/* tslint:disable */
/* eslint-disable */
/*
Carbon

Connect external data to LLMs, no matter the source.

The version of the OpenAPI document: 1.0.0


NOTE: This file is auto generated by Konfig (https://konfigthis.com).
*/

import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction, isBrowser } from '../common';
import { fromBuffer } from "file-type/browser"
const FormData = require("form-data")
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { AuthenticationProperty } from '../models';
// @ts-ignore
import { ConnectDataSourceInput } from '../models';
// @ts-ignore
import { ConnectDataSourceResponse } from '../models';
// @ts-ignore
import { DataSourceType } from '../models';
// @ts-ignore
import { EmbeddingGenerators } from '../models';
// @ts-ignore
import { EmbeddingGeneratorsNullable } from '../models';
// @ts-ignore
import { ExternalSourceItemsOrderBy } from '../models';
// @ts-ignore
import { FreshDeskConnectRequest } from '../models';
// @ts-ignore
import { GenericSuccessResponse } from '../models';
// @ts-ignore
import { GitbookConnectRequest } from '../models';
// @ts-ignore
import { GitbookSyncRequest } from '../models';
// @ts-ignore
import { GithubConnectRequest } from '../models';
// @ts-ignore
import { GithubFetchReposRequest } from '../models';
// @ts-ignore
import { GmailSyncInput } from '../models';
// @ts-ignore
import { HTTPValidationError } from '../models';
// @ts-ignore
import { HelpdeskFileSyncConfigNullable } from '../models';
// @ts-ignore
import { IdsProperty } from '../models';
// @ts-ignore
import { ListDataSourceItemsRequest } from '../models';
// @ts-ignore
import { ListDataSourceItemsResponse } from '../models';
// @ts-ignore
import { ListItemsFiltersNullable } from '../models';
// @ts-ignore
import { ListRequest } from '../models';
// @ts-ignore
import { ListResponse } from '../models';
// @ts-ignore
import { OAuthURLRequest } from '../models';
// @ts-ignore
import { OrderDirV2 } from '../models';
// @ts-ignore
import { OrganizationUserDataSourceAPI } from '../models';
// @ts-ignore
import { OuthURLResponse } from '../models';
// @ts-ignore
import { OutlookSyncInput } from '../models';
// @ts-ignore
import { Pagination } from '../models';
// @ts-ignore
import { RSSFeedInput } from '../models';
// @ts-ignore
import { S3AuthRequest } from '../models';
// @ts-ignore
import { S3FileSyncInput } from '../models';
// @ts-ignore
import { S3GetFileInput } from '../models';
// @ts-ignore
import { SyncDirectoryRequest } from '../models';
// @ts-ignore
import { SyncFilesRequest } from '../models';
// @ts-ignore
import { SyncOptions } from '../models';
import { paginate } from "../pagination/paginate";
import type * as buffer from "buffer"
import { requestBeforeHook } from '../requestBeforeHook';
/**
 * IntegrationsApi - axios parameter creator
 * @export
 */
export const IntegrationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Connect Data Source
         * @param {ConnectDataSourceInput} connectDataSourceInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectDataSource: async (connectDataSourceInput: ConnectDataSourceInput, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectDataSourceInput' is not null or undefined
            assertParamExists('connectDataSource', 'connectDataSourceInput', connectDataSourceInput)
            const localVarPath = `/integrations/connect`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "authorization", keyParamName: "accessToken", configuration, prefix: "Token " })
            // authentication apiKey required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "authorization", keyParamName: "apiKey", configuration, prefix: "Bearer " })
            // authentication customerId required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "customer-id", keyParamName: "customerId", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: connectDataSourceInput,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/integrations/connect',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(connectDataSourceInput, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Refer this article to obtain an API key https://support.freshdesk.com/en/support/solutions/articles/215517. Make sure that your API key has the permission to read solutions from your account and you are on a <b>paid</b> plan. Once you have an API key, you can make a request to this endpoint along with your freshdesk domain. This will  trigger an automatic sync of the articles in your \"solutions\" tab. Additional parameters below can be used to associate  data with the synced articles or modify the sync behavior.
         * @summary Freshdesk Connect
         * @param {FreshDeskConnectRequest} freshDeskConnectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectFreshdesk: async (freshDeskConnectRequest: FreshDeskConnectRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'freshDeskConnectRequest' is not null or undefined
            assertParamExists('connectFreshdesk', 'freshDeskConnectRequest', freshDeskConnectRequest)
            const localVarPath = `/integrations/freshdesk`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "authorization", keyParamName: "accessToken", configuration, prefix: "Token " })
            // authentication apiKey required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "authorization", keyParamName: "apiKey", configuration, prefix: "Bearer " })
            // authentication customerId required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "customer-id", keyParamName: "customerId", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: freshDeskConnectRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/integrations/freshdesk',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(freshDeskConnectRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * You will need an access token to connect your Gitbook account. Note that the permissions will be defined by the user  generating access token so make sure you have the permission to access spaces you will be syncing.  Refer this article for more details https://developer.gitbook.com/gitbook-api/authentication. Additionally, you need to specify the name of organization you will be syncing data from.
         * @summary Gitbook Connect
         * @param {GitbookConnectRequest} gitbookConnectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectGitbook: async (gitbookConnectRequest: GitbookConnectRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'gitbookConnectRequest' is not null or undefined
            assertParamExists('connectGitbook', 'gitbookConnectRequest', gitbookConnectRequest)
            const localVarPath = `/integrations/gitbook`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "authorization", keyParamName: "accessToken", configuration, prefix: "Token " })
            // authentication apiKey required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "authorization", keyParamName: "apiKey", configuration, prefix: "Bearer " })
            // authentication customerId required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "customer-id", keyParamName: "customerId", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: gitbookConnectRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/integrations/gitbook',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(gitbookConnectRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new IAM user with permissions to: <ol> <li>List all buckets.</li> <li>Read from the specific buckets and objects to sync with Carbon. Ensure any future buckets or objects carry  the same permissions.</li> </ol> Once created, generate an access key for this user and share the credentials with us. We recommend testing this key beforehand.
         * @summary S3 Auth
         * @param {S3AuthRequest} s3AuthRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAwsIamUser: async (s3AuthRequest: S3AuthRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 's3AuthRequest' is not null or undefined
            assertParamExists('createAwsIamUser', 's3AuthRequest', s3AuthRequest)
            const localVarPath = `/integrations/s3`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "authorization", keyParamName: "accessToken", configuration, prefix: "Token " })
            // authentication apiKey required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "authorization", keyParamName: "apiKey", configuration, prefix: "Bearer " })
            // authentication customerId required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "customer-id", keyParamName: "customerId", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: s3AuthRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/integrations/s3',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(s3AuthRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint can be used to generate the following URLs - An OAuth URL for OAuth based connectors - A file syncing URL which skips the OAuth flow if the user already has a valid access token and takes them to the success state.
         * @summary Get Oauth Url
         * @param {OAuthURLRequest} oAuthURLRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOauthUrl: async (oAuthURLRequest: OAuthURLRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'oAuthURLRequest' is not null or undefined
            assertParamExists('getOauthUrl', 'oAuthURLRequest', oAuthURLRequest)
            const localVarPath = `/integrations/oauth_url`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "authorization", keyParamName: "accessToken", configuration, prefix: "Token " })
            // authentication apiKey required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "authorization", keyParamName: "apiKey", configuration, prefix: "Bearer " })
            // authentication customerId required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "customer-id", keyParamName: "customerId", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: oAuthURLRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/integrations/oauth_url',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(oAuthURLRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * To begin listing a user\'s Confluence pages, at least a `data_source_id` of a connected Confluence account must be specified. This base request returns a list of root pages for every space the user has access to in a Confluence instance. To traverse further down the user\'s page directory, additional requests to this endpoint can be made with the same `data_source_id` and with `parent_id` set to the id of page from a previous request. For convenience, the `has_children` property in each directory item in the response list will flag which pages will return non-empty lists of pages when set as the `parent_id`.
         * @summary Confluence List
         * @param {ListRequest} listRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConfluencePages: async (listRequest: ListRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listRequest' is not null or undefined
            assertParamExists('listConfluencePages', 'listRequest', listRequest)
            const localVarPath = `/integrations/confluence/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "authorization", keyParamName: "accessToken", configuration, prefix: "Token " })
            // authentication apiKey required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "authorization", keyParamName: "apiKey", configuration, prefix: "Bearer " })
            // authentication customerId required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "customer-id", keyParamName: "customerId", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: listRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/integrations/confluence/list',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(listRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Data Source Items
         * @param {ListDataSourceItemsRequest} listDataSourceItemsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDataSourceItems: async (listDataSourceItemsRequest: ListDataSourceItemsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listDataSourceItemsRequest' is not null or undefined
            assertParamExists('listDataSourceItems', 'listDataSourceItemsRequest', listDataSourceItemsRequest)
            const localVarPath = `/integrations/items/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "authorization", keyParamName: "accessToken", configuration, prefix: "Token " })
            // authentication apiKey required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "authorization", keyParamName: "apiKey", configuration, prefix: "Bearer " })
            // authentication customerId required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "customer-id", keyParamName: "customerId", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: listDataSourceItemsRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/integrations/items/list',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(listDataSourceItemsRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * After connecting your Outlook account, you can use this endpoint to list all of your folders on outlook. This includes  both system folders like \"inbox\" and user created folders.
         * @summary Outlook Folders
         * @param {number} [dataSourceId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFolders: async (dataSourceId?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/integrations/outlook/user_folders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "authorization", keyParamName: "accessToken", configuration, prefix: "Token " })
            // authentication apiKey required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "authorization", keyParamName: "apiKey", configuration, prefix: "Bearer " })
            // authentication customerId required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "customer-id", keyParamName: "customerId", configuration })
            if (dataSourceId !== undefined) {
                localVarQueryParameter['data_source_id'] = dataSourceId;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/integrations/outlook/user_folders',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * After connecting your Gitbook account, you can use this endpoint to list all of your spaces under current organization.
         * @summary Gitbook Spaces
         * @param {number} dataSourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGitbookSpaces: async (dataSourceId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists('listGitbookSpaces', 'dataSourceId', dataSourceId)
            const localVarPath = `/integrations/gitbook/spaces`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "authorization", keyParamName: "accessToken", configuration, prefix: "Token " })
            // authentication apiKey required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "authorization", keyParamName: "apiKey", configuration, prefix: "Bearer " })
            // authentication customerId required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "customer-id", keyParamName: "customerId", configuration })
            if (dataSourceId !== undefined) {
                localVarQueryParameter['data_source_id'] = dataSourceId;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/integrations/gitbook/spaces',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * After connecting your Gmail account, you can use this endpoint to list all of your labels. User created labels will have the type \"user\" and Gmail\'s default labels will have the type \"system\"
         * @summary Gmail Labels
         * @param {number} [dataSourceId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLabels: async (dataSourceId?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/integrations/gmail/user_labels`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "authorization", keyParamName: "accessToken", configuration, prefix: "Token " })
            // authentication apiKey required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "authorization", keyParamName: "apiKey", configuration, prefix: "Bearer " })
            // authentication customerId required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "customer-id", keyParamName: "customerId", configuration })
            if (dataSourceId !== undefined) {
                localVarQueryParameter['data_source_id'] = dataSourceId;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/integrations/gmail/user_labels',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * After connecting your Outlook account, you can use this endpoint to list all of your categories on outlook. We currently support listing up to 250 categories.
         * @summary Outlook Categories
         * @param {number} [dataSourceId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOutlookCategories: async (dataSourceId?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/integrations/outlook/user_categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "authorization", keyParamName: "accessToken", configuration, prefix: "Token " })
            // authentication apiKey required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "authorization", keyParamName: "apiKey", configuration, prefix: "Bearer " })
            // authentication customerId required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "customer-id", keyParamName: "customerId", configuration })
            if (dataSourceId !== undefined) {
                localVarQueryParameter['data_source_id'] = dataSourceId;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/integrations/outlook/user_categories',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Once you have connected your GitHub account, you can use this endpoint to list the      repositories your account has access to. You can use a data source ID or username to fetch from a specific account.
         * @summary Github List Repos
         * @param {number} [perPage] 
         * @param {number} [page] 
         * @param {number} [dataSourceId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRepos: async (perPage?: number, page?: number, dataSourceId?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/integrations/github/repos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "authorization", keyParamName: "accessToken", configuration, prefix: "Token " })
            // authentication apiKey required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "authorization", keyParamName: "apiKey", configuration, prefix: "Bearer " })
            // authentication customerId required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "customer-id", keyParamName: "customerId", configuration })
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (dataSourceId !== undefined) {
                localVarQueryParameter['data_source_id'] = dataSourceId;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/integrations/github/repos',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * After listing pages in a user\'s Confluence account, the set of selected page `ids` and the connected account\'s `data_source_id` can be passed into this endpoint to sync them into Carbon. Additional parameters listed below can be used to associate data to the selected pages or alter the behavior of the sync.
         * @summary Confluence Sync
         * @param {SyncFilesRequest} syncFilesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncConfluence: async (syncFilesRequest: SyncFilesRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'syncFilesRequest' is not null or undefined
            assertParamExists('syncConfluence', 'syncFilesRequest', syncFilesRequest)
            const localVarPath = `/integrations/confluence/sync`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "authorization", keyParamName: "accessToken", configuration, prefix: "Token " })
            // authentication apiKey required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "authorization", keyParamName: "apiKey", configuration, prefix: "Bearer " })
            // authentication customerId required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "customer-id", keyParamName: "customerId", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: syncFilesRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/integrations/confluence/sync',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(syncFilesRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Sync Data Source Items
         * @param {SyncDirectoryRequest} syncDirectoryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncDataSourceItems: async (syncDirectoryRequest: SyncDirectoryRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'syncDirectoryRequest' is not null or undefined
            assertParamExists('syncDataSourceItems', 'syncDirectoryRequest', syncDirectoryRequest)
            const localVarPath = `/integrations/items/sync`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "authorization", keyParamName: "accessToken", configuration, prefix: "Token " })
            // authentication apiKey required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "authorization", keyParamName: "apiKey", configuration, prefix: "Bearer " })
            // authentication customerId required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "customer-id", keyParamName: "customerId", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: syncDirectoryRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/integrations/items/sync',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(syncDirectoryRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * After listing files and folders via /integrations/items/sync and integrations/items/list, use the selected items\' external ids  as the ids in this endpoint to sync them into Carbon. Sharepoint items take an additional parameter root_id, which identifies the drive the file or folder is in and is stored in root_external_id. That additional paramter is optional and excluding it will tell the sync to assume the item is stored in the default Documents drive.
         * @summary Sync Files
         * @param {SyncFilesRequest} syncFilesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncFiles: async (syncFilesRequest: SyncFilesRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'syncFilesRequest' is not null or undefined
            assertParamExists('syncFiles', 'syncFilesRequest', syncFilesRequest)
            const localVarPath = `/integrations/files/sync`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "authorization", keyParamName: "accessToken", configuration, prefix: "Token " })
            // authentication apiKey required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "authorization", keyParamName: "apiKey", configuration, prefix: "Bearer " })
            // authentication customerId required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "customer-id", keyParamName: "customerId", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: syncFilesRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/integrations/files/sync',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(syncFilesRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Refer this article to obtain an access token https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/managing-your-personal-access-tokens. Make sure that your access token has the permission to read content from your desired repos. Note that if your access token expires you will need to manually update it through this endpoint.
         * @summary Github Connect
         * @param {GithubConnectRequest} githubConnectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncGitHub: async (githubConnectRequest: GithubConnectRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'githubConnectRequest' is not null or undefined
            assertParamExists('syncGitHub', 'githubConnectRequest', githubConnectRequest)
            const localVarPath = `/integrations/github`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "authorization", keyParamName: "accessToken", configuration, prefix: "Token " })
            // authentication apiKey required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "authorization", keyParamName: "apiKey", configuration, prefix: "Bearer " })
            // authentication customerId required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "customer-id", keyParamName: "customerId", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: githubConnectRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/integrations/github',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(githubConnectRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * You can sync upto 20 Gitbook spaces at a time using this endpoint. Additional parameters below can be used to associate  data with the synced pages or modify the sync behavior.
         * @summary Gitbook Sync
         * @param {GitbookSyncRequest} gitbookSyncRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncGitbook: async (gitbookSyncRequest: GitbookSyncRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'gitbookSyncRequest' is not null or undefined
            assertParamExists('syncGitbook', 'gitbookSyncRequest', gitbookSyncRequest)
            const localVarPath = `/integrations/gitbook/sync`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "authorization", keyParamName: "accessToken", configuration, prefix: "Token " })
            // authentication apiKey required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "authorization", keyParamName: "apiKey", configuration, prefix: "Bearer " })
            // authentication customerId required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "customer-id", keyParamName: "customerId", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: gitbookSyncRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/integrations/gitbook/sync',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(gitbookSyncRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Once you have successfully connected your gmail account, you can choose which emails to sync with us using the filters parameter. Filters is a JSON object with key value pairs. It also supports AND and OR operations. For now, we support a limited set of keys listed below.  <b>label</b>: Inbuilt Gmail labels, for example \"Important\" or a custom label you created.   <b>after</b> or <b>before</b>: A date in YYYY/mm/dd format (example 2023/12/31). Gets emails after/before a certain date. You can also use them in combination to get emails from a certain period.   <b>is</b>: Can have the following values - starred, important, snoozed, and unread    Using keys or values outside of the specified values can lead to unexpected behaviour.  An example of a basic query with filters can be ```json {     \"filters\": {             \"key\": \"label\",             \"value\": \"Test\"         } } ``` Which will list all emails that have the label \"Test\".  You can use AND and OR operation in the following way: ```json {     \"filters\": {         \"AND\": [             {                 \"key\": \"after\",                 \"value\": \"2024/01/07\"             },             {                 \"OR\": [                     {                         \"key\": \"label\",                         \"value\": \"Personal\"                     },                     {                         \"key\": \"is\",                         \"value\": \"starred\"                     }                 ]             }         ]     } } ``` This will return emails after 7th of Jan that are either starred or have the label \"Personal\".  Note that this is the highest level of nesting we support, i.e. you can\'t add more AND/OR filters within the OR filter in the above example.
         * @summary Gmail Sync
         * @param {GmailSyncInput} gmailSyncInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncGmail: async (gmailSyncInput: GmailSyncInput, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'gmailSyncInput' is not null or undefined
            assertParamExists('syncGmail', 'gmailSyncInput', gmailSyncInput)
            const localVarPath = `/integrations/gmail/sync`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "authorization", keyParamName: "accessToken", configuration, prefix: "Token " })
            // authentication apiKey required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "authorization", keyParamName: "apiKey", configuration, prefix: "Bearer " })
            // authentication customerId required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "customer-id", keyParamName: "customerId", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: gmailSyncInput,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/integrations/gmail/sync',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(gmailSyncInput, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Once you have successfully connected your Outlook account, you can choose which emails to sync with us using the filters and folder parameter. \"folder\" should be the folder you want to sync from Outlook. By default we get messages from your inbox folder.   Filters is a JSON object with key value pairs. It also supports AND and OR operations. For now, we support a limited set of keys listed below.  <b>category</b>: Custom categories that you created in Outlook.   <b>after</b> or <b>before</b>: A date in YYYY/mm/dd format (example 2023/12/31). Gets emails after/before a certain date. You can also use them in combination to get emails from a certain period.     <b>is</b>: Can have the following values: flagged     An example of a basic query with filters can be ```json {     \"filters\": {             \"key\": \"category\",             \"value\": \"Test\"         } } ``` Which will list all emails that have the category \"Test\".    Specifying a custom folder in the same query ```json {     \"folder\": \"Folder Name\",     \"filters\": {             \"key\": \"category\",             \"value\": \"Test\"         } } ```  You can use AND and OR operation in the following way: ```json {     \"filters\": {         \"AND\": [             {                 \"key\": \"after\",                 \"value\": \"2024/01/07\"             },             {                 \"OR\": [                     {                         \"key\": \"category\",                         \"value\": \"Personal\"                     },                     {                         \"key\": \"category\",                         \"value\": \"Test\"                     },                 ]             }         ]     } } ``` This will return emails after 7th of Jan that have either Personal or Test as category.  Note that this is the highest level of nesting we support, i.e. you can\'t add more AND/OR filters within the OR filter in the above example.
         * @summary Outlook Sync
         * @param {OutlookSyncInput} outlookSyncInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncOutlook: async (outlookSyncInput: OutlookSyncInput, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'outlookSyncInput' is not null or undefined
            assertParamExists('syncOutlook', 'outlookSyncInput', outlookSyncInput)
            const localVarPath = `/integrations/outlook/sync`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "authorization", keyParamName: "accessToken", configuration, prefix: "Token " })
            // authentication apiKey required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "authorization", keyParamName: "apiKey", configuration, prefix: "Bearer " })
            // authentication customerId required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "customer-id", keyParamName: "customerId", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: outlookSyncInput,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/integrations/outlook/sync',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(outlookSyncInput, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * You can retreive repos your token has access to using /integrations/github/repos and sync their content.  You can also pass full name of any public repository (username/repo-name). This will store the repo content with  carbon which can be accessed through /integrations/items/list endpoint. Maximum of 25 repositories are accepted per request.
         * @summary Github Sync Repos
         * @param {GithubFetchReposRequest} githubFetchReposRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncRepos: async (githubFetchReposRequest: GithubFetchReposRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'githubFetchReposRequest' is not null or undefined
            assertParamExists('syncRepos', 'githubFetchReposRequest', githubFetchReposRequest)
            const localVarPath = `/integrations/github/sync_repos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "authorization", keyParamName: "accessToken", configuration, prefix: "Token " })
            // authentication apiKey required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "authorization", keyParamName: "apiKey", configuration, prefix: "Bearer " })
            // authentication customerId required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "customer-id", keyParamName: "customerId", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: githubFetchReposRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/integrations/github/sync_repos',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(githubFetchReposRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Rss Feed
         * @param {RSSFeedInput} rSSFeedInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncRssFeed: async (rSSFeedInput: RSSFeedInput, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rSSFeedInput' is not null or undefined
            assertParamExists('syncRssFeed', 'rSSFeedInput', rSSFeedInput)
            const localVarPath = `/integrations/rss_feed`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "authorization", keyParamName: "accessToken", configuration, prefix: "Token " })
            // authentication apiKey required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "authorization", keyParamName: "apiKey", configuration, prefix: "Bearer " })
            // authentication customerId required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "customer-id", keyParamName: "customerId", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: rSSFeedInput,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/integrations/rss_feed',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(rSSFeedInput, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * After optionally loading the items via /integrations/items/sync and integrations/items/list, use the bucket name  and object key as the ID in this endpoint to sync them into Carbon. Additional parameters below can associate  data with the selected items or modify the sync behavior
         * @summary S3 Files
         * @param {S3FileSyncInput} s3FileSyncInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncS3Files: async (s3FileSyncInput: S3FileSyncInput, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 's3FileSyncInput' is not null or undefined
            assertParamExists('syncS3Files', 's3FileSyncInput', s3FileSyncInput)
            const localVarPath = `/integrations/s3/files`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "authorization", keyParamName: "accessToken", configuration, prefix: "Token " })
            // authentication apiKey required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "authorization", keyParamName: "apiKey", configuration, prefix: "Bearer " })
            // authentication customerId required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "customer-id", keyParamName: "customerId", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: s3FileSyncInput,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/integrations/s3/files',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(s3FileSyncInput, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IntegrationsApi - functional programming interface
 * @export
 */
export const IntegrationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IntegrationsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Connect Data Source
         * @param {IntegrationsApiConnectDataSourceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async connectDataSource(requestParameters: IntegrationsApiConnectDataSourceRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectDataSourceResponse>> {
            const connectDataSourceInput: ConnectDataSourceInput = {
                authentication: requestParameters.authentication,
                sync_options: requestParameters.sync_options
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.connectDataSource(connectDataSourceInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Refer this article to obtain an API key https://support.freshdesk.com/en/support/solutions/articles/215517. Make sure that your API key has the permission to read solutions from your account and you are on a <b>paid</b> plan. Once you have an API key, you can make a request to this endpoint along with your freshdesk domain. This will  trigger an automatic sync of the articles in your \"solutions\" tab. Additional parameters below can be used to associate  data with the synced articles or modify the sync behavior.
         * @summary Freshdesk Connect
         * @param {IntegrationsApiConnectFreshdeskRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async connectFreshdesk(requestParameters: IntegrationsApiConnectFreshdeskRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericSuccessResponse>> {
            const freshDeskConnectRequest: FreshDeskConnectRequest = {
                tags: requestParameters.tags,
                domain: requestParameters.domain,
                api_key: requestParameters.api_key,
                chunk_size: requestParameters.chunk_size,
                chunk_overlap: requestParameters.chunk_overlap,
                skip_embedding_generation: requestParameters.skip_embedding_generation,
                embedding_model: requestParameters.embedding_model,
                generate_sparse_vectors: requestParameters.generate_sparse_vectors,
                prepend_filename_to_chunks: requestParameters.prepend_filename_to_chunks,
                sync_files_on_connection: requestParameters.sync_files_on_connection,
                request_id: requestParameters.request_id,
                sync_source_items: requestParameters.sync_source_items
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.connectFreshdesk(freshDeskConnectRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * You will need an access token to connect your Gitbook account. Note that the permissions will be defined by the user  generating access token so make sure you have the permission to access spaces you will be syncing.  Refer this article for more details https://developer.gitbook.com/gitbook-api/authentication. Additionally, you need to specify the name of organization you will be syncing data from.
         * @summary Gitbook Connect
         * @param {IntegrationsApiConnectGitbookRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async connectGitbook(requestParameters: IntegrationsApiConnectGitbookRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericSuccessResponse>> {
            const gitbookConnectRequest: GitbookConnectRequest = {
                tags: requestParameters.tags,
                organization: requestParameters.organization,
                access_token: requestParameters.access_token,
                chunk_size: requestParameters.chunk_size,
                chunk_overlap: requestParameters.chunk_overlap,
                skip_embedding_generation: requestParameters.skip_embedding_generation,
                embedding_model: requestParameters.embedding_model,
                generate_sparse_vectors: requestParameters.generate_sparse_vectors,
                prepend_filename_to_chunks: requestParameters.prepend_filename_to_chunks,
                sync_files_on_connection: requestParameters.sync_files_on_connection,
                request_id: requestParameters.request_id,
                sync_source_items: requestParameters.sync_source_items
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.connectGitbook(gitbookConnectRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new IAM user with permissions to: <ol> <li>List all buckets.</li> <li>Read from the specific buckets and objects to sync with Carbon. Ensure any future buckets or objects carry  the same permissions.</li> </ol> Once created, generate an access key for this user and share the credentials with us. We recommend testing this key beforehand.
         * @summary S3 Auth
         * @param {IntegrationsApiCreateAwsIamUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAwsIamUser(requestParameters: IntegrationsApiCreateAwsIamUserRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationUserDataSourceAPI>> {
            const s3AuthRequest: S3AuthRequest = {
                access_key: requestParameters.access_key,
                access_key_secret: requestParameters.access_key_secret,
                sync_source_items: requestParameters.sync_source_items
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAwsIamUser(s3AuthRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint can be used to generate the following URLs - An OAuth URL for OAuth based connectors - A file syncing URL which skips the OAuth flow if the user already has a valid access token and takes them to the success state.
         * @summary Get Oauth Url
         * @param {IntegrationsApiGetOauthUrlRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOauthUrl(requestParameters: IntegrationsApiGetOauthUrlRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OuthURLResponse>> {
            const oAuthURLRequest: OAuthURLRequest = {
                tags: requestParameters.tags,
                scope: requestParameters.scope,
                service: requestParameters.service,
                chunk_size: requestParameters.chunk_size,
                chunk_overlap: requestParameters.chunk_overlap,
                skip_embedding_generation: requestParameters.skip_embedding_generation,
                embedding_model: requestParameters.embedding_model,
                zendesk_subdomain: requestParameters.zendesk_subdomain,
                microsoft_tenant: requestParameters.microsoft_tenant,
                sharepoint_site_name: requestParameters.sharepoint_site_name,
                confluence_subdomain: requestParameters.confluence_subdomain,
                generate_sparse_vectors: requestParameters.generate_sparse_vectors,
                prepend_filename_to_chunks: requestParameters.prepend_filename_to_chunks,
                max_items_per_chunk: requestParameters.max_items_per_chunk,
                salesforce_domain: requestParameters.salesforce_domain,
                sync_files_on_connection: requestParameters.sync_files_on_connection,
                set_page_as_boundary: requestParameters.set_page_as_boundary,
                data_source_id: requestParameters.data_source_id,
                connecting_new_account: requestParameters.connecting_new_account,
                request_id: requestParameters.request_id,
                use_ocr: requestParameters.use_ocr,
                parse_pdf_tables_with_ocr: requestParameters.parse_pdf_tables_with_ocr,
                enable_file_picker: requestParameters.enable_file_picker,
                sync_source_items: requestParameters.sync_source_items,
                incremental_sync: requestParameters.incremental_sync,
                file_sync_config: requestParameters.file_sync_config
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOauthUrl(oAuthURLRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * To begin listing a user\'s Confluence pages, at least a `data_source_id` of a connected Confluence account must be specified. This base request returns a list of root pages for every space the user has access to in a Confluence instance. To traverse further down the user\'s page directory, additional requests to this endpoint can be made with the same `data_source_id` and with `parent_id` set to the id of page from a previous request. For convenience, the `has_children` property in each directory item in the response list will flag which pages will return non-empty lists of pages when set as the `parent_id`.
         * @summary Confluence List
         * @param {IntegrationsApiListConfluencePagesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listConfluencePages(requestParameters: IntegrationsApiListConfluencePagesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListResponse>> {
            const listRequest: ListRequest = {
                data_source_id: requestParameters.data_source_id,
                parent_id: requestParameters.parent_id
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.listConfluencePages(listRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Data Source Items
         * @param {IntegrationsApiListDataSourceItemsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDataSourceItems(requestParameters: IntegrationsApiListDataSourceItemsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListDataSourceItemsResponse>> {
            const listDataSourceItemsRequest: ListDataSourceItemsRequest = {
                data_source_id: requestParameters.data_source_id,
                parent_id: requestParameters.parent_id,
                filters: requestParameters.filters,
                pagination: requestParameters.pagination,
                order_by: requestParameters.order_by,
                order_dir: requestParameters.order_dir
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDataSourceItems(listDataSourceItemsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * After connecting your Outlook account, you can use this endpoint to list all of your folders on outlook. This includes  both system folders like \"inbox\" and user created folders.
         * @summary Outlook Folders
         * @param {IntegrationsApiListFoldersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listFolders(requestParameters: IntegrationsApiListFoldersRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listFolders(requestParameters.dataSourceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * After connecting your Gitbook account, you can use this endpoint to list all of your spaces under current organization.
         * @summary Gitbook Spaces
         * @param {IntegrationsApiListGitbookSpacesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGitbookSpaces(requestParameters: IntegrationsApiListGitbookSpacesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listGitbookSpaces(requestParameters.dataSourceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * After connecting your Gmail account, you can use this endpoint to list all of your labels. User created labels will have the type \"user\" and Gmail\'s default labels will have the type \"system\"
         * @summary Gmail Labels
         * @param {IntegrationsApiListLabelsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listLabels(requestParameters: IntegrationsApiListLabelsRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listLabels(requestParameters.dataSourceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * After connecting your Outlook account, you can use this endpoint to list all of your categories on outlook. We currently support listing up to 250 categories.
         * @summary Outlook Categories
         * @param {IntegrationsApiListOutlookCategoriesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOutlookCategories(requestParameters: IntegrationsApiListOutlookCategoriesRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOutlookCategories(requestParameters.dataSourceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Once you have connected your GitHub account, you can use this endpoint to list the      repositories your account has access to. You can use a data source ID or username to fetch from a specific account.
         * @summary Github List Repos
         * @param {IntegrationsApiListReposRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRepos(requestParameters: IntegrationsApiListReposRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRepos(requestParameters.perPage, requestParameters.page, requestParameters.dataSourceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * After listing pages in a user\'s Confluence account, the set of selected page `ids` and the connected account\'s `data_source_id` can be passed into this endpoint to sync them into Carbon. Additional parameters listed below can be used to associate data to the selected pages or alter the behavior of the sync.
         * @summary Confluence Sync
         * @param {IntegrationsApiSyncConfluenceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async syncConfluence(requestParameters: IntegrationsApiSyncConfluenceRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericSuccessResponse>> {
            const syncFilesRequest: SyncFilesRequest = {
                tags: requestParameters.tags,
                data_source_id: requestParameters.data_source_id,
                ids: requestParameters.ids,
                chunk_size: requestParameters.chunk_size,
                chunk_overlap: requestParameters.chunk_overlap,
                skip_embedding_generation: requestParameters.skip_embedding_generation,
                embedding_model: requestParameters.embedding_model,
                generate_sparse_vectors: requestParameters.generate_sparse_vectors,
                prepend_filename_to_chunks: requestParameters.prepend_filename_to_chunks,
                max_items_per_chunk: requestParameters.max_items_per_chunk,
                set_page_as_boundary: requestParameters.set_page_as_boundary,
                request_id: requestParameters.request_id,
                use_ocr: requestParameters.use_ocr,
                parse_pdf_tables_with_ocr: requestParameters.parse_pdf_tables_with_ocr,
                incremental_sync: requestParameters.incremental_sync
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.syncConfluence(syncFilesRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Sync Data Source Items
         * @param {IntegrationsApiSyncDataSourceItemsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async syncDataSourceItems(requestParameters: IntegrationsApiSyncDataSourceItemsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationUserDataSourceAPI>> {
            const syncDirectoryRequest: SyncDirectoryRequest = {
                data_source_id: requestParameters.data_source_id
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.syncDataSourceItems(syncDirectoryRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * After listing files and folders via /integrations/items/sync and integrations/items/list, use the selected items\' external ids  as the ids in this endpoint to sync them into Carbon. Sharepoint items take an additional parameter root_id, which identifies the drive the file or folder is in and is stored in root_external_id. That additional paramter is optional and excluding it will tell the sync to assume the item is stored in the default Documents drive.
         * @summary Sync Files
         * @param {IntegrationsApiSyncFilesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async syncFiles(requestParameters: IntegrationsApiSyncFilesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericSuccessResponse>> {
            const syncFilesRequest: SyncFilesRequest = {
                tags: requestParameters.tags,
                data_source_id: requestParameters.data_source_id,
                ids: requestParameters.ids,
                chunk_size: requestParameters.chunk_size,
                chunk_overlap: requestParameters.chunk_overlap,
                skip_embedding_generation: requestParameters.skip_embedding_generation,
                embedding_model: requestParameters.embedding_model,
                generate_sparse_vectors: requestParameters.generate_sparse_vectors,
                prepend_filename_to_chunks: requestParameters.prepend_filename_to_chunks,
                max_items_per_chunk: requestParameters.max_items_per_chunk,
                set_page_as_boundary: requestParameters.set_page_as_boundary,
                request_id: requestParameters.request_id,
                use_ocr: requestParameters.use_ocr,
                parse_pdf_tables_with_ocr: requestParameters.parse_pdf_tables_with_ocr,
                incremental_sync: requestParameters.incremental_sync
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.syncFiles(syncFilesRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Refer this article to obtain an access token https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/managing-your-personal-access-tokens. Make sure that your access token has the permission to read content from your desired repos. Note that if your access token expires you will need to manually update it through this endpoint.
         * @summary Github Connect
         * @param {IntegrationsApiSyncGitHubRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async syncGitHub(requestParameters: IntegrationsApiSyncGitHubRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericSuccessResponse>> {
            const githubConnectRequest: GithubConnectRequest = {
                username: requestParameters.username,
                access_token: requestParameters.access_token,
                sync_source_items: requestParameters.sync_source_items
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.syncGitHub(githubConnectRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * You can sync upto 20 Gitbook spaces at a time using this endpoint. Additional parameters below can be used to associate  data with the synced pages or modify the sync behavior.
         * @summary Gitbook Sync
         * @param {IntegrationsApiSyncGitbookRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async syncGitbook(requestParameters: IntegrationsApiSyncGitbookRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const gitbookSyncRequest: GitbookSyncRequest = {
                tags: requestParameters.tags,
                space_ids: requestParameters.space_ids,
                data_source_id: requestParameters.data_source_id,
                chunk_size: requestParameters.chunk_size,
                chunk_overlap: requestParameters.chunk_overlap,
                skip_embedding_generation: requestParameters.skip_embedding_generation,
                embedding_model: requestParameters.embedding_model,
                generate_sparse_vectors: requestParameters.generate_sparse_vectors,
                prepend_filename_to_chunks: requestParameters.prepend_filename_to_chunks,
                request_id: requestParameters.request_id
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.syncGitbook(gitbookSyncRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Once you have successfully connected your gmail account, you can choose which emails to sync with us using the filters parameter. Filters is a JSON object with key value pairs. It also supports AND and OR operations. For now, we support a limited set of keys listed below.  <b>label</b>: Inbuilt Gmail labels, for example \"Important\" or a custom label you created.   <b>after</b> or <b>before</b>: A date in YYYY/mm/dd format (example 2023/12/31). Gets emails after/before a certain date. You can also use them in combination to get emails from a certain period.   <b>is</b>: Can have the following values - starred, important, snoozed, and unread    Using keys or values outside of the specified values can lead to unexpected behaviour.  An example of a basic query with filters can be ```json {     \"filters\": {             \"key\": \"label\",             \"value\": \"Test\"         } } ``` Which will list all emails that have the label \"Test\".  You can use AND and OR operation in the following way: ```json {     \"filters\": {         \"AND\": [             {                 \"key\": \"after\",                 \"value\": \"2024/01/07\"             },             {                 \"OR\": [                     {                         \"key\": \"label\",                         \"value\": \"Personal\"                     },                     {                         \"key\": \"is\",                         \"value\": \"starred\"                     }                 ]             }         ]     } } ``` This will return emails after 7th of Jan that are either starred or have the label \"Personal\".  Note that this is the highest level of nesting we support, i.e. you can\'t add more AND/OR filters within the OR filter in the above example.
         * @summary Gmail Sync
         * @param {IntegrationsApiSyncGmailRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async syncGmail(requestParameters: IntegrationsApiSyncGmailRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericSuccessResponse>> {
            const gmailSyncInput: GmailSyncInput = {
                tags: requestParameters.tags,
                filters: requestParameters.filters,
                chunk_size: requestParameters.chunk_size,
                chunk_overlap: requestParameters.chunk_overlap,
                skip_embedding_generation: requestParameters.skip_embedding_generation,
                embedding_model: requestParameters.embedding_model,
                generate_sparse_vectors: requestParameters.generate_sparse_vectors,
                prepend_filename_to_chunks: requestParameters.prepend_filename_to_chunks,
                data_source_id: requestParameters.data_source_id,
                request_id: requestParameters.request_id,
                sync_attachments: requestParameters.sync_attachments
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.syncGmail(gmailSyncInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Once you have successfully connected your Outlook account, you can choose which emails to sync with us using the filters and folder parameter. \"folder\" should be the folder you want to sync from Outlook. By default we get messages from your inbox folder.   Filters is a JSON object with key value pairs. It also supports AND and OR operations. For now, we support a limited set of keys listed below.  <b>category</b>: Custom categories that you created in Outlook.   <b>after</b> or <b>before</b>: A date in YYYY/mm/dd format (example 2023/12/31). Gets emails after/before a certain date. You can also use them in combination to get emails from a certain period.     <b>is</b>: Can have the following values: flagged     An example of a basic query with filters can be ```json {     \"filters\": {             \"key\": \"category\",             \"value\": \"Test\"         } } ``` Which will list all emails that have the category \"Test\".    Specifying a custom folder in the same query ```json {     \"folder\": \"Folder Name\",     \"filters\": {             \"key\": \"category\",             \"value\": \"Test\"         } } ```  You can use AND and OR operation in the following way: ```json {     \"filters\": {         \"AND\": [             {                 \"key\": \"after\",                 \"value\": \"2024/01/07\"             },             {                 \"OR\": [                     {                         \"key\": \"category\",                         \"value\": \"Personal\"                     },                     {                         \"key\": \"category\",                         \"value\": \"Test\"                     },                 ]             }         ]     } } ``` This will return emails after 7th of Jan that have either Personal or Test as category.  Note that this is the highest level of nesting we support, i.e. you can\'t add more AND/OR filters within the OR filter in the above example.
         * @summary Outlook Sync
         * @param {IntegrationsApiSyncOutlookRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async syncOutlook(requestParameters: IntegrationsApiSyncOutlookRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericSuccessResponse>> {
            const outlookSyncInput: OutlookSyncInput = {
                tags: requestParameters.tags,
                folder: requestParameters.folder,
                filters: requestParameters.filters,
                chunk_size: requestParameters.chunk_size,
                chunk_overlap: requestParameters.chunk_overlap,
                skip_embedding_generation: requestParameters.skip_embedding_generation,
                embedding_model: requestParameters.embedding_model,
                generate_sparse_vectors: requestParameters.generate_sparse_vectors,
                prepend_filename_to_chunks: requestParameters.prepend_filename_to_chunks,
                data_source_id: requestParameters.data_source_id,
                request_id: requestParameters.request_id,
                sync_attachments: requestParameters.sync_attachments
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.syncOutlook(outlookSyncInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * You can retreive repos your token has access to using /integrations/github/repos and sync their content.  You can also pass full name of any public repository (username/repo-name). This will store the repo content with  carbon which can be accessed through /integrations/items/list endpoint. Maximum of 25 repositories are accepted per request.
         * @summary Github Sync Repos
         * @param {IntegrationsApiSyncReposRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async syncRepos(requestParameters: IntegrationsApiSyncReposRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const githubFetchReposRequest: GithubFetchReposRequest = {
                repos: requestParameters.repos,
                data_source_id: requestParameters.data_source_id
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.syncRepos(githubFetchReposRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Rss Feed
         * @param {IntegrationsApiSyncRssFeedRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async syncRssFeed(requestParameters: IntegrationsApiSyncRssFeedRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericSuccessResponse>> {
            const rSSFeedInput: RSSFeedInput = {
                tags: requestParameters.tags,
                url: requestParameters.url,
                chunk_size: requestParameters.chunk_size,
                chunk_overlap: requestParameters.chunk_overlap,
                skip_embedding_generation: requestParameters.skip_embedding_generation,
                embedding_model: requestParameters.embedding_model,
                generate_sparse_vectors: requestParameters.generate_sparse_vectors,
                prepend_filename_to_chunks: requestParameters.prepend_filename_to_chunks,
                request_id: requestParameters.request_id
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.syncRssFeed(rSSFeedInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * After optionally loading the items via /integrations/items/sync and integrations/items/list, use the bucket name  and object key as the ID in this endpoint to sync them into Carbon. Additional parameters below can associate  data with the selected items or modify the sync behavior
         * @summary S3 Files
         * @param {IntegrationsApiSyncS3FilesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async syncS3Files(requestParameters: IntegrationsApiSyncS3FilesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericSuccessResponse>> {
            const s3FileSyncInput: S3FileSyncInput = {
                tags: requestParameters.tags,
                ids: requestParameters.ids,
                chunk_size: requestParameters.chunk_size,
                chunk_overlap: requestParameters.chunk_overlap,
                skip_embedding_generation: requestParameters.skip_embedding_generation,
                embedding_model: requestParameters.embedding_model,
                generate_sparse_vectors: requestParameters.generate_sparse_vectors,
                prepend_filename_to_chunks: requestParameters.prepend_filename_to_chunks,
                max_items_per_chunk: requestParameters.max_items_per_chunk,
                set_page_as_boundary: requestParameters.set_page_as_boundary,
                data_source_id: requestParameters.data_source_id,
                request_id: requestParameters.request_id,
                use_ocr: requestParameters.use_ocr,
                parse_pdf_tables_with_ocr: requestParameters.parse_pdf_tables_with_ocr
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.syncS3Files(s3FileSyncInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * IntegrationsApi - factory interface
 * @export
 */
export const IntegrationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IntegrationsApiFp(configuration)
    return {
        /**
         * 
         * @summary Connect Data Source
         * @param {IntegrationsApiConnectDataSourceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectDataSource(requestParameters: IntegrationsApiConnectDataSourceRequest, options?: AxiosRequestConfig): AxiosPromise<ConnectDataSourceResponse> {
            return localVarFp.connectDataSource(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Refer this article to obtain an API key https://support.freshdesk.com/en/support/solutions/articles/215517. Make sure that your API key has the permission to read solutions from your account and you are on a <b>paid</b> plan. Once you have an API key, you can make a request to this endpoint along with your freshdesk domain. This will  trigger an automatic sync of the articles in your \"solutions\" tab. Additional parameters below can be used to associate  data with the synced articles or modify the sync behavior.
         * @summary Freshdesk Connect
         * @param {IntegrationsApiConnectFreshdeskRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectFreshdesk(requestParameters: IntegrationsApiConnectFreshdeskRequest, options?: AxiosRequestConfig): AxiosPromise<GenericSuccessResponse> {
            return localVarFp.connectFreshdesk(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * You will need an access token to connect your Gitbook account. Note that the permissions will be defined by the user  generating access token so make sure you have the permission to access spaces you will be syncing.  Refer this article for more details https://developer.gitbook.com/gitbook-api/authentication. Additionally, you need to specify the name of organization you will be syncing data from.
         * @summary Gitbook Connect
         * @param {IntegrationsApiConnectGitbookRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectGitbook(requestParameters: IntegrationsApiConnectGitbookRequest, options?: AxiosRequestConfig): AxiosPromise<GenericSuccessResponse> {
            return localVarFp.connectGitbook(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new IAM user with permissions to: <ol> <li>List all buckets.</li> <li>Read from the specific buckets and objects to sync with Carbon. Ensure any future buckets or objects carry  the same permissions.</li> </ol> Once created, generate an access key for this user and share the credentials with us. We recommend testing this key beforehand.
         * @summary S3 Auth
         * @param {IntegrationsApiCreateAwsIamUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAwsIamUser(requestParameters: IntegrationsApiCreateAwsIamUserRequest, options?: AxiosRequestConfig): AxiosPromise<OrganizationUserDataSourceAPI> {
            return localVarFp.createAwsIamUser(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint can be used to generate the following URLs - An OAuth URL for OAuth based connectors - A file syncing URL which skips the OAuth flow if the user already has a valid access token and takes them to the success state.
         * @summary Get Oauth Url
         * @param {IntegrationsApiGetOauthUrlRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOauthUrl(requestParameters: IntegrationsApiGetOauthUrlRequest, options?: AxiosRequestConfig): AxiosPromise<OuthURLResponse> {
            return localVarFp.getOauthUrl(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * To begin listing a user\'s Confluence pages, at least a `data_source_id` of a connected Confluence account must be specified. This base request returns a list of root pages for every space the user has access to in a Confluence instance. To traverse further down the user\'s page directory, additional requests to this endpoint can be made with the same `data_source_id` and with `parent_id` set to the id of page from a previous request. For convenience, the `has_children` property in each directory item in the response list will flag which pages will return non-empty lists of pages when set as the `parent_id`.
         * @summary Confluence List
         * @param {IntegrationsApiListConfluencePagesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConfluencePages(requestParameters: IntegrationsApiListConfluencePagesRequest, options?: AxiosRequestConfig): AxiosPromise<ListResponse> {
            return localVarFp.listConfluencePages(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Data Source Items
         * @param {IntegrationsApiListDataSourceItemsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDataSourceItems(requestParameters: IntegrationsApiListDataSourceItemsRequest, options?: AxiosRequestConfig): AxiosPromise<ListDataSourceItemsResponse> {
            return localVarFp.listDataSourceItems(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * After connecting your Outlook account, you can use this endpoint to list all of your folders on outlook. This includes  both system folders like \"inbox\" and user created folders.
         * @summary Outlook Folders
         * @param {IntegrationsApiListFoldersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFolders(requestParameters: IntegrationsApiListFoldersRequest = {}, options?: AxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.listFolders(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * After connecting your Gitbook account, you can use this endpoint to list all of your spaces under current organization.
         * @summary Gitbook Spaces
         * @param {IntegrationsApiListGitbookSpacesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGitbookSpaces(requestParameters: IntegrationsApiListGitbookSpacesRequest, options?: AxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.listGitbookSpaces(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * After connecting your Gmail account, you can use this endpoint to list all of your labels. User created labels will have the type \"user\" and Gmail\'s default labels will have the type \"system\"
         * @summary Gmail Labels
         * @param {IntegrationsApiListLabelsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLabels(requestParameters: IntegrationsApiListLabelsRequest = {}, options?: AxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.listLabels(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * After connecting your Outlook account, you can use this endpoint to list all of your categories on outlook. We currently support listing up to 250 categories.
         * @summary Outlook Categories
         * @param {IntegrationsApiListOutlookCategoriesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOutlookCategories(requestParameters: IntegrationsApiListOutlookCategoriesRequest = {}, options?: AxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.listOutlookCategories(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Once you have connected your GitHub account, you can use this endpoint to list the      repositories your account has access to. You can use a data source ID or username to fetch from a specific account.
         * @summary Github List Repos
         * @param {IntegrationsApiListReposRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRepos(requestParameters: IntegrationsApiListReposRequest = {}, options?: AxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.listRepos(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * After listing pages in a user\'s Confluence account, the set of selected page `ids` and the connected account\'s `data_source_id` can be passed into this endpoint to sync them into Carbon. Additional parameters listed below can be used to associate data to the selected pages or alter the behavior of the sync.
         * @summary Confluence Sync
         * @param {IntegrationsApiSyncConfluenceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncConfluence(requestParameters: IntegrationsApiSyncConfluenceRequest, options?: AxiosRequestConfig): AxiosPromise<GenericSuccessResponse> {
            return localVarFp.syncConfluence(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Sync Data Source Items
         * @param {IntegrationsApiSyncDataSourceItemsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncDataSourceItems(requestParameters: IntegrationsApiSyncDataSourceItemsRequest, options?: AxiosRequestConfig): AxiosPromise<OrganizationUserDataSourceAPI> {
            return localVarFp.syncDataSourceItems(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * After listing files and folders via /integrations/items/sync and integrations/items/list, use the selected items\' external ids  as the ids in this endpoint to sync them into Carbon. Sharepoint items take an additional parameter root_id, which identifies the drive the file or folder is in and is stored in root_external_id. That additional paramter is optional and excluding it will tell the sync to assume the item is stored in the default Documents drive.
         * @summary Sync Files
         * @param {IntegrationsApiSyncFilesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncFiles(requestParameters: IntegrationsApiSyncFilesRequest, options?: AxiosRequestConfig): AxiosPromise<GenericSuccessResponse> {
            return localVarFp.syncFiles(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Refer this article to obtain an access token https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/managing-your-personal-access-tokens. Make sure that your access token has the permission to read content from your desired repos. Note that if your access token expires you will need to manually update it through this endpoint.
         * @summary Github Connect
         * @param {IntegrationsApiSyncGitHubRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncGitHub(requestParameters: IntegrationsApiSyncGitHubRequest, options?: AxiosRequestConfig): AxiosPromise<GenericSuccessResponse> {
            return localVarFp.syncGitHub(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * You can sync upto 20 Gitbook spaces at a time using this endpoint. Additional parameters below can be used to associate  data with the synced pages or modify the sync behavior.
         * @summary Gitbook Sync
         * @param {IntegrationsApiSyncGitbookRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncGitbook(requestParameters: IntegrationsApiSyncGitbookRequest, options?: AxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.syncGitbook(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Once you have successfully connected your gmail account, you can choose which emails to sync with us using the filters parameter. Filters is a JSON object with key value pairs. It also supports AND and OR operations. For now, we support a limited set of keys listed below.  <b>label</b>: Inbuilt Gmail labels, for example \"Important\" or a custom label you created.   <b>after</b> or <b>before</b>: A date in YYYY/mm/dd format (example 2023/12/31). Gets emails after/before a certain date. You can also use them in combination to get emails from a certain period.   <b>is</b>: Can have the following values - starred, important, snoozed, and unread    Using keys or values outside of the specified values can lead to unexpected behaviour.  An example of a basic query with filters can be ```json {     \"filters\": {             \"key\": \"label\",             \"value\": \"Test\"         } } ``` Which will list all emails that have the label \"Test\".  You can use AND and OR operation in the following way: ```json {     \"filters\": {         \"AND\": [             {                 \"key\": \"after\",                 \"value\": \"2024/01/07\"             },             {                 \"OR\": [                     {                         \"key\": \"label\",                         \"value\": \"Personal\"                     },                     {                         \"key\": \"is\",                         \"value\": \"starred\"                     }                 ]             }         ]     } } ``` This will return emails after 7th of Jan that are either starred or have the label \"Personal\".  Note that this is the highest level of nesting we support, i.e. you can\'t add more AND/OR filters within the OR filter in the above example.
         * @summary Gmail Sync
         * @param {IntegrationsApiSyncGmailRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncGmail(requestParameters: IntegrationsApiSyncGmailRequest, options?: AxiosRequestConfig): AxiosPromise<GenericSuccessResponse> {
            return localVarFp.syncGmail(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Once you have successfully connected your Outlook account, you can choose which emails to sync with us using the filters and folder parameter. \"folder\" should be the folder you want to sync from Outlook. By default we get messages from your inbox folder.   Filters is a JSON object with key value pairs. It also supports AND and OR operations. For now, we support a limited set of keys listed below.  <b>category</b>: Custom categories that you created in Outlook.   <b>after</b> or <b>before</b>: A date in YYYY/mm/dd format (example 2023/12/31). Gets emails after/before a certain date. You can also use them in combination to get emails from a certain period.     <b>is</b>: Can have the following values: flagged     An example of a basic query with filters can be ```json {     \"filters\": {             \"key\": \"category\",             \"value\": \"Test\"         } } ``` Which will list all emails that have the category \"Test\".    Specifying a custom folder in the same query ```json {     \"folder\": \"Folder Name\",     \"filters\": {             \"key\": \"category\",             \"value\": \"Test\"         } } ```  You can use AND and OR operation in the following way: ```json {     \"filters\": {         \"AND\": [             {                 \"key\": \"after\",                 \"value\": \"2024/01/07\"             },             {                 \"OR\": [                     {                         \"key\": \"category\",                         \"value\": \"Personal\"                     },                     {                         \"key\": \"category\",                         \"value\": \"Test\"                     },                 ]             }         ]     } } ``` This will return emails after 7th of Jan that have either Personal or Test as category.  Note that this is the highest level of nesting we support, i.e. you can\'t add more AND/OR filters within the OR filter in the above example.
         * @summary Outlook Sync
         * @param {IntegrationsApiSyncOutlookRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncOutlook(requestParameters: IntegrationsApiSyncOutlookRequest, options?: AxiosRequestConfig): AxiosPromise<GenericSuccessResponse> {
            return localVarFp.syncOutlook(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * You can retreive repos your token has access to using /integrations/github/repos and sync their content.  You can also pass full name of any public repository (username/repo-name). This will store the repo content with  carbon which can be accessed through /integrations/items/list endpoint. Maximum of 25 repositories are accepted per request.
         * @summary Github Sync Repos
         * @param {IntegrationsApiSyncReposRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncRepos(requestParameters: IntegrationsApiSyncReposRequest, options?: AxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.syncRepos(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Rss Feed
         * @param {IntegrationsApiSyncRssFeedRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncRssFeed(requestParameters: IntegrationsApiSyncRssFeedRequest, options?: AxiosRequestConfig): AxiosPromise<GenericSuccessResponse> {
            return localVarFp.syncRssFeed(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * After optionally loading the items via /integrations/items/sync and integrations/items/list, use the bucket name  and object key as the ID in this endpoint to sync them into Carbon. Additional parameters below can associate  data with the selected items or modify the sync behavior
         * @summary S3 Files
         * @param {IntegrationsApiSyncS3FilesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncS3Files(requestParameters: IntegrationsApiSyncS3FilesRequest, options?: AxiosRequestConfig): AxiosPromise<GenericSuccessResponse> {
            return localVarFp.syncS3Files(requestParameters, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for connectDataSource operation in IntegrationsApi.
 * @export
 * @interface IntegrationsApiConnectDataSourceRequest
 */
export type IntegrationsApiConnectDataSourceRequest = {
    
} & ConnectDataSourceInput

/**
 * Request parameters for connectFreshdesk operation in IntegrationsApi.
 * @export
 * @interface IntegrationsApiConnectFreshdeskRequest
 */
export type IntegrationsApiConnectFreshdeskRequest = {
    
} & FreshDeskConnectRequest

/**
 * Request parameters for connectGitbook operation in IntegrationsApi.
 * @export
 * @interface IntegrationsApiConnectGitbookRequest
 */
export type IntegrationsApiConnectGitbookRequest = {
    
} & GitbookConnectRequest

/**
 * Request parameters for createAwsIamUser operation in IntegrationsApi.
 * @export
 * @interface IntegrationsApiCreateAwsIamUserRequest
 */
export type IntegrationsApiCreateAwsIamUserRequest = {
    
} & S3AuthRequest

/**
 * Request parameters for getOauthUrl operation in IntegrationsApi.
 * @export
 * @interface IntegrationsApiGetOauthUrlRequest
 */
export type IntegrationsApiGetOauthUrlRequest = {
    
} & OAuthURLRequest

/**
 * Request parameters for listConfluencePages operation in IntegrationsApi.
 * @export
 * @interface IntegrationsApiListConfluencePagesRequest
 */
export type IntegrationsApiListConfluencePagesRequest = {
    
} & ListRequest

/**
 * Request parameters for listDataSourceItems operation in IntegrationsApi.
 * @export
 * @interface IntegrationsApiListDataSourceItemsRequest
 */
export type IntegrationsApiListDataSourceItemsRequest = {
    
} & ListDataSourceItemsRequest

/**
 * Request parameters for listFolders operation in IntegrationsApi.
 * @export
 * @interface IntegrationsApiListFoldersRequest
 */
export type IntegrationsApiListFoldersRequest = {
    
    /**
    * 
    * @type {number}
    * @memberof IntegrationsApiListFolders
    */
    readonly dataSourceId?: number
    
}

/**
 * Request parameters for listGitbookSpaces operation in IntegrationsApi.
 * @export
 * @interface IntegrationsApiListGitbookSpacesRequest
 */
export type IntegrationsApiListGitbookSpacesRequest = {
    
    /**
    * 
    * @type {number}
    * @memberof IntegrationsApiListGitbookSpaces
    */
    readonly dataSourceId: number
    
}

/**
 * Request parameters for listLabels operation in IntegrationsApi.
 * @export
 * @interface IntegrationsApiListLabelsRequest
 */
export type IntegrationsApiListLabelsRequest = {
    
    /**
    * 
    * @type {number}
    * @memberof IntegrationsApiListLabels
    */
    readonly dataSourceId?: number
    
}

/**
 * Request parameters for listOutlookCategories operation in IntegrationsApi.
 * @export
 * @interface IntegrationsApiListOutlookCategoriesRequest
 */
export type IntegrationsApiListOutlookCategoriesRequest = {
    
    /**
    * 
    * @type {number}
    * @memberof IntegrationsApiListOutlookCategories
    */
    readonly dataSourceId?: number
    
}

/**
 * Request parameters for listRepos operation in IntegrationsApi.
 * @export
 * @interface IntegrationsApiListReposRequest
 */
export type IntegrationsApiListReposRequest = {
    
    /**
    * 
    * @type {number}
    * @memberof IntegrationsApiListRepos
    */
    readonly perPage?: number
    
    /**
    * 
    * @type {number}
    * @memberof IntegrationsApiListRepos
    */
    readonly page?: number
    
    /**
    * 
    * @type {number}
    * @memberof IntegrationsApiListRepos
    */
    readonly dataSourceId?: number
    
}

/**
 * Request parameters for syncConfluence operation in IntegrationsApi.
 * @export
 * @interface IntegrationsApiSyncConfluenceRequest
 */
export type IntegrationsApiSyncConfluenceRequest = {
    
} & SyncFilesRequest

/**
 * Request parameters for syncDataSourceItems operation in IntegrationsApi.
 * @export
 * @interface IntegrationsApiSyncDataSourceItemsRequest
 */
export type IntegrationsApiSyncDataSourceItemsRequest = {
    
} & SyncDirectoryRequest

/**
 * Request parameters for syncFiles operation in IntegrationsApi.
 * @export
 * @interface IntegrationsApiSyncFilesRequest
 */
export type IntegrationsApiSyncFilesRequest = {
    
} & SyncFilesRequest

/**
 * Request parameters for syncGitHub operation in IntegrationsApi.
 * @export
 * @interface IntegrationsApiSyncGitHubRequest
 */
export type IntegrationsApiSyncGitHubRequest = {
    
} & GithubConnectRequest

/**
 * Request parameters for syncGitbook operation in IntegrationsApi.
 * @export
 * @interface IntegrationsApiSyncGitbookRequest
 */
export type IntegrationsApiSyncGitbookRequest = {
    
} & GitbookSyncRequest

/**
 * Request parameters for syncGmail operation in IntegrationsApi.
 * @export
 * @interface IntegrationsApiSyncGmailRequest
 */
export type IntegrationsApiSyncGmailRequest = {
    
} & GmailSyncInput

/**
 * Request parameters for syncOutlook operation in IntegrationsApi.
 * @export
 * @interface IntegrationsApiSyncOutlookRequest
 */
export type IntegrationsApiSyncOutlookRequest = {
    
} & OutlookSyncInput

/**
 * Request parameters for syncRepos operation in IntegrationsApi.
 * @export
 * @interface IntegrationsApiSyncReposRequest
 */
export type IntegrationsApiSyncReposRequest = {
    
} & GithubFetchReposRequest

/**
 * Request parameters for syncRssFeed operation in IntegrationsApi.
 * @export
 * @interface IntegrationsApiSyncRssFeedRequest
 */
export type IntegrationsApiSyncRssFeedRequest = {
    
} & RSSFeedInput

/**
 * Request parameters for syncS3Files operation in IntegrationsApi.
 * @export
 * @interface IntegrationsApiSyncS3FilesRequest
 */
export type IntegrationsApiSyncS3FilesRequest = {
    
} & S3FileSyncInput

/**
 * IntegrationsApiGenerated - object-oriented interface
 * @export
 * @class IntegrationsApiGenerated
 * @extends {BaseAPI}
 */
export class IntegrationsApiGenerated extends BaseAPI {
    /**
     * 
     * @summary Connect Data Source
     * @param {IntegrationsApiConnectDataSourceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApiGenerated
     */
    public connectDataSource(requestParameters: IntegrationsApiConnectDataSourceRequest, options?: AxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).connectDataSource(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Refer this article to obtain an API key https://support.freshdesk.com/en/support/solutions/articles/215517. Make sure that your API key has the permission to read solutions from your account and you are on a <b>paid</b> plan. Once you have an API key, you can make a request to this endpoint along with your freshdesk domain. This will  trigger an automatic sync of the articles in your \"solutions\" tab. Additional parameters below can be used to associate  data with the synced articles or modify the sync behavior.
     * @summary Freshdesk Connect
     * @param {IntegrationsApiConnectFreshdeskRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApiGenerated
     */
    public connectFreshdesk(requestParameters: IntegrationsApiConnectFreshdeskRequest, options?: AxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).connectFreshdesk(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You will need an access token to connect your Gitbook account. Note that the permissions will be defined by the user  generating access token so make sure you have the permission to access spaces you will be syncing.  Refer this article for more details https://developer.gitbook.com/gitbook-api/authentication. Additionally, you need to specify the name of organization you will be syncing data from.
     * @summary Gitbook Connect
     * @param {IntegrationsApiConnectGitbookRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApiGenerated
     */
    public connectGitbook(requestParameters: IntegrationsApiConnectGitbookRequest, options?: AxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).connectGitbook(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new IAM user with permissions to: <ol> <li>List all buckets.</li> <li>Read from the specific buckets and objects to sync with Carbon. Ensure any future buckets or objects carry  the same permissions.</li> </ol> Once created, generate an access key for this user and share the credentials with us. We recommend testing this key beforehand.
     * @summary S3 Auth
     * @param {IntegrationsApiCreateAwsIamUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApiGenerated
     */
    public createAwsIamUser(requestParameters: IntegrationsApiCreateAwsIamUserRequest, options?: AxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).createAwsIamUser(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint can be used to generate the following URLs - An OAuth URL for OAuth based connectors - A file syncing URL which skips the OAuth flow if the user already has a valid access token and takes them to the success state.
     * @summary Get Oauth Url
     * @param {IntegrationsApiGetOauthUrlRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApiGenerated
     */
    public getOauthUrl(requestParameters: IntegrationsApiGetOauthUrlRequest, options?: AxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).getOauthUrl(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * To begin listing a user\'s Confluence pages, at least a `data_source_id` of a connected Confluence account must be specified. This base request returns a list of root pages for every space the user has access to in a Confluence instance. To traverse further down the user\'s page directory, additional requests to this endpoint can be made with the same `data_source_id` and with `parent_id` set to the id of page from a previous request. For convenience, the `has_children` property in each directory item in the response list will flag which pages will return non-empty lists of pages when set as the `parent_id`.
     * @summary Confluence List
     * @param {IntegrationsApiListConfluencePagesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApiGenerated
     */
    public listConfluencePages(requestParameters: IntegrationsApiListConfluencePagesRequest, options?: AxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).listConfluencePages(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Data Source Items
     * @param {IntegrationsApiListDataSourceItemsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApiGenerated
     */
    public listDataSourceItems(requestParameters: IntegrationsApiListDataSourceItemsRequest, options?: AxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).listDataSourceItems(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * After connecting your Outlook account, you can use this endpoint to list all of your folders on outlook. This includes  both system folders like \"inbox\" and user created folders.
     * @summary Outlook Folders
     * @param {IntegrationsApiListFoldersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApiGenerated
     */
    public listFolders(requestParameters: IntegrationsApiListFoldersRequest = {}, options?: AxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).listFolders(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * After connecting your Gitbook account, you can use this endpoint to list all of your spaces under current organization.
     * @summary Gitbook Spaces
     * @param {IntegrationsApiListGitbookSpacesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApiGenerated
     */
    public listGitbookSpaces(requestParameters: IntegrationsApiListGitbookSpacesRequest, options?: AxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).listGitbookSpaces(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * After connecting your Gmail account, you can use this endpoint to list all of your labels. User created labels will have the type \"user\" and Gmail\'s default labels will have the type \"system\"
     * @summary Gmail Labels
     * @param {IntegrationsApiListLabelsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApiGenerated
     */
    public listLabels(requestParameters: IntegrationsApiListLabelsRequest = {}, options?: AxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).listLabels(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * After connecting your Outlook account, you can use this endpoint to list all of your categories on outlook. We currently support listing up to 250 categories.
     * @summary Outlook Categories
     * @param {IntegrationsApiListOutlookCategoriesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApiGenerated
     */
    public listOutlookCategories(requestParameters: IntegrationsApiListOutlookCategoriesRequest = {}, options?: AxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).listOutlookCategories(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Once you have connected your GitHub account, you can use this endpoint to list the      repositories your account has access to. You can use a data source ID or username to fetch from a specific account.
     * @summary Github List Repos
     * @param {IntegrationsApiListReposRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApiGenerated
     */
    public listRepos(requestParameters: IntegrationsApiListReposRequest = {}, options?: AxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).listRepos(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * After listing pages in a user\'s Confluence account, the set of selected page `ids` and the connected account\'s `data_source_id` can be passed into this endpoint to sync them into Carbon. Additional parameters listed below can be used to associate data to the selected pages or alter the behavior of the sync.
     * @summary Confluence Sync
     * @param {IntegrationsApiSyncConfluenceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApiGenerated
     */
    public syncConfluence(requestParameters: IntegrationsApiSyncConfluenceRequest, options?: AxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).syncConfluence(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Sync Data Source Items
     * @param {IntegrationsApiSyncDataSourceItemsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApiGenerated
     */
    public syncDataSourceItems(requestParameters: IntegrationsApiSyncDataSourceItemsRequest, options?: AxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).syncDataSourceItems(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * After listing files and folders via /integrations/items/sync and integrations/items/list, use the selected items\' external ids  as the ids in this endpoint to sync them into Carbon. Sharepoint items take an additional parameter root_id, which identifies the drive the file or folder is in and is stored in root_external_id. That additional paramter is optional and excluding it will tell the sync to assume the item is stored in the default Documents drive.
     * @summary Sync Files
     * @param {IntegrationsApiSyncFilesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApiGenerated
     */
    public syncFiles(requestParameters: IntegrationsApiSyncFilesRequest, options?: AxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).syncFiles(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Refer this article to obtain an access token https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/managing-your-personal-access-tokens. Make sure that your access token has the permission to read content from your desired repos. Note that if your access token expires you will need to manually update it through this endpoint.
     * @summary Github Connect
     * @param {IntegrationsApiSyncGitHubRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApiGenerated
     */
    public syncGitHub(requestParameters: IntegrationsApiSyncGitHubRequest, options?: AxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).syncGitHub(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You can sync upto 20 Gitbook spaces at a time using this endpoint. Additional parameters below can be used to associate  data with the synced pages or modify the sync behavior.
     * @summary Gitbook Sync
     * @param {IntegrationsApiSyncGitbookRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApiGenerated
     */
    public syncGitbook(requestParameters: IntegrationsApiSyncGitbookRequest, options?: AxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).syncGitbook(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Once you have successfully connected your gmail account, you can choose which emails to sync with us using the filters parameter. Filters is a JSON object with key value pairs. It also supports AND and OR operations. For now, we support a limited set of keys listed below.  <b>label</b>: Inbuilt Gmail labels, for example \"Important\" or a custom label you created.   <b>after</b> or <b>before</b>: A date in YYYY/mm/dd format (example 2023/12/31). Gets emails after/before a certain date. You can also use them in combination to get emails from a certain period.   <b>is</b>: Can have the following values - starred, important, snoozed, and unread    Using keys or values outside of the specified values can lead to unexpected behaviour.  An example of a basic query with filters can be ```json {     \"filters\": {             \"key\": \"label\",             \"value\": \"Test\"         } } ``` Which will list all emails that have the label \"Test\".  You can use AND and OR operation in the following way: ```json {     \"filters\": {         \"AND\": [             {                 \"key\": \"after\",                 \"value\": \"2024/01/07\"             },             {                 \"OR\": [                     {                         \"key\": \"label\",                         \"value\": \"Personal\"                     },                     {                         \"key\": \"is\",                         \"value\": \"starred\"                     }                 ]             }         ]     } } ``` This will return emails after 7th of Jan that are either starred or have the label \"Personal\".  Note that this is the highest level of nesting we support, i.e. you can\'t add more AND/OR filters within the OR filter in the above example.
     * @summary Gmail Sync
     * @param {IntegrationsApiSyncGmailRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApiGenerated
     */
    public syncGmail(requestParameters: IntegrationsApiSyncGmailRequest, options?: AxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).syncGmail(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Once you have successfully connected your Outlook account, you can choose which emails to sync with us using the filters and folder parameter. \"folder\" should be the folder you want to sync from Outlook. By default we get messages from your inbox folder.   Filters is a JSON object with key value pairs. It also supports AND and OR operations. For now, we support a limited set of keys listed below.  <b>category</b>: Custom categories that you created in Outlook.   <b>after</b> or <b>before</b>: A date in YYYY/mm/dd format (example 2023/12/31). Gets emails after/before a certain date. You can also use them in combination to get emails from a certain period.     <b>is</b>: Can have the following values: flagged     An example of a basic query with filters can be ```json {     \"filters\": {             \"key\": \"category\",             \"value\": \"Test\"         } } ``` Which will list all emails that have the category \"Test\".    Specifying a custom folder in the same query ```json {     \"folder\": \"Folder Name\",     \"filters\": {             \"key\": \"category\",             \"value\": \"Test\"         } } ```  You can use AND and OR operation in the following way: ```json {     \"filters\": {         \"AND\": [             {                 \"key\": \"after\",                 \"value\": \"2024/01/07\"             },             {                 \"OR\": [                     {                         \"key\": \"category\",                         \"value\": \"Personal\"                     },                     {                         \"key\": \"category\",                         \"value\": \"Test\"                     },                 ]             }         ]     } } ``` This will return emails after 7th of Jan that have either Personal or Test as category.  Note that this is the highest level of nesting we support, i.e. you can\'t add more AND/OR filters within the OR filter in the above example.
     * @summary Outlook Sync
     * @param {IntegrationsApiSyncOutlookRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApiGenerated
     */
    public syncOutlook(requestParameters: IntegrationsApiSyncOutlookRequest, options?: AxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).syncOutlook(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You can retreive repos your token has access to using /integrations/github/repos and sync their content.  You can also pass full name of any public repository (username/repo-name). This will store the repo content with  carbon which can be accessed through /integrations/items/list endpoint. Maximum of 25 repositories are accepted per request.
     * @summary Github Sync Repos
     * @param {IntegrationsApiSyncReposRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApiGenerated
     */
    public syncRepos(requestParameters: IntegrationsApiSyncReposRequest, options?: AxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).syncRepos(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Rss Feed
     * @param {IntegrationsApiSyncRssFeedRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApiGenerated
     */
    public syncRssFeed(requestParameters: IntegrationsApiSyncRssFeedRequest, options?: AxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).syncRssFeed(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * After optionally loading the items via /integrations/items/sync and integrations/items/list, use the bucket name  and object key as the ID in this endpoint to sync them into Carbon. Additional parameters below can associate  data with the selected items or modify the sync behavior
     * @summary S3 Files
     * @param {IntegrationsApiSyncS3FilesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApiGenerated
     */
    public syncS3Files(requestParameters: IntegrationsApiSyncS3FilesRequest, options?: AxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).syncS3Files(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }
}
