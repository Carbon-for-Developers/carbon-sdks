/* tslint:disable */
/* eslint-disable */
/*
Carbon

Connect external data to LLMs, no matter the source.

The version of the OpenAPI document: 1.0.0


NOTE: This file is auto generated by Konfig (https://konfigthis.com).
*/

import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction, isBrowser } from '../common';
import { fromBuffer } from "file-type/browser"
const FormData = require("form-data")
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { BodyCreateUploadFileUploadfilePost } from '../models';
// @ts-ignore
import { DeleteFilesQueryInput } from '../models';
// @ts-ignore
import { EmbeddingGenerators } from '../models';
// @ts-ignore
import { EmbeddingGeneratorsNullable } from '../models';
// @ts-ignore
import { ExternalFileSyncStatuses } from '../models';
// @ts-ignore
import { GenericSuccessResponse } from '../models';
// @ts-ignore
import { HTTPValidationError } from '../models';
// @ts-ignore
import { OrderDir } from '../models';
// @ts-ignore
import { OrganizationUserFileTagCreate } from '../models';
// @ts-ignore
import { OrganizationUserFileTagsRemove } from '../models';
// @ts-ignore
import { OrganizationUserFilesToSyncFilters } from '../models';
// @ts-ignore
import { OrganizationUserFilesToSyncOrderByTypes } from '../models';
// @ts-ignore
import { OrganizationUserFilesToSyncQueryInput } from '../models';
// @ts-ignore
import { Pagination } from '../models';
// @ts-ignore
import { PresignedURLResponse } from '../models';
// @ts-ignore
import { RawTextInput } from '../models';
// @ts-ignore
import { ResyncFileQueryInput } from '../models';
// @ts-ignore
import { Tags1 } from '../models';
// @ts-ignore
import { TextEmbeddingGenerators } from '../models';
// @ts-ignore
import { UploadFileFromUrlInput } from '../models';
// @ts-ignore
import { UserFile } from '../models';
// @ts-ignore
import { UserFilesV2 } from '../models';
import { paginate } from "../pagination/paginate";
import type * as buffer from "buffer"
import { requestBeforeHook } from '../requestBeforeHook';
/**
 * FilesApi - axios parameter creator
 * @export
 */
export const FilesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * A tag is a key-value pair that can be added to a file. This pair can then be used for searches (e.g. embedding searches) in order to narrow down the scope of the search. A file can have any number of tags. The following are reserved keys that cannot be used: - db_embedding_id - organization_id - user_id - organization_user_file_id  Carbon currently supports two data types for tag values - `string` and `list<string>`. Keys can only be `string`. If values other than `string` and `list<string>` are used, they\'re automatically converted to strings (e.g. 4 will become \"4\").
         * @summary Create File Tags
         * @param {OrganizationUserFileTagCreate} organizationUserFileTagCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserFileTags: async (organizationUserFileTagCreate: OrganizationUserFileTagCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationUserFileTagCreate' is not null or undefined
            assertParamExists('createUserFileTags', 'organizationUserFileTagCreate', organizationUserFileTagCreate)
            const localVarPath = `/create_user_file_tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "authorization", keyParamName: "accessToken", configuration, prefix: "Token " })
            // authentication apiKey required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "authorization", keyParamName: "apiKey", configuration, prefix: "Bearer " })
            // authentication customerId required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "customer-id", keyParamName: "customerId", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: organizationUserFileTagCreate,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration
            });
            localVarRequestOptions.data = serializeDataIfNeeded(organizationUserFileTagCreate, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete File Endpoint
         * @param {number} fileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete: async (fileId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('delete', 'fileId', fileId)
            const localVarPath = `/deletefile/{file_id}`
                .replace(`{${"file_id"}}`, encodeURIComponent(String(fileId !== undefined ? fileId : `-file_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "authorization", keyParamName: "accessToken", configuration, prefix: "Token " })
            // authentication apiKey required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "authorization", keyParamName: "apiKey", configuration, prefix: "Bearer " })
            // authentication customerId required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "customer-id", keyParamName: "customerId", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete File Tags
         * @param {OrganizationUserFileTagsRemove} organizationUserFileTagsRemove 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFileTags: async (organizationUserFileTagsRemove: OrganizationUserFileTagsRemove, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationUserFileTagsRemove' is not null or undefined
            assertParamExists('deleteFileTags', 'organizationUserFileTagsRemove', organizationUserFileTagsRemove)
            const localVarPath = `/delete_user_file_tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "authorization", keyParamName: "accessToken", configuration, prefix: "Token " })
            // authentication apiKey required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "authorization", keyParamName: "apiKey", configuration, prefix: "Bearer " })
            // authentication customerId required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "customer-id", keyParamName: "customerId", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: organizationUserFileTagsRemove,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration
            });
            localVarRequestOptions.data = serializeDataIfNeeded(organizationUserFileTagsRemove, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Files Endpoint
         * @param {DeleteFilesQueryInput} deleteFilesQueryInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMany: async (deleteFilesQueryInput: DeleteFilesQueryInput, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deleteFilesQueryInput' is not null or undefined
            assertParamExists('deleteMany', 'deleteFilesQueryInput', deleteFilesQueryInput)
            const localVarPath = `/delete_files`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "authorization", keyParamName: "accessToken", configuration, prefix: "Token " })
            // authentication apiKey required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "authorization", keyParamName: "apiKey", configuration, prefix: "Bearer " })
            // authentication customerId required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "customer-id", keyParamName: "customerId", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: deleteFilesQueryInput,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration
            });
            localVarRequestOptions.data = serializeDataIfNeeded(deleteFilesQueryInput, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This route is deprecated. Use `/user_files_v2` instead.
         * @summary Parsed File
         * @param {number} fileId 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getParsedFile: async (fileId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('getParsedFile', 'fileId', fileId)
            const localVarPath = `/parsed_file/{file_id}`
                .replace(`{${"file_id"}}`, encodeURIComponent(String(fileId !== undefined ? fileId : `-file_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "authorization", keyParamName: "accessToken", configuration, prefix: "Token " })
            // authentication apiKey required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "authorization", keyParamName: "apiKey", configuration, prefix: "Bearer " })
            // authentication customerId required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "customer-id", keyParamName: "customerId", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This route is deprecated. Use `/user_files_v2` instead.
         * @summary Raw File
         * @param {number} fileId 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getRawFile: async (fileId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('getRawFile', 'fileId', fileId)
            const localVarPath = `/raw_file/{file_id}`
                .replace(`{${"file_id"}}`, encodeURIComponent(String(fileId !== undefined ? fileId : `-file_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "authorization", keyParamName: "accessToken", configuration, prefix: "Token " })
            // authentication apiKey required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "authorization", keyParamName: "apiKey", configuration, prefix: "Bearer " })
            // authentication customerId required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "customer-id", keyParamName: "customerId", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * For pre-filtering documents, using `tags_v2` is preferred to using `tags` (which is now deprecated). If both `tags_v2` and `tags` are specified, `tags` is ignored. `tags_v2` enables building complex filters through the use of \"AND\", \"OR\", and negation logic. Take the below input as an example: ```json {     \"OR\": [         {             \"key\": \"subject\",             \"value\": \"holy-bible\",             \"negate\": false         },         {             \"key\": \"person-of-interest\",             \"value\": \"jesus christ\",             \"negate\": false         },         {             \"key\": \"genre\",             \"value\": \"religion\",             \"negate\": true         }         {             \"AND\": [                 {                     \"key\": \"subject\",                     \"value\": \"tao-te-ching\",                     \"negate\": false                 },                 {                     \"key\": \"author\",                     \"value\": \"lao-tzu\",                     \"negate\": false                 }             ]         }     ] } ``` In this case, files will be filtered such that: 1. \"subject\" = \"holy-bible\" OR 2. \"person-of-interest\" = \"jesus christ\" OR 3. \"genre\" != \"religion\" OR 4. \"subject\" = \"tao-te-ching\" AND \"author\" = \"lao-tzu\"  Note that the top level of the query must be either an \"OR\" or \"AND\" array. Currently, nesting is limited to 3. For tag blocks (those with \"key\", \"value\", and \"negate\" keys), the following typing rules apply: 1. \"key\" isn\'t optional and must be a `string` 2. \"value\" isn\'t optional and can be `any` or list[`any`] 3. \"negate\" is optional and must be `true` or `false`. If present and `true`, then the filter block is negated in the resulting query. It is `false` by default.
         * @summary User Files V2
         * @param {OrganizationUserFilesToSyncQueryInput} organizationUserFilesToSyncQueryInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryUserFiles: async (organizationUserFilesToSyncQueryInput: OrganizationUserFilesToSyncQueryInput, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationUserFilesToSyncQueryInput' is not null or undefined
            assertParamExists('queryUserFiles', 'organizationUserFilesToSyncQueryInput', organizationUserFilesToSyncQueryInput)
            const localVarPath = `/user_files_v2`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "authorization", keyParamName: "accessToken", configuration, prefix: "Token " })
            // authentication apiKey required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "authorization", keyParamName: "apiKey", configuration, prefix: "Bearer " })
            // authentication customerId required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "customer-id", keyParamName: "customerId", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: organizationUserFilesToSyncQueryInput,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration
            });
            localVarRequestOptions.data = serializeDataIfNeeded(organizationUserFilesToSyncQueryInput, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This route is deprecated. Use `/user_files_v2` instead.
         * @summary User Files
         * @param {OrganizationUserFilesToSyncQueryInput} organizationUserFilesToSyncQueryInput 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        queryUserFilesDeprecated: async (organizationUserFilesToSyncQueryInput: OrganizationUserFilesToSyncQueryInput, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationUserFilesToSyncQueryInput' is not null or undefined
            assertParamExists('queryUserFilesDeprecated', 'organizationUserFilesToSyncQueryInput', organizationUserFilesToSyncQueryInput)
            const localVarPath = `/user_files`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "authorization", keyParamName: "accessToken", configuration, prefix: "Token " })
            // authentication apiKey required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "authorization", keyParamName: "apiKey", configuration, prefix: "Bearer " })
            // authentication customerId required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "customer-id", keyParamName: "customerId", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: organizationUserFilesToSyncQueryInput,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration
            });
            localVarRequestOptions.data = serializeDataIfNeeded(organizationUserFilesToSyncQueryInput, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Resync File
         * @param {ResyncFileQueryInput} resyncFileQueryInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resync: async (resyncFileQueryInput: ResyncFileQueryInput, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resyncFileQueryInput' is not null or undefined
            assertParamExists('resync', 'resyncFileQueryInput', resyncFileQueryInput)
            const localVarPath = `/resync_file`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "authorization", keyParamName: "accessToken", configuration, prefix: "Token " })
            // authentication apiKey required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "authorization", keyParamName: "apiKey", configuration, prefix: "Bearer " })
            // authentication customerId required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "customer-id", keyParamName: "customerId", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: resyncFileQueryInput,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration
            });
            localVarRequestOptions.data = serializeDataIfNeeded(resyncFileQueryInput, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint is used to directly upload local files to Carbon. The `POST` request should be a multipart form request. Note that the `set_page_as_boundary` query parameter is applicable only to PDFs for now. When this value is set, PDF chunks are at most one page long. Additional information can be retrieved for each chunk, however, namely the coordinates of the bounding box around the chunk (this can be used for things like text highlighting). Following is a description of all possible query parameters: - `chunk_size`: the chunk size (in tokens) applied when splitting the document - `chunk_overlap`: the chunk overlap (in tokens) applied when splitting the document - `skip_embedding_generation`: whether or not to skip the generation of chunks and embeddings - `set_page_as_boundary`: described above - `embedding_model`: the model used to generate embeddings for the document chunks - `use_ocr`: whether or not to use OCR as a preprocessing step prior to generating chunks (only valid for PDFs currently) - `generate_sparse_vectors`: whether or not to generate sparse vectors for the file. Required for hybrid search. - `prepend_filename_to_chunks`: whether or not to prepend the filename to the chunk text   Carbon supports multiple models for use in generating embeddings for files. For images, we support Vertex AI\'s multimodal model; for text, we support OpenAI\'s `text-embedding-ada-002` and Cohere\'s embed-multilingual-v3.0. The model can be specified via the `embedding_model` parameter (in the POST body for `/embeddings`, and a query  parameter in `/uploadfile`). If no model is supplied, the `text-embedding-ada-002` is used by default. When performing embedding queries, embeddings from files that used the specified model will be considered in the query. For example, if files A and B have embeddings generated with `OPENAI`, and files C and D have embeddings generated with `COHERE_MULTILINGUAL_V3`, then by default, queries will only consider files A and B. If `COHERE_MULTILINGUAL_V3` is specified as the `embedding_model` in `/embeddings`, then only files C and D will be considered. Make sure that the set of all files you want considered for a query have embeddings generated via the same model. For now, **do not** set `VERTEX_MULTIMODAL` as an `embedding_model`. This model is used automatically by Carbon when it detects an image file.
         * @summary Create Upload File
         * @param {Uint8Array | File | buffer.File} file 
         * @param {BodyCreateUploadFileUploadfilePost} bodyCreateUploadFileUploadfilePost 
         * @param {number} [chunkSize] Chunk size in tiktoken tokens to be used when processing file.
         * @param {number} [chunkOverlap] Chunk overlap in tiktoken tokens to be used when processing file.
         * @param {boolean} [skipEmbeddingGeneration] Flag to control whether or not embeddings should be generated and stored             when processing file.
         * @param {boolean} [setPageAsBoundary] Flag to control whether or not to set the a page\&#39;s worth of content as the maximum             amount of content that can appear in a chunk. Only valid for PDFs. See description route description for             more information.
         * @param {TextEmbeddingGenerators} [embeddingModel] Embedding model that will be used to embed file chunks.
         * @param {boolean} [useOcr] Whether or not to use OCR when processing files. Only valid for PDFs. Useful for documents with             tables, images, and/or scanned text.
         * @param {boolean} [generateSparseVectors] Whether or not to generate sparse vectors for the file. This is *required* for the file to be a             candidate for hybrid search.
         * @param {boolean} [prependFilenameToChunks] Whether or not to prepend the file\&#39;s name to chunks.
         * @param {number} [maxItemsPerChunk] Number of objects per chunk. For json files only.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upload: async (file: Uint8Array | File | buffer.File, bodyCreateUploadFileUploadfilePost: BodyCreateUploadFileUploadfilePost, chunkSize?: number, chunkOverlap?: number, skipEmbeddingGeneration?: boolean, setPageAsBoundary?: boolean, embeddingModel?: TextEmbeddingGenerators, useOcr?: boolean, generateSparseVectors?: boolean, prependFilenameToChunks?: boolean, maxItemsPerChunk?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'file' is not null or undefined
            assertParamExists('upload', 'file', file)
            // verify required parameter 'bodyCreateUploadFileUploadfilePost' is not null or undefined
            assertParamExists('upload', 'bodyCreateUploadFileUploadfilePost', bodyCreateUploadFileUploadfilePost)
            const localVarPath = `/uploadfile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();
            const addFormParam = async (name: string, data: any, isBinary: boolean, isPrimitiveType: boolean) => {
                if (isBinary) {
                    if (data instanceof Uint8Array) {
                        // Handle Buffer data
                        const filetype = await fromBuffer(data)
                        const filename = filetype === undefined ? name : `${name}.${filetype.ext}`
                        localVarFormParams.append(name, data as any, filename);
                    } else if ("name" in data) {
                        // File instances in browsers and Node.js have the
                        // "name" property "Duck typing" files to handle browser
                        // File class or Node.js File class
                        // Web: https://developer.mozilla.org/en-US/docs/Web/API/File
                        // Node.js: https://nodejs.org/api/buffer.html#new-bufferfilesources-filename-options
                        if (isBrowser()) {
                            // FormData in browser can accept File/Blob directly
                            localVarFormParams.append(name, data, data.name);
                        } else {
                            // FormData in Node.js can only accept raw Buffer so convert before passing
                            const bytes = await data.arrayBuffer()
                            const buffer = Buffer.from(bytes)
                            localVarFormParams.append(name, buffer, data.name);
                        }
                    }
                } else {
                    if (isPrimitiveType) {
                        /**
                         * FormData can only accept string or Blob so we need to convert
                         * non-string primitives to string. We also need to convert
                         */
                        if (typeof data === "object") {
                          localVarFormParams.append(name, JSON.stringify(data));
                        } else {
                          localVarFormParams.append(name, data);
                        }
                    } else {
                        if (isBrowser()) {
                            localVarFormParams.append(name, new Blob([JSON.stringify(data)], { type: "application/json" }))
                        } else {
                            localVarFormParams.append(name, JSON.stringify(data), { type: "application/json", filename: "data.json" });
                        }
                    }
                }
            }
            if (!isBrowser()) Object.assign(localVarHeaderParameter, localVarFormParams.getHeaders());

            // authentication accessToken required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "authorization", keyParamName: "accessToken", configuration, prefix: "Token " })
            // authentication apiKey required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "authorization", keyParamName: "apiKey", configuration, prefix: "Bearer " })
            // authentication customerId required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "customer-id", keyParamName: "customerId", configuration })
            if (chunkSize !== undefined) {
                localVarQueryParameter['chunk_size'] = chunkSize;
            }

            if (chunkOverlap !== undefined) {
                localVarQueryParameter['chunk_overlap'] = chunkOverlap;
            }

            if (skipEmbeddingGeneration !== undefined) {
                localVarQueryParameter['skip_embedding_generation'] = skipEmbeddingGeneration;
            }

            if (setPageAsBoundary !== undefined) {
                localVarQueryParameter['set_page_as_boundary'] = setPageAsBoundary;
            }

            if (embeddingModel !== undefined) {
                localVarQueryParameter['embedding_model'] = embeddingModel;
            }

            if (useOcr !== undefined) {
                localVarQueryParameter['use_ocr'] = useOcr;
            }

            if (generateSparseVectors !== undefined) {
                localVarQueryParameter['generate_sparse_vectors'] = generateSparseVectors;
            }

            if (prependFilenameToChunks !== undefined) {
                localVarQueryParameter['prepend_filename_to_chunks'] = prependFilenameToChunks;
            }

            if (maxItemsPerChunk !== undefined) {
                localVarQueryParameter['max_items_per_chunk'] = maxItemsPerChunk;
            }


            if (file !== undefined) {
                await addFormParam('file', file, true, true)
            }
    
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;
            requestBeforeHook({
                requestBody: bodyCreateUploadFileUploadfilePost,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Upload File From Url
         * @param {UploadFileFromUrlInput} uploadFileFromUrlInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFromUrl: async (uploadFileFromUrlInput: UploadFileFromUrlInput, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uploadFileFromUrlInput' is not null or undefined
            assertParamExists('uploadFromUrl', 'uploadFileFromUrlInput', uploadFileFromUrlInput)
            const localVarPath = `/upload_file_from_url`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "authorization", keyParamName: "accessToken", configuration, prefix: "Token " })
            // authentication apiKey required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "authorization", keyParamName: "apiKey", configuration, prefix: "Bearer " })
            // authentication customerId required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "customer-id", keyParamName: "customerId", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: uploadFileFromUrlInput,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration
            });
            localVarRequestOptions.data = serializeDataIfNeeded(uploadFileFromUrlInput, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Carbon supports multiple models for use in generating embeddings for files. For images, we support Vertex AI\'s multimodal model; for text, we support OpenAI\'s `text-embedding-ada-002` and Cohere\'s embed-multilingual-v3.0. The model can be specified via the `embedding_model` parameter (in the POST body for `/embeddings`, and a query  parameter in `/uploadfile`). If no model is supplied, the `text-embedding-ada-002` is used by default. When performing embedding queries, embeddings from files that used the specified model will be considered in the query. For example, if files A and B have embeddings generated with `OPENAI`, and files C and D have embeddings generated with `COHERE_MULTILINGUAL_V3`, then by default, queries will only consider files A and B. If `COHERE_MULTILINGUAL_V3` is specified as the `embedding_model` in `/embeddings`, then only files C and D will be considered. Make sure that the set of all files you want considered for a query have embeddings generated via the same model. For now, **do not** set `VERTEX_MULTIMODAL` as an `embedding_model`. This model is used automatically by Carbon when it detects an image file.
         * @summary Create Raw Text
         * @param {RawTextInput} rawTextInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadText: async (rawTextInput: RawTextInput, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rawTextInput' is not null or undefined
            assertParamExists('uploadText', 'rawTextInput', rawTextInput)
            const localVarPath = `/upload_text`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "authorization", keyParamName: "accessToken", configuration, prefix: "Token " })
            // authentication apiKey required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "authorization", keyParamName: "apiKey", configuration, prefix: "Bearer " })
            // authentication customerId required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "customer-id", keyParamName: "customerId", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: rawTextInput,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration
            });
            localVarRequestOptions.data = serializeDataIfNeeded(rawTextInput, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FilesApi - functional programming interface
 * @export
 */
export const FilesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FilesApiAxiosParamCreator(configuration)
    return {
        /**
         * A tag is a key-value pair that can be added to a file. This pair can then be used for searches (e.g. embedding searches) in order to narrow down the scope of the search. A file can have any number of tags. The following are reserved keys that cannot be used: - db_embedding_id - organization_id - user_id - organization_user_file_id  Carbon currently supports two data types for tag values - `string` and `list<string>`. Keys can only be `string`. If values other than `string` and `list<string>` are used, they\'re automatically converted to strings (e.g. 4 will become \"4\").
         * @summary Create File Tags
         * @param {FilesApiCreateUserFileTagsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUserFileTags(requestParameters: FilesApiCreateUserFileTagsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserFile>> {
            const organizationUserFileTagCreate: OrganizationUserFileTagCreate = {
                tags: requestParameters.tags,
                organization_user_file_id: requestParameters.organization_user_file_id
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUserFileTags(organizationUserFileTagCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete File Endpoint
         * @param {FilesApiDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async delete(requestParameters: FilesApiDeleteRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericSuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.delete(requestParameters.fileId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete File Tags
         * @param {FilesApiDeleteFileTagsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFileTags(requestParameters: FilesApiDeleteFileTagsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserFile>> {
            const organizationUserFileTagsRemove: OrganizationUserFileTagsRemove = {
                tags: requestParameters.tags,
                organization_user_file_id: requestParameters.organization_user_file_id
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFileTags(organizationUserFileTagsRemove, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete Files Endpoint
         * @param {FilesApiDeleteManyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMany(requestParameters: FilesApiDeleteManyRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericSuccessResponse>> {
            const deleteFilesQueryInput: DeleteFilesQueryInput = {
                file_ids: requestParameters.file_ids,
                sync_statuses: requestParameters.sync_statuses,
                delete_non_synced_only: requestParameters.delete_non_synced_only
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMany(deleteFilesQueryInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This route is deprecated. Use `/user_files_v2` instead.
         * @summary Parsed File
         * @param {FilesApiGetParsedFileRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getParsedFile(requestParameters: FilesApiGetParsedFileRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PresignedURLResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getParsedFile(requestParameters.fileId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This route is deprecated. Use `/user_files_v2` instead.
         * @summary Raw File
         * @param {FilesApiGetRawFileRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getRawFile(requestParameters: FilesApiGetRawFileRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PresignedURLResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRawFile(requestParameters.fileId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * For pre-filtering documents, using `tags_v2` is preferred to using `tags` (which is now deprecated). If both `tags_v2` and `tags` are specified, `tags` is ignored. `tags_v2` enables building complex filters through the use of \"AND\", \"OR\", and negation logic. Take the below input as an example: ```json {     \"OR\": [         {             \"key\": \"subject\",             \"value\": \"holy-bible\",             \"negate\": false         },         {             \"key\": \"person-of-interest\",             \"value\": \"jesus christ\",             \"negate\": false         },         {             \"key\": \"genre\",             \"value\": \"religion\",             \"negate\": true         }         {             \"AND\": [                 {                     \"key\": \"subject\",                     \"value\": \"tao-te-ching\",                     \"negate\": false                 },                 {                     \"key\": \"author\",                     \"value\": \"lao-tzu\",                     \"negate\": false                 }             ]         }     ] } ``` In this case, files will be filtered such that: 1. \"subject\" = \"holy-bible\" OR 2. \"person-of-interest\" = \"jesus christ\" OR 3. \"genre\" != \"religion\" OR 4. \"subject\" = \"tao-te-ching\" AND \"author\" = \"lao-tzu\"  Note that the top level of the query must be either an \"OR\" or \"AND\" array. Currently, nesting is limited to 3. For tag blocks (those with \"key\", \"value\", and \"negate\" keys), the following typing rules apply: 1. \"key\" isn\'t optional and must be a `string` 2. \"value\" isn\'t optional and can be `any` or list[`any`] 3. \"negate\" is optional and must be `true` or `false`. If present and `true`, then the filter block is negated in the resulting query. It is `false` by default.
         * @summary User Files V2
         * @param {FilesApiQueryUserFilesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queryUserFiles(requestParameters: FilesApiQueryUserFilesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserFilesV2>> {
            const organizationUserFilesToSyncQueryInput: OrganizationUserFilesToSyncQueryInput = {
                pagination: requestParameters.pagination,
                order_by: requestParameters.order_by,
                order_dir: requestParameters.order_dir,
                filters: requestParameters.filters,
                include_raw_file: requestParameters.include_raw_file,
                include_parsed_text_file: requestParameters.include_parsed_text_file,
                include_additional_files: requestParameters.include_additional_files
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.queryUserFiles(organizationUserFilesToSyncQueryInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This route is deprecated. Use `/user_files_v2` instead.
         * @summary User Files
         * @param {FilesApiQueryUserFilesDeprecatedRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async queryUserFilesDeprecated(requestParameters: FilesApiQueryUserFilesDeprecatedRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserFile>>> {
            const organizationUserFilesToSyncQueryInput: OrganizationUserFilesToSyncQueryInput = {
                pagination: requestParameters.pagination,
                order_by: requestParameters.order_by,
                order_dir: requestParameters.order_dir,
                filters: requestParameters.filters,
                include_raw_file: requestParameters.include_raw_file,
                include_parsed_text_file: requestParameters.include_parsed_text_file,
                include_additional_files: requestParameters.include_additional_files
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.queryUserFilesDeprecated(organizationUserFilesToSyncQueryInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Resync File
         * @param {FilesApiResyncRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resync(requestParameters: FilesApiResyncRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserFile>> {
            const resyncFileQueryInput: ResyncFileQueryInput = {
                file_id: requestParameters.file_id,
                chunk_size: requestParameters.chunk_size,
                chunk_overlap: requestParameters.chunk_overlap
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.resync(resyncFileQueryInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint is used to directly upload local files to Carbon. The `POST` request should be a multipart form request. Note that the `set_page_as_boundary` query parameter is applicable only to PDFs for now. When this value is set, PDF chunks are at most one page long. Additional information can be retrieved for each chunk, however, namely the coordinates of the bounding box around the chunk (this can be used for things like text highlighting). Following is a description of all possible query parameters: - `chunk_size`: the chunk size (in tokens) applied when splitting the document - `chunk_overlap`: the chunk overlap (in tokens) applied when splitting the document - `skip_embedding_generation`: whether or not to skip the generation of chunks and embeddings - `set_page_as_boundary`: described above - `embedding_model`: the model used to generate embeddings for the document chunks - `use_ocr`: whether or not to use OCR as a preprocessing step prior to generating chunks (only valid for PDFs currently) - `generate_sparse_vectors`: whether or not to generate sparse vectors for the file. Required for hybrid search. - `prepend_filename_to_chunks`: whether or not to prepend the filename to the chunk text   Carbon supports multiple models for use in generating embeddings for files. For images, we support Vertex AI\'s multimodal model; for text, we support OpenAI\'s `text-embedding-ada-002` and Cohere\'s embed-multilingual-v3.0. The model can be specified via the `embedding_model` parameter (in the POST body for `/embeddings`, and a query  parameter in `/uploadfile`). If no model is supplied, the `text-embedding-ada-002` is used by default. When performing embedding queries, embeddings from files that used the specified model will be considered in the query. For example, if files A and B have embeddings generated with `OPENAI`, and files C and D have embeddings generated with `COHERE_MULTILINGUAL_V3`, then by default, queries will only consider files A and B. If `COHERE_MULTILINGUAL_V3` is specified as the `embedding_model` in `/embeddings`, then only files C and D will be considered. Make sure that the set of all files you want considered for a query have embeddings generated via the same model. For now, **do not** set `VERTEX_MULTIMODAL` as an `embedding_model`. This model is used automatically by Carbon when it detects an image file.
         * @summary Create Upload File
         * @param {FilesApiUploadRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async upload(requestParameters: FilesApiUploadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserFile>> {
            const bodyCreateUploadFileUploadfilePost: BodyCreateUploadFileUploadfilePost = {
                file: requestParameters.file
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.upload(requestParameters.file, bodyCreateUploadFileUploadfilePost, requestParameters.chunkSize, requestParameters.chunkOverlap, requestParameters.skipEmbeddingGeneration, requestParameters.setPageAsBoundary, requestParameters.embeddingModel, requestParameters.useOcr, requestParameters.generateSparseVectors, requestParameters.prependFilenameToChunks, requestParameters.maxItemsPerChunk, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create Upload File From Url
         * @param {FilesApiUploadFromUrlRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadFromUrl(requestParameters: FilesApiUploadFromUrlRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserFile>> {
            const uploadFileFromUrlInput: UploadFileFromUrlInput = {
                url: requestParameters.url,
                file_name: requestParameters.file_name,
                chunk_size: requestParameters.chunk_size,
                chunk_overlap: requestParameters.chunk_overlap,
                skip_embedding_generation: requestParameters.skip_embedding_generation,
                set_page_as_boundary: requestParameters.set_page_as_boundary,
                embedding_model: requestParameters.embedding_model,
                generate_sparse_vectors: requestParameters.generate_sparse_vectors,
                use_textract: requestParameters.use_textract,
                prepend_filename_to_chunks: requestParameters.prepend_filename_to_chunks,
                max_items_per_chunk: requestParameters.max_items_per_chunk
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadFromUrl(uploadFileFromUrlInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Carbon supports multiple models for use in generating embeddings for files. For images, we support Vertex AI\'s multimodal model; for text, we support OpenAI\'s `text-embedding-ada-002` and Cohere\'s embed-multilingual-v3.0. The model can be specified via the `embedding_model` parameter (in the POST body for `/embeddings`, and a query  parameter in `/uploadfile`). If no model is supplied, the `text-embedding-ada-002` is used by default. When performing embedding queries, embeddings from files that used the specified model will be considered in the query. For example, if files A and B have embeddings generated with `OPENAI`, and files C and D have embeddings generated with `COHERE_MULTILINGUAL_V3`, then by default, queries will only consider files A and B. If `COHERE_MULTILINGUAL_V3` is specified as the `embedding_model` in `/embeddings`, then only files C and D will be considered. Make sure that the set of all files you want considered for a query have embeddings generated via the same model. For now, **do not** set `VERTEX_MULTIMODAL` as an `embedding_model`. This model is used automatically by Carbon when it detects an image file.
         * @summary Create Raw Text
         * @param {FilesApiUploadTextRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadText(requestParameters: FilesApiUploadTextRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserFile>> {
            const rawTextInput: RawTextInput = {
                contents: requestParameters.contents,
                name: requestParameters.name,
                chunk_size: requestParameters.chunk_size,
                chunk_overlap: requestParameters.chunk_overlap,
                skip_embedding_generation: requestParameters.skip_embedding_generation,
                overwrite_file_id: requestParameters.overwrite_file_id,
                embedding_model: requestParameters.embedding_model,
                generate_sparse_vectors: requestParameters.generate_sparse_vectors
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadText(rawTextInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FilesApi - factory interface
 * @export
 */
export const FilesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FilesApiFp(configuration)
    return {
        /**
         * A tag is a key-value pair that can be added to a file. This pair can then be used for searches (e.g. embedding searches) in order to narrow down the scope of the search. A file can have any number of tags. The following are reserved keys that cannot be used: - db_embedding_id - organization_id - user_id - organization_user_file_id  Carbon currently supports two data types for tag values - `string` and `list<string>`. Keys can only be `string`. If values other than `string` and `list<string>` are used, they\'re automatically converted to strings (e.g. 4 will become \"4\").
         * @summary Create File Tags
         * @param {FilesApiCreateUserFileTagsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserFileTags(requestParameters: FilesApiCreateUserFileTagsRequest, options?: AxiosRequestConfig): AxiosPromise<UserFile> {
            return localVarFp.createUserFileTags(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete File Endpoint
         * @param {FilesApiDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete(requestParameters: FilesApiDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<GenericSuccessResponse> {
            return localVarFp.delete(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete File Tags
         * @param {FilesApiDeleteFileTagsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFileTags(requestParameters: FilesApiDeleteFileTagsRequest, options?: AxiosRequestConfig): AxiosPromise<UserFile> {
            return localVarFp.deleteFileTags(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Files Endpoint
         * @param {FilesApiDeleteManyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMany(requestParameters: FilesApiDeleteManyRequest, options?: AxiosRequestConfig): AxiosPromise<GenericSuccessResponse> {
            return localVarFp.deleteMany(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * This route is deprecated. Use `/user_files_v2` instead.
         * @summary Parsed File
         * @param {FilesApiGetParsedFileRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getParsedFile(requestParameters: FilesApiGetParsedFileRequest, options?: AxiosRequestConfig): AxiosPromise<PresignedURLResponse> {
            return localVarFp.getParsedFile(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * This route is deprecated. Use `/user_files_v2` instead.
         * @summary Raw File
         * @param {FilesApiGetRawFileRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getRawFile(requestParameters: FilesApiGetRawFileRequest, options?: AxiosRequestConfig): AxiosPromise<PresignedURLResponse> {
            return localVarFp.getRawFile(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * For pre-filtering documents, using `tags_v2` is preferred to using `tags` (which is now deprecated). If both `tags_v2` and `tags` are specified, `tags` is ignored. `tags_v2` enables building complex filters through the use of \"AND\", \"OR\", and negation logic. Take the below input as an example: ```json {     \"OR\": [         {             \"key\": \"subject\",             \"value\": \"holy-bible\",             \"negate\": false         },         {             \"key\": \"person-of-interest\",             \"value\": \"jesus christ\",             \"negate\": false         },         {             \"key\": \"genre\",             \"value\": \"religion\",             \"negate\": true         }         {             \"AND\": [                 {                     \"key\": \"subject\",                     \"value\": \"tao-te-ching\",                     \"negate\": false                 },                 {                     \"key\": \"author\",                     \"value\": \"lao-tzu\",                     \"negate\": false                 }             ]         }     ] } ``` In this case, files will be filtered such that: 1. \"subject\" = \"holy-bible\" OR 2. \"person-of-interest\" = \"jesus christ\" OR 3. \"genre\" != \"religion\" OR 4. \"subject\" = \"tao-te-ching\" AND \"author\" = \"lao-tzu\"  Note that the top level of the query must be either an \"OR\" or \"AND\" array. Currently, nesting is limited to 3. For tag blocks (those with \"key\", \"value\", and \"negate\" keys), the following typing rules apply: 1. \"key\" isn\'t optional and must be a `string` 2. \"value\" isn\'t optional and can be `any` or list[`any`] 3. \"negate\" is optional and must be `true` or `false`. If present and `true`, then the filter block is negated in the resulting query. It is `false` by default.
         * @summary User Files V2
         * @param {FilesApiQueryUserFilesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryUserFiles(requestParameters: FilesApiQueryUserFilesRequest, options?: AxiosRequestConfig): AxiosPromise<UserFilesV2> {
            return localVarFp.queryUserFiles(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * This route is deprecated. Use `/user_files_v2` instead.
         * @summary User Files
         * @param {FilesApiQueryUserFilesDeprecatedRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        queryUserFilesDeprecated(requestParameters: FilesApiQueryUserFilesDeprecatedRequest, options?: AxiosRequestConfig): AxiosPromise<Array<UserFile>> {
            return localVarFp.queryUserFilesDeprecated(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Resync File
         * @param {FilesApiResyncRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resync(requestParameters: FilesApiResyncRequest, options?: AxiosRequestConfig): AxiosPromise<UserFile> {
            return localVarFp.resync(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint is used to directly upload local files to Carbon. The `POST` request should be a multipart form request. Note that the `set_page_as_boundary` query parameter is applicable only to PDFs for now. When this value is set, PDF chunks are at most one page long. Additional information can be retrieved for each chunk, however, namely the coordinates of the bounding box around the chunk (this can be used for things like text highlighting). Following is a description of all possible query parameters: - `chunk_size`: the chunk size (in tokens) applied when splitting the document - `chunk_overlap`: the chunk overlap (in tokens) applied when splitting the document - `skip_embedding_generation`: whether or not to skip the generation of chunks and embeddings - `set_page_as_boundary`: described above - `embedding_model`: the model used to generate embeddings for the document chunks - `use_ocr`: whether or not to use OCR as a preprocessing step prior to generating chunks (only valid for PDFs currently) - `generate_sparse_vectors`: whether or not to generate sparse vectors for the file. Required for hybrid search. - `prepend_filename_to_chunks`: whether or not to prepend the filename to the chunk text   Carbon supports multiple models for use in generating embeddings for files. For images, we support Vertex AI\'s multimodal model; for text, we support OpenAI\'s `text-embedding-ada-002` and Cohere\'s embed-multilingual-v3.0. The model can be specified via the `embedding_model` parameter (in the POST body for `/embeddings`, and a query  parameter in `/uploadfile`). If no model is supplied, the `text-embedding-ada-002` is used by default. When performing embedding queries, embeddings from files that used the specified model will be considered in the query. For example, if files A and B have embeddings generated with `OPENAI`, and files C and D have embeddings generated with `COHERE_MULTILINGUAL_V3`, then by default, queries will only consider files A and B. If `COHERE_MULTILINGUAL_V3` is specified as the `embedding_model` in `/embeddings`, then only files C and D will be considered. Make sure that the set of all files you want considered for a query have embeddings generated via the same model. For now, **do not** set `VERTEX_MULTIMODAL` as an `embedding_model`. This model is used automatically by Carbon when it detects an image file.
         * @summary Create Upload File
         * @param {FilesApiUploadRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upload(requestParameters: FilesApiUploadRequest, options?: AxiosRequestConfig): AxiosPromise<UserFile> {
            return localVarFp.upload(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Upload File From Url
         * @param {FilesApiUploadFromUrlRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFromUrl(requestParameters: FilesApiUploadFromUrlRequest, options?: AxiosRequestConfig): AxiosPromise<UserFile> {
            return localVarFp.uploadFromUrl(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Carbon supports multiple models for use in generating embeddings for files. For images, we support Vertex AI\'s multimodal model; for text, we support OpenAI\'s `text-embedding-ada-002` and Cohere\'s embed-multilingual-v3.0. The model can be specified via the `embedding_model` parameter (in the POST body for `/embeddings`, and a query  parameter in `/uploadfile`). If no model is supplied, the `text-embedding-ada-002` is used by default. When performing embedding queries, embeddings from files that used the specified model will be considered in the query. For example, if files A and B have embeddings generated with `OPENAI`, and files C and D have embeddings generated with `COHERE_MULTILINGUAL_V3`, then by default, queries will only consider files A and B. If `COHERE_MULTILINGUAL_V3` is specified as the `embedding_model` in `/embeddings`, then only files C and D will be considered. Make sure that the set of all files you want considered for a query have embeddings generated via the same model. For now, **do not** set `VERTEX_MULTIMODAL` as an `embedding_model`. This model is used automatically by Carbon when it detects an image file.
         * @summary Create Raw Text
         * @param {FilesApiUploadTextRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadText(requestParameters: FilesApiUploadTextRequest, options?: AxiosRequestConfig): AxiosPromise<UserFile> {
            return localVarFp.uploadText(requestParameters, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createUserFileTags operation in FilesApi.
 * @export
 * @interface FilesApiCreateUserFileTagsRequest
 */
export type FilesApiCreateUserFileTagsRequest = {
    
} & OrganizationUserFileTagCreate

/**
 * Request parameters for delete operation in FilesApi.
 * @export
 * @interface FilesApiDeleteRequest
 */
export type FilesApiDeleteRequest = {
    
    /**
    * 
    * @type {number}
    * @memberof FilesApiDelete
    */
    readonly fileId: number
    
}

/**
 * Request parameters for deleteFileTags operation in FilesApi.
 * @export
 * @interface FilesApiDeleteFileTagsRequest
 */
export type FilesApiDeleteFileTagsRequest = {
    
} & OrganizationUserFileTagsRemove

/**
 * Request parameters for deleteMany operation in FilesApi.
 * @export
 * @interface FilesApiDeleteManyRequest
 */
export type FilesApiDeleteManyRequest = {
    
} & DeleteFilesQueryInput

/**
 * Request parameters for getParsedFile operation in FilesApi.
 * @export
 * @interface FilesApiGetParsedFileRequest
 */
export type FilesApiGetParsedFileRequest = {
    
    /**
    * 
    * @type {number}
    * @memberof FilesApiGetParsedFile
    */
    readonly fileId: number
    
}

/**
 * Request parameters for getRawFile operation in FilesApi.
 * @export
 * @interface FilesApiGetRawFileRequest
 */
export type FilesApiGetRawFileRequest = {
    
    /**
    * 
    * @type {number}
    * @memberof FilesApiGetRawFile
    */
    readonly fileId: number
    
}

/**
 * Request parameters for queryUserFiles operation in FilesApi.
 * @export
 * @interface FilesApiQueryUserFilesRequest
 */
export type FilesApiQueryUserFilesRequest = {
    
} & OrganizationUserFilesToSyncQueryInput

/**
 * Request parameters for queryUserFilesDeprecated operation in FilesApi.
 * @export
 * @interface FilesApiQueryUserFilesDeprecatedRequest
 */
export type FilesApiQueryUserFilesDeprecatedRequest = {
    
} & OrganizationUserFilesToSyncQueryInput

/**
 * Request parameters for resync operation in FilesApi.
 * @export
 * @interface FilesApiResyncRequest
 */
export type FilesApiResyncRequest = {
    
} & ResyncFileQueryInput

/**
 * Request parameters for upload operation in FilesApi.
 * @export
 * @interface FilesApiUploadRequest
 */
export type FilesApiUploadRequest = {
    
    /**
    * 
    * @type {Uint8Array | File | buffer.File}
    * @memberof FilesApiUpload
    */
    readonly file: Uint8Array | File | buffer.File
    
    /**
    * Chunk size in tiktoken tokens to be used when processing file.
    * @type {number}
    * @memberof FilesApiUpload
    */
    readonly chunkSize?: number
    
    /**
    * Chunk overlap in tiktoken tokens to be used when processing file.
    * @type {number}
    * @memberof FilesApiUpload
    */
    readonly chunkOverlap?: number
    
    /**
    * Flag to control whether or not embeddings should be generated and stored             when processing file.
    * @type {boolean}
    * @memberof FilesApiUpload
    */
    readonly skipEmbeddingGeneration?: boolean
    
    /**
    * Flag to control whether or not to set the a page\'s worth of content as the maximum             amount of content that can appear in a chunk. Only valid for PDFs. See description route description for             more information.
    * @type {boolean}
    * @memberof FilesApiUpload
    */
    readonly setPageAsBoundary?: boolean
    
    /**
    * Embedding model that will be used to embed file chunks.
    * @type {TextEmbeddingGenerators}
    * @memberof FilesApiUpload
    */
    readonly embeddingModel?: TextEmbeddingGenerators
    
    /**
    * Whether or not to use OCR when processing files. Only valid for PDFs. Useful for documents with             tables, images, and/or scanned text.
    * @type {boolean}
    * @memberof FilesApiUpload
    */
    readonly useOcr?: boolean
    
    /**
    * Whether or not to generate sparse vectors for the file. This is *required* for the file to be a             candidate for hybrid search.
    * @type {boolean}
    * @memberof FilesApiUpload
    */
    readonly generateSparseVectors?: boolean
    
    /**
    * Whether or not to prepend the file\'s name to chunks.
    * @type {boolean}
    * @memberof FilesApiUpload
    */
    readonly prependFilenameToChunks?: boolean
    
    /**
    * Number of objects per chunk. For json files only.
    * @type {number}
    * @memberof FilesApiUpload
    */
    readonly maxItemsPerChunk?: number
    
} & BodyCreateUploadFileUploadfilePost

/**
 * Request parameters for uploadFromUrl operation in FilesApi.
 * @export
 * @interface FilesApiUploadFromUrlRequest
 */
export type FilesApiUploadFromUrlRequest = {
    
} & UploadFileFromUrlInput

/**
 * Request parameters for uploadText operation in FilesApi.
 * @export
 * @interface FilesApiUploadTextRequest
 */
export type FilesApiUploadTextRequest = {
    
} & RawTextInput

/**
 * FilesApiGenerated - object-oriented interface
 * @export
 * @class FilesApiGenerated
 * @extends {BaseAPI}
 */
export class FilesApiGenerated extends BaseAPI {
    /**
     * A tag is a key-value pair that can be added to a file. This pair can then be used for searches (e.g. embedding searches) in order to narrow down the scope of the search. A file can have any number of tags. The following are reserved keys that cannot be used: - db_embedding_id - organization_id - user_id - organization_user_file_id  Carbon currently supports two data types for tag values - `string` and `list<string>`. Keys can only be `string`. If values other than `string` and `list<string>` are used, they\'re automatically converted to strings (e.g. 4 will become \"4\").
     * @summary Create File Tags
     * @param {FilesApiCreateUserFileTagsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApiGenerated
     */
    public createUserFileTags(requestParameters: FilesApiCreateUserFileTagsRequest, options?: AxiosRequestConfig) {
        return FilesApiFp(this.configuration).createUserFileTags(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete File Endpoint
     * @param {FilesApiDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApiGenerated
     */
    public delete(requestParameters: FilesApiDeleteRequest, options?: AxiosRequestConfig) {
        return FilesApiFp(this.configuration).delete(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete File Tags
     * @param {FilesApiDeleteFileTagsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApiGenerated
     */
    public deleteFileTags(requestParameters: FilesApiDeleteFileTagsRequest, options?: AxiosRequestConfig) {
        return FilesApiFp(this.configuration).deleteFileTags(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Files Endpoint
     * @param {FilesApiDeleteManyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApiGenerated
     */
    public deleteMany(requestParameters: FilesApiDeleteManyRequest, options?: AxiosRequestConfig) {
        return FilesApiFp(this.configuration).deleteMany(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This route is deprecated. Use `/user_files_v2` instead.
     * @summary Parsed File
     * @param {FilesApiGetParsedFileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof FilesApiGenerated
     */
    public getParsedFile(requestParameters: FilesApiGetParsedFileRequest, options?: AxiosRequestConfig) {
        return FilesApiFp(this.configuration).getParsedFile(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This route is deprecated. Use `/user_files_v2` instead.
     * @summary Raw File
     * @param {FilesApiGetRawFileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof FilesApiGenerated
     */
    public getRawFile(requestParameters: FilesApiGetRawFileRequest, options?: AxiosRequestConfig) {
        return FilesApiFp(this.configuration).getRawFile(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * For pre-filtering documents, using `tags_v2` is preferred to using `tags` (which is now deprecated). If both `tags_v2` and `tags` are specified, `tags` is ignored. `tags_v2` enables building complex filters through the use of \"AND\", \"OR\", and negation logic. Take the below input as an example: ```json {     \"OR\": [         {             \"key\": \"subject\",             \"value\": \"holy-bible\",             \"negate\": false         },         {             \"key\": \"person-of-interest\",             \"value\": \"jesus christ\",             \"negate\": false         },         {             \"key\": \"genre\",             \"value\": \"religion\",             \"negate\": true         }         {             \"AND\": [                 {                     \"key\": \"subject\",                     \"value\": \"tao-te-ching\",                     \"negate\": false                 },                 {                     \"key\": \"author\",                     \"value\": \"lao-tzu\",                     \"negate\": false                 }             ]         }     ] } ``` In this case, files will be filtered such that: 1. \"subject\" = \"holy-bible\" OR 2. \"person-of-interest\" = \"jesus christ\" OR 3. \"genre\" != \"religion\" OR 4. \"subject\" = \"tao-te-ching\" AND \"author\" = \"lao-tzu\"  Note that the top level of the query must be either an \"OR\" or \"AND\" array. Currently, nesting is limited to 3. For tag blocks (those with \"key\", \"value\", and \"negate\" keys), the following typing rules apply: 1. \"key\" isn\'t optional and must be a `string` 2. \"value\" isn\'t optional and can be `any` or list[`any`] 3. \"negate\" is optional and must be `true` or `false`. If present and `true`, then the filter block is negated in the resulting query. It is `false` by default.
     * @summary User Files V2
     * @param {FilesApiQueryUserFilesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApiGenerated
     */
    public queryUserFiles(requestParameters: FilesApiQueryUserFilesRequest, options?: AxiosRequestConfig) {
        return FilesApiFp(this.configuration).queryUserFiles(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This route is deprecated. Use `/user_files_v2` instead.
     * @summary User Files
     * @param {FilesApiQueryUserFilesDeprecatedRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof FilesApiGenerated
     */
    public queryUserFilesDeprecated(requestParameters: FilesApiQueryUserFilesDeprecatedRequest, options?: AxiosRequestConfig) {
        return FilesApiFp(this.configuration).queryUserFilesDeprecated(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Resync File
     * @param {FilesApiResyncRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApiGenerated
     */
    public resync(requestParameters: FilesApiResyncRequest, options?: AxiosRequestConfig) {
        return FilesApiFp(this.configuration).resync(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint is used to directly upload local files to Carbon. The `POST` request should be a multipart form request. Note that the `set_page_as_boundary` query parameter is applicable only to PDFs for now. When this value is set, PDF chunks are at most one page long. Additional information can be retrieved for each chunk, however, namely the coordinates of the bounding box around the chunk (this can be used for things like text highlighting). Following is a description of all possible query parameters: - `chunk_size`: the chunk size (in tokens) applied when splitting the document - `chunk_overlap`: the chunk overlap (in tokens) applied when splitting the document - `skip_embedding_generation`: whether or not to skip the generation of chunks and embeddings - `set_page_as_boundary`: described above - `embedding_model`: the model used to generate embeddings for the document chunks - `use_ocr`: whether or not to use OCR as a preprocessing step prior to generating chunks (only valid for PDFs currently) - `generate_sparse_vectors`: whether or not to generate sparse vectors for the file. Required for hybrid search. - `prepend_filename_to_chunks`: whether or not to prepend the filename to the chunk text   Carbon supports multiple models for use in generating embeddings for files. For images, we support Vertex AI\'s multimodal model; for text, we support OpenAI\'s `text-embedding-ada-002` and Cohere\'s embed-multilingual-v3.0. The model can be specified via the `embedding_model` parameter (in the POST body for `/embeddings`, and a query  parameter in `/uploadfile`). If no model is supplied, the `text-embedding-ada-002` is used by default. When performing embedding queries, embeddings from files that used the specified model will be considered in the query. For example, if files A and B have embeddings generated with `OPENAI`, and files C and D have embeddings generated with `COHERE_MULTILINGUAL_V3`, then by default, queries will only consider files A and B. If `COHERE_MULTILINGUAL_V3` is specified as the `embedding_model` in `/embeddings`, then only files C and D will be considered. Make sure that the set of all files you want considered for a query have embeddings generated via the same model. For now, **do not** set `VERTEX_MULTIMODAL` as an `embedding_model`. This model is used automatically by Carbon when it detects an image file.
     * @summary Create Upload File
     * @param {FilesApiUploadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApiGenerated
     */
    public upload(requestParameters: FilesApiUploadRequest, options?: AxiosRequestConfig) {
        return FilesApiFp(this.configuration).upload(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Upload File From Url
     * @param {FilesApiUploadFromUrlRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApiGenerated
     */
    public uploadFromUrl(requestParameters: FilesApiUploadFromUrlRequest, options?: AxiosRequestConfig) {
        return FilesApiFp(this.configuration).uploadFromUrl(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Carbon supports multiple models for use in generating embeddings for files. For images, we support Vertex AI\'s multimodal model; for text, we support OpenAI\'s `text-embedding-ada-002` and Cohere\'s embed-multilingual-v3.0. The model can be specified via the `embedding_model` parameter (in the POST body for `/embeddings`, and a query  parameter in `/uploadfile`). If no model is supplied, the `text-embedding-ada-002` is used by default. When performing embedding queries, embeddings from files that used the specified model will be considered in the query. For example, if files A and B have embeddings generated with `OPENAI`, and files C and D have embeddings generated with `COHERE_MULTILINGUAL_V3`, then by default, queries will only consider files A and B. If `COHERE_MULTILINGUAL_V3` is specified as the `embedding_model` in `/embeddings`, then only files C and D will be considered. Make sure that the set of all files you want considered for a query have embeddings generated via the same model. For now, **do not** set `VERTEX_MULTIMODAL` as an `embedding_model`. This model is used automatically by Carbon when it detects an image file.
     * @summary Create Raw Text
     * @param {FilesApiUploadTextRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApiGenerated
     */
    public uploadText(requestParameters: FilesApiUploadTextRequest, options?: AxiosRequestConfig) {
        return FilesApiFp(this.configuration).uploadText(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }
}
