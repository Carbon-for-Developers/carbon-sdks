/*
 * Carbon
 * Connect external data to LLMs, no matter the source.
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by Konfig (https://konfigthis.com).
 * Do not edit the class manually.
 */


package com.konfigthis.carbonai.client.api;

import com.konfigthis.carbonai.client.ApiCallback;
import com.konfigthis.carbonai.client.ApiClient;
import com.konfigthis.carbonai.client.ApiException;
import com.konfigthis.carbonai.client.ApiResponse;
import com.konfigthis.carbonai.client.Configuration;
import com.konfigthis.carbonai.client.Pair;
import com.konfigthis.carbonai.client.ProgressRequestBody;
import com.konfigthis.carbonai.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import com.konfigthis.carbonai.client.model.ChunksAndEmbeddingsUploadInput;
import com.konfigthis.carbonai.client.model.DocumentResponseList;
import com.konfigthis.carbonai.client.model.EmbeddingGenerators;
import com.konfigthis.carbonai.client.model.EmbeddingGeneratorsNullable;
import com.konfigthis.carbonai.client.model.EmbeddingsAndChunksFilters;
import com.konfigthis.carbonai.client.model.EmbeddingsAndChunksOrderByColumns;
import com.konfigthis.carbonai.client.model.EmbeddingsAndChunksQueryInput;
import com.konfigthis.carbonai.client.model.EmbeddingsAndChunksResponse;
import com.konfigthis.carbonai.client.model.FileContentTypesNullable;
import com.konfigthis.carbonai.client.model.GenericSuccessResponse;
import com.konfigthis.carbonai.client.model.GetEmbeddingDocumentsBody;
import com.konfigthis.carbonai.client.model.HybridSearchTuningParamsNullable;
import com.konfigthis.carbonai.client.model.OrderDir;
import com.konfigthis.carbonai.client.model.Pagination;
import com.konfigthis.carbonai.client.model.SingleChunksAndEmbeddingsUploadInput;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.ws.rs.core.GenericType;

public class EmbeddingsApiGenerated {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public EmbeddingsApiGenerated() throws IllegalArgumentException {
        this(Configuration.getDefaultApiClient());
    }

    public EmbeddingsApiGenerated(ApiClient apiClient) throws IllegalArgumentException {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    private okhttp3.Call getDocumentsCall(GetEmbeddingDocumentsBody getEmbeddingDocumentsBody, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = getEmbeddingDocumentsBody;

        // create path and map variables
        String localVarPath = "/embeddings";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "accessToken", "apiKey", "customerId" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getDocumentsValidateBeforeCall(GetEmbeddingDocumentsBody getEmbeddingDocumentsBody, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'getEmbeddingDocumentsBody' is set
        if (getEmbeddingDocumentsBody == null) {
            throw new ApiException("Missing the required parameter 'getEmbeddingDocumentsBody' when calling getDocuments(Async)");
        }

        return getDocumentsCall(getEmbeddingDocumentsBody, _callback);

    }


    private ApiResponse<DocumentResponseList> getDocumentsWithHttpInfo(GetEmbeddingDocumentsBody getEmbeddingDocumentsBody) throws ApiException {
        okhttp3.Call localVarCall = getDocumentsValidateBeforeCall(getEmbeddingDocumentsBody, null);
        Type localVarReturnType = new TypeToken<DocumentResponseList>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getDocumentsAsync(GetEmbeddingDocumentsBody getEmbeddingDocumentsBody, final ApiCallback<DocumentResponseList> _callback) throws ApiException {

        okhttp3.Call localVarCall = getDocumentsValidateBeforeCall(getEmbeddingDocumentsBody, _callback);
        Type localVarReturnType = new TypeToken<DocumentResponseList>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class GetDocumentsRequestBuilder {
        private final String query;
        private final Integer k;
        private Map<String, Object> tags;
        private List<Double> queryVector;
        private List<Integer> fileIds;
        private List<Integer> parentFileIds;
        private Boolean includeAllChildren;
        private Object tagsV2;
        private Boolean includeTags;
        private Boolean includeVectors;
        private Boolean includeRawFile;
        private Boolean hybridSearch;
        private HybridSearchTuningParamsNullable hybridSearchTuningParameters;
        private FileContentTypesNullable mediaType;
        private EmbeddingGeneratorsNullable embeddingModel;

        private GetDocumentsRequestBuilder(String query, Integer k) {
            this.query = query;
            this.k = k;
        }

        /**
         * Set tags
         * @param tags A set of tags to limit the search to. Deprecated and may be removed in the future. (optional)
         * @return GetDocumentsRequestBuilder
         */
        public GetDocumentsRequestBuilder tags(Map<String, Object> tags) {
            this.tags = tags;
            return this;
        }
        
        /**
         * Set queryVector
         * @param queryVector Optional query vector for which to get related chunks and embeddings. It must have been         generated by the same model used to generate the embeddings across which the search is being conducted. Cannot         provide both &#x60;query&#x60; and &#x60;query_vector&#x60;. (optional)
         * @return GetDocumentsRequestBuilder
         */
        public GetDocumentsRequestBuilder queryVector(List<Double> queryVector) {
            this.queryVector = queryVector;
            return this;
        }
        
        /**
         * Set fileIds
         * @param fileIds Optional list of file IDs to limit the search to (optional)
         * @return GetDocumentsRequestBuilder
         */
        public GetDocumentsRequestBuilder fileIds(List<Integer> fileIds) {
            this.fileIds = fileIds;
            return this;
        }
        
        /**
         * Set parentFileIds
         * @param parentFileIds Optional list of parent file IDs to limit the search to. A parent file describes a file to which         another file belongs (e.g. a folder) (optional)
         * @return GetDocumentsRequestBuilder
         */
        public GetDocumentsRequestBuilder parentFileIds(List<Integer> parentFileIds) {
            this.parentFileIds = parentFileIds;
            return this;
        }
        
        /**
         * Set includeAllChildren
         * @param includeAllChildren Flag to control whether or not to include all children of filtered files in the embedding search. (optional, default to false)
         * @return GetDocumentsRequestBuilder
         */
        public GetDocumentsRequestBuilder includeAllChildren(Boolean includeAllChildren) {
            this.includeAllChildren = includeAllChildren;
            return this;
        }
        
        /**
         * Set tagsV2
         * @param tagsV2 A set of tags to limit the search to. Use this instead of &#x60;tags&#x60;, which is deprecated. (optional)
         * @return GetDocumentsRequestBuilder
         */
        public GetDocumentsRequestBuilder tagsV2(Object tagsV2) {
            this.tagsV2 = tagsV2;
            return this;
        }
        
        /**
         * Set includeTags
         * @param includeTags Flag to control whether or not to include tags for each chunk in the response. (optional)
         * @return GetDocumentsRequestBuilder
         */
        public GetDocumentsRequestBuilder includeTags(Boolean includeTags) {
            this.includeTags = includeTags;
            return this;
        }
        
        /**
         * Set includeVectors
         * @param includeVectors Flag to control whether or not to include embedding vectors in the response. (optional)
         * @return GetDocumentsRequestBuilder
         */
        public GetDocumentsRequestBuilder includeVectors(Boolean includeVectors) {
            this.includeVectors = includeVectors;
            return this;
        }
        
        /**
         * Set includeRawFile
         * @param includeRawFile Flag to control whether or not to include a signed URL to the raw file containing each chunk         in the response. (optional)
         * @return GetDocumentsRequestBuilder
         */
        public GetDocumentsRequestBuilder includeRawFile(Boolean includeRawFile) {
            this.includeRawFile = includeRawFile;
            return this;
        }
        
        /**
         * Set hybridSearch
         * @param hybridSearch Flag to control whether or not to perform hybrid search. (optional)
         * @return GetDocumentsRequestBuilder
         */
        public GetDocumentsRequestBuilder hybridSearch(Boolean hybridSearch) {
            this.hybridSearch = hybridSearch;
            return this;
        }
        
        /**
         * Set hybridSearchTuningParameters
         * @param hybridSearchTuningParameters  (optional)
         * @return GetDocumentsRequestBuilder
         */
        public GetDocumentsRequestBuilder hybridSearchTuningParameters(HybridSearchTuningParamsNullable hybridSearchTuningParameters) {
            this.hybridSearchTuningParameters = hybridSearchTuningParameters;
            return this;
        }
        
        /**
         * Set mediaType
         * @param mediaType  (optional, default to TEXT)
         * @return GetDocumentsRequestBuilder
         */
        public GetDocumentsRequestBuilder mediaType(FileContentTypesNullable mediaType) {
            this.mediaType = mediaType;
            return this;
        }
        
        /**
         * Set embeddingModel
         * @param embeddingModel  (optional, default to OPENAI)
         * @return GetDocumentsRequestBuilder
         */
        public GetDocumentsRequestBuilder embeddingModel(EmbeddingGeneratorsNullable embeddingModel) {
            this.embeddingModel = embeddingModel;
            return this;
        }
        
        /**
         * Build call for getDocuments
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            GetEmbeddingDocumentsBody getEmbeddingDocumentsBody = buildBodyParams();
            return getDocumentsCall(getEmbeddingDocumentsBody, _callback);
        }

        private GetEmbeddingDocumentsBody buildBodyParams() {
            GetEmbeddingDocumentsBody getEmbeddingDocumentsBody = new GetEmbeddingDocumentsBody();
            getEmbeddingDocumentsBody.tags(this.tags);
            getEmbeddingDocumentsBody.query(this.query);
            getEmbeddingDocumentsBody.queryVector(this.queryVector);
            getEmbeddingDocumentsBody.k(this.k);
            getEmbeddingDocumentsBody.fileIds(this.fileIds);
            getEmbeddingDocumentsBody.parentFileIds(this.parentFileIds);
            getEmbeddingDocumentsBody.includeAllChildren(this.includeAllChildren);
            getEmbeddingDocumentsBody.tagsV2(this.tagsV2);
            getEmbeddingDocumentsBody.includeTags(this.includeTags);
            getEmbeddingDocumentsBody.includeVectors(this.includeVectors);
            getEmbeddingDocumentsBody.includeRawFile(this.includeRawFile);
            getEmbeddingDocumentsBody.hybridSearch(this.hybridSearch);
            getEmbeddingDocumentsBody.hybridSearchTuningParameters(this.hybridSearchTuningParameters);
            getEmbeddingDocumentsBody.mediaType(this.mediaType);
            getEmbeddingDocumentsBody.embeddingModel(this.embeddingModel);
            return getEmbeddingDocumentsBody;
        }

        /**
         * Execute getDocuments request
         * @return DocumentResponseList
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public DocumentResponseList execute() throws ApiException {
            GetEmbeddingDocumentsBody getEmbeddingDocumentsBody = buildBodyParams();
            ApiResponse<DocumentResponseList> localVarResp = getDocumentsWithHttpInfo(getEmbeddingDocumentsBody);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute getDocuments request with HTTP info returned
         * @return ApiResponse&lt;DocumentResponseList&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<DocumentResponseList> executeWithHttpInfo() throws ApiException {
            GetEmbeddingDocumentsBody getEmbeddingDocumentsBody = buildBodyParams();
            return getDocumentsWithHttpInfo(getEmbeddingDocumentsBody);
        }

        /**
         * Execute getDocuments request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<DocumentResponseList> _callback) throws ApiException {
            GetEmbeddingDocumentsBody getEmbeddingDocumentsBody = buildBodyParams();
            return getDocumentsAsync(getEmbeddingDocumentsBody, _callback);
        }
    }

    /**
     * Embeddings
     * For pre-filtering documents, using &#x60;tags_v2&#x60; is preferred to using &#x60;tags&#x60; (which is now deprecated). If both &#x60;tags_v2&#x60; and &#x60;tags&#x60; are specified, &#x60;tags&#x60; is ignored. &#x60;tags_v2&#x60; enables building complex filters through the use of \&quot;AND\&quot;, \&quot;OR\&quot;, and negation logic. Take the below input as an example: &#x60;&#x60;&#x60;json {     \&quot;OR\&quot;: [         {             \&quot;key\&quot;: \&quot;subject\&quot;,             \&quot;value\&quot;: \&quot;holy-bible\&quot;,             \&quot;negate\&quot;: false         },         {             \&quot;key\&quot;: \&quot;person-of-interest\&quot;,             \&quot;value\&quot;: \&quot;jesus christ\&quot;,             \&quot;negate\&quot;: false         },         {             \&quot;key\&quot;: \&quot;genre\&quot;,             \&quot;value\&quot;: \&quot;religion\&quot;,             \&quot;negate\&quot;: true         }         {             \&quot;AND\&quot;: [                 {                     \&quot;key\&quot;: \&quot;subject\&quot;,                     \&quot;value\&quot;: \&quot;tao-te-ching\&quot;,                     \&quot;negate\&quot;: false                 },                 {                     \&quot;key\&quot;: \&quot;author\&quot;,                     \&quot;value\&quot;: \&quot;lao-tzu\&quot;,                     \&quot;negate\&quot;: false                 }             ]         }     ] } &#x60;&#x60;&#x60; In this case, files will be filtered such that: 1. \&quot;subject\&quot; &#x3D; \&quot;holy-bible\&quot; OR 2. \&quot;person-of-interest\&quot; &#x3D; \&quot;jesus christ\&quot; OR 3. \&quot;genre\&quot; !&#x3D; \&quot;religion\&quot; OR 4. \&quot;subject\&quot; &#x3D; \&quot;tao-te-ching\&quot; AND \&quot;author\&quot; &#x3D; \&quot;lao-tzu\&quot;  Note that the top level of the query must be either an \&quot;OR\&quot; or \&quot;AND\&quot; array. Currently, nesting is limited to 3. For tag blocks (those with \&quot;key\&quot;, \&quot;value\&quot;, and \&quot;negate\&quot; keys), the following typing rules apply: 1. \&quot;key\&quot; isn&#39;t optional and must be a &#x60;string&#x60; 2. \&quot;value\&quot; isn&#39;t optional and can be &#x60;any&#x60; or list[&#x60;any&#x60;] 3. \&quot;negate\&quot; is optional and must be &#x60;true&#x60; or &#x60;false&#x60;. If present and &#x60;true&#x60;, then the filter block is negated in the resulting query. It is &#x60;false&#x60; by default.   When querying embeddings, you can optionally specify the &#x60;media_type&#x60; parameter in your request. By default (if not set), it is equal to \&quot;TEXT\&quot;. This means that the query will be performed over files that have been parsed as text (for now, this covers all files except image files). If it is equal to \&quot;IMAGE\&quot;, the query will be performed over image files (for now, &#x60;.jpg&#x60; and &#x60;.png&#x60; files). You can think of this field as an additional filter on top of any filters set in &#x60;file_ids&#x60; and   When &#x60;hybrid_search&#x60; is set to true, a combination of keyword search and semantic search are used to rank and select candidate embeddings during information retrieval. By default, these search methods are weighted equally during the ranking process. To adjust the weight (or \&quot;importance\&quot;) of each search method, you can use the &#x60;hybrid_search_tuning_parameters&#x60; property. The description for the different tuning parameters are: - &#x60;weight_a&#x60;: weight to assign to semantic search - &#x60;weight_b&#x60;: weight to assign to keyword search  You must ensure that &#x60;sum(weight_a, weight_b,..., weight_n)&#x60; for all *n* weights is equal to 1. The equality has an error tolerance of 0.001 to account for possible floating point issues.  In order to use hybrid search for a customer across a set of documents, two flags need to be enabled: 1. Use the &#x60;/modify_user_configuration&#x60; endpoint to to enable &#x60;sparse_vectors&#x60; for the customer. The payload body for this request is below: &#x60;&#x60;&#x60; {   \&quot;configuration_key_name\&quot;: \&quot;sparse_vectors\&quot;,   \&quot;value\&quot;: {     \&quot;enabled\&quot;: true   } } &#x60;&#x60;&#x60; 2. Make sure hybrid search is enabled for the documents across which you want to perform the search. For the &#x60;/uploadfile&#x60; endpoint, this can be done by setting the following query parameter: &#x60;generate_sparse_vectors&#x3D;true&#x60;   Carbon supports multiple models for use in generating embeddings for files. For images, we support Vertex AI&#39;s multimodal model; for text, we support OpenAI&#39;s &#x60;text-embedding-ada-002&#x60; and Cohere&#39;s embed-multilingual-v3.0. The model can be specified via the &#x60;embedding_model&#x60; parameter (in the POST body for &#x60;/embeddings&#x60;, and a query  parameter in &#x60;/uploadfile&#x60;). If no model is supplied, the &#x60;text-embedding-ada-002&#x60; is used by default. When performing embedding queries, embeddings from files that used the specified model will be considered in the query. For example, if files A and B have embeddings generated with &#x60;OPENAI&#x60;, and files C and D have embeddings generated with &#x60;COHERE_MULTILINGUAL_V3&#x60;, then by default, queries will only consider files A and B. If &#x60;COHERE_MULTILINGUAL_V3&#x60; is specified as the &#x60;embedding_model&#x60; in &#x60;/embeddings&#x60;, then only files C and D will be considered. Make sure that the set of all files you want considered for a query have embeddings generated via the same model. For now, **do not** set &#x60;VERTEX_MULTIMODAL&#x60; as an &#x60;embedding_model&#x60;. This model is used automatically by Carbon when it detects an image file.
     * @param getEmbeddingDocumentsBody  (required)
     * @return GetDocumentsRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
     </table>
     */
    public GetDocumentsRequestBuilder getDocuments(String query, Integer k) throws IllegalArgumentException {
        if (query == null) throw new IllegalArgumentException("\"query\" is required but got null");
            if (query != null && query.length() < 1) {
              throw new IllegalArgumentException("Invalid value for query. Length must be greater than or equal to 1.");
            }

        if (k == null) throw new IllegalArgumentException("\"k\" is required but got null");
        return new GetDocumentsRequestBuilder(query, k);
    }
    private okhttp3.Call getEmbeddingsAndChunksCall(EmbeddingsAndChunksQueryInput embeddingsAndChunksQueryInput, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = embeddingsAndChunksQueryInput;

        // create path and map variables
        String localVarPath = "/text_chunks";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "accessToken", "apiKey", "customerId" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getEmbeddingsAndChunksValidateBeforeCall(EmbeddingsAndChunksQueryInput embeddingsAndChunksQueryInput, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'embeddingsAndChunksQueryInput' is set
        if (embeddingsAndChunksQueryInput == null) {
            throw new ApiException("Missing the required parameter 'embeddingsAndChunksQueryInput' when calling getEmbeddingsAndChunks(Async)");
        }

        return getEmbeddingsAndChunksCall(embeddingsAndChunksQueryInput, _callback);

    }


    private ApiResponse<EmbeddingsAndChunksResponse> getEmbeddingsAndChunksWithHttpInfo(EmbeddingsAndChunksQueryInput embeddingsAndChunksQueryInput) throws ApiException {
        okhttp3.Call localVarCall = getEmbeddingsAndChunksValidateBeforeCall(embeddingsAndChunksQueryInput, null);
        Type localVarReturnType = new TypeToken<EmbeddingsAndChunksResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getEmbeddingsAndChunksAsync(EmbeddingsAndChunksQueryInput embeddingsAndChunksQueryInput, final ApiCallback<EmbeddingsAndChunksResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getEmbeddingsAndChunksValidateBeforeCall(embeddingsAndChunksQueryInput, _callback);
        Type localVarReturnType = new TypeToken<EmbeddingsAndChunksResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class GetEmbeddingsAndChunksRequestBuilder {
        private final EmbeddingsAndChunksFilters filters;
        private Pagination pagination;
        private EmbeddingsAndChunksOrderByColumns orderBy;
        private OrderDir orderDir;
        private Boolean includeVectors;

        private GetEmbeddingsAndChunksRequestBuilder(EmbeddingsAndChunksFilters filters) {
            this.filters = filters;
        }

        /**
         * Set pagination
         * @param pagination  (optional)
         * @return GetEmbeddingsAndChunksRequestBuilder
         */
        public GetEmbeddingsAndChunksRequestBuilder pagination(Pagination pagination) {
            this.pagination = pagination;
            return this;
        }
        
        /**
         * Set orderBy
         * @param orderBy  (optional)
         * @return GetEmbeddingsAndChunksRequestBuilder
         */
        public GetEmbeddingsAndChunksRequestBuilder orderBy(EmbeddingsAndChunksOrderByColumns orderBy) {
            this.orderBy = orderBy;
            return this;
        }
        
        /**
         * Set orderDir
         * @param orderDir  (optional)
         * @return GetEmbeddingsAndChunksRequestBuilder
         */
        public GetEmbeddingsAndChunksRequestBuilder orderDir(OrderDir orderDir) {
            this.orderDir = orderDir;
            return this;
        }
        
        /**
         * Set includeVectors
         * @param includeVectors  (optional, default to false)
         * @return GetEmbeddingsAndChunksRequestBuilder
         */
        public GetEmbeddingsAndChunksRequestBuilder includeVectors(Boolean includeVectors) {
            this.includeVectors = includeVectors;
            return this;
        }
        
        /**
         * Build call for getEmbeddingsAndChunks
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            EmbeddingsAndChunksQueryInput embeddingsAndChunksQueryInput = buildBodyParams();
            return getEmbeddingsAndChunksCall(embeddingsAndChunksQueryInput, _callback);
        }

        private EmbeddingsAndChunksQueryInput buildBodyParams() {
            EmbeddingsAndChunksQueryInput embeddingsAndChunksQueryInput = new EmbeddingsAndChunksQueryInput();
            embeddingsAndChunksQueryInput.pagination(this.pagination);
            embeddingsAndChunksQueryInput.orderBy(this.orderBy);
            embeddingsAndChunksQueryInput.orderDir(this.orderDir);
            embeddingsAndChunksQueryInput.filters(this.filters);
            embeddingsAndChunksQueryInput.includeVectors(this.includeVectors);
            return embeddingsAndChunksQueryInput;
        }

        /**
         * Execute getEmbeddingsAndChunks request
         * @return EmbeddingsAndChunksResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public EmbeddingsAndChunksResponse execute() throws ApiException {
            EmbeddingsAndChunksQueryInput embeddingsAndChunksQueryInput = buildBodyParams();
            ApiResponse<EmbeddingsAndChunksResponse> localVarResp = getEmbeddingsAndChunksWithHttpInfo(embeddingsAndChunksQueryInput);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute getEmbeddingsAndChunks request with HTTP info returned
         * @return ApiResponse&lt;EmbeddingsAndChunksResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<EmbeddingsAndChunksResponse> executeWithHttpInfo() throws ApiException {
            EmbeddingsAndChunksQueryInput embeddingsAndChunksQueryInput = buildBodyParams();
            return getEmbeddingsAndChunksWithHttpInfo(embeddingsAndChunksQueryInput);
        }

        /**
         * Execute getEmbeddingsAndChunks request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<EmbeddingsAndChunksResponse> _callback) throws ApiException {
            EmbeddingsAndChunksQueryInput embeddingsAndChunksQueryInput = buildBodyParams();
            return getEmbeddingsAndChunksAsync(embeddingsAndChunksQueryInput, _callback);
        }
    }

    /**
     * Retrieve Embeddings And Content
     * 
     * @param embeddingsAndChunksQueryInput  (required)
     * @return GetEmbeddingsAndChunksRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
     </table>
     */
    public GetEmbeddingsAndChunksRequestBuilder getEmbeddingsAndChunks(EmbeddingsAndChunksFilters filters) throws IllegalArgumentException {
        if (filters == null) throw new IllegalArgumentException("\"filters\" is required but got null");
        return new GetEmbeddingsAndChunksRequestBuilder(filters);
    }
    private okhttp3.Call uploadChunksAndEmbeddingsCall(ChunksAndEmbeddingsUploadInput chunksAndEmbeddingsUploadInput, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = chunksAndEmbeddingsUploadInput;

        // create path and map variables
        String localVarPath = "/upload_chunks_and_embeddings";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "accessToken", "apiKey", "customerId" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call uploadChunksAndEmbeddingsValidateBeforeCall(ChunksAndEmbeddingsUploadInput chunksAndEmbeddingsUploadInput, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'chunksAndEmbeddingsUploadInput' is set
        if (chunksAndEmbeddingsUploadInput == null) {
            throw new ApiException("Missing the required parameter 'chunksAndEmbeddingsUploadInput' when calling uploadChunksAndEmbeddings(Async)");
        }

        return uploadChunksAndEmbeddingsCall(chunksAndEmbeddingsUploadInput, _callback);

    }


    private ApiResponse<GenericSuccessResponse> uploadChunksAndEmbeddingsWithHttpInfo(ChunksAndEmbeddingsUploadInput chunksAndEmbeddingsUploadInput) throws ApiException {
        okhttp3.Call localVarCall = uploadChunksAndEmbeddingsValidateBeforeCall(chunksAndEmbeddingsUploadInput, null);
        Type localVarReturnType = new TypeToken<GenericSuccessResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call uploadChunksAndEmbeddingsAsync(ChunksAndEmbeddingsUploadInput chunksAndEmbeddingsUploadInput, final ApiCallback<GenericSuccessResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = uploadChunksAndEmbeddingsValidateBeforeCall(chunksAndEmbeddingsUploadInput, _callback);
        Type localVarReturnType = new TypeToken<GenericSuccessResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class UploadChunksAndEmbeddingsRequestBuilder {
        private final EmbeddingGenerators embeddingModel;
        private final List<SingleChunksAndEmbeddingsUploadInput> chunksAndEmbeddings;
        private Boolean overwriteExisting;
        private Boolean chunksOnly;
        private Map<String, Object> customCredentials;

        private UploadChunksAndEmbeddingsRequestBuilder(EmbeddingGenerators embeddingModel, List<SingleChunksAndEmbeddingsUploadInput> chunksAndEmbeddings) {
            this.embeddingModel = embeddingModel;
            this.chunksAndEmbeddings = chunksAndEmbeddings;
        }

        /**
         * Set overwriteExisting
         * @param overwriteExisting  (optional, default to false)
         * @return UploadChunksAndEmbeddingsRequestBuilder
         */
        public UploadChunksAndEmbeddingsRequestBuilder overwriteExisting(Boolean overwriteExisting) {
            this.overwriteExisting = overwriteExisting;
            return this;
        }
        
        /**
         * Set chunksOnly
         * @param chunksOnly  (optional, default to false)
         * @return UploadChunksAndEmbeddingsRequestBuilder
         */
        public UploadChunksAndEmbeddingsRequestBuilder chunksOnly(Boolean chunksOnly) {
            this.chunksOnly = chunksOnly;
            return this;
        }
        
        /**
         * Set customCredentials
         * @param customCredentials  (optional)
         * @return UploadChunksAndEmbeddingsRequestBuilder
         */
        public UploadChunksAndEmbeddingsRequestBuilder customCredentials(Map<String, Object> customCredentials) {
            this.customCredentials = customCredentials;
            return this;
        }
        
        /**
         * Build call for uploadChunksAndEmbeddings
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            ChunksAndEmbeddingsUploadInput chunksAndEmbeddingsUploadInput = buildBodyParams();
            return uploadChunksAndEmbeddingsCall(chunksAndEmbeddingsUploadInput, _callback);
        }

        private ChunksAndEmbeddingsUploadInput buildBodyParams() {
            ChunksAndEmbeddingsUploadInput chunksAndEmbeddingsUploadInput = new ChunksAndEmbeddingsUploadInput();
            chunksAndEmbeddingsUploadInput.embeddingModel(this.embeddingModel);
            chunksAndEmbeddingsUploadInput.chunksAndEmbeddings(this.chunksAndEmbeddings);
            chunksAndEmbeddingsUploadInput.overwriteExisting(this.overwriteExisting);
            chunksAndEmbeddingsUploadInput.chunksOnly(this.chunksOnly);
            chunksAndEmbeddingsUploadInput.customCredentials(this.customCredentials);
            return chunksAndEmbeddingsUploadInput;
        }

        /**
         * Execute uploadChunksAndEmbeddings request
         * @return GenericSuccessResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public GenericSuccessResponse execute() throws ApiException {
            ChunksAndEmbeddingsUploadInput chunksAndEmbeddingsUploadInput = buildBodyParams();
            ApiResponse<GenericSuccessResponse> localVarResp = uploadChunksAndEmbeddingsWithHttpInfo(chunksAndEmbeddingsUploadInput);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute uploadChunksAndEmbeddings request with HTTP info returned
         * @return ApiResponse&lt;GenericSuccessResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<GenericSuccessResponse> executeWithHttpInfo() throws ApiException {
            ChunksAndEmbeddingsUploadInput chunksAndEmbeddingsUploadInput = buildBodyParams();
            return uploadChunksAndEmbeddingsWithHttpInfo(chunksAndEmbeddingsUploadInput);
        }

        /**
         * Execute uploadChunksAndEmbeddings request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<GenericSuccessResponse> _callback) throws ApiException {
            ChunksAndEmbeddingsUploadInput chunksAndEmbeddingsUploadInput = buildBodyParams();
            return uploadChunksAndEmbeddingsAsync(chunksAndEmbeddingsUploadInput, _callback);
        }
    }

    /**
     * Upload Chunks And Embeddings
     * 
     * @param chunksAndEmbeddingsUploadInput  (required)
     * @return UploadChunksAndEmbeddingsRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
     </table>
     */
    public UploadChunksAndEmbeddingsRequestBuilder uploadChunksAndEmbeddings(EmbeddingGenerators embeddingModel, List<SingleChunksAndEmbeddingsUploadInput> chunksAndEmbeddings) throws IllegalArgumentException {
        if (embeddingModel == null) throw new IllegalArgumentException("\"embeddingModel\" is required but got null");
        if (chunksAndEmbeddings == null) throw new IllegalArgumentException("\"chunksAndEmbeddings\" is required but got null");
        return new UploadChunksAndEmbeddingsRequestBuilder(embeddingModel, chunksAndEmbeddings);
    }
}
