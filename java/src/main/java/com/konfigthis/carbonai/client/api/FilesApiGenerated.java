/*
 * Carbon
 * Connect external data to LLMs, no matter the source.
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by Konfig (https://konfigthis.com).
 * Do not edit the class manually.
 */


package com.konfigthis.carbonai.client.api;

import com.konfigthis.carbonai.client.ApiCallback;
import com.konfigthis.carbonai.client.ApiClient;
import com.konfigthis.carbonai.client.ApiException;
import com.konfigthis.carbonai.client.ApiResponse;
import com.konfigthis.carbonai.client.Configuration;
import com.konfigthis.carbonai.client.Pair;
import com.konfigthis.carbonai.client.ProgressRequestBody;
import com.konfigthis.carbonai.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import com.konfigthis.carbonai.client.model.BodyCreateUploadFileUploadfilePost;
import com.konfigthis.carbonai.client.model.ColdStorageProps;
import com.konfigthis.carbonai.client.model.DeleteFilesQueryInput;
import com.konfigthis.carbonai.client.model.DeleteFilesV2QueryInput;
import com.konfigthis.carbonai.client.model.EmbeddingGenerators;
import com.konfigthis.carbonai.client.model.EmbeddingGeneratorsNullable;
import com.konfigthis.carbonai.client.model.ExternalFileSyncStatuses;
import java.io.File;
import com.konfigthis.carbonai.client.model.FileContentTypesNullable;
import com.konfigthis.carbonai.client.model.GenericSuccessResponse;
import com.konfigthis.carbonai.client.model.ModifyColdStorageParametersQueryInput;
import com.konfigthis.carbonai.client.model.MoveToHotStorageQueryInput;
import com.konfigthis.carbonai.client.model.OrderDir;
import com.konfigthis.carbonai.client.model.OrganizationUserFileTagCreate;
import com.konfigthis.carbonai.client.model.OrganizationUserFileTagsRemove;
import com.konfigthis.carbonai.client.model.OrganizationUserFilesToSyncFilters;
import com.konfigthis.carbonai.client.model.OrganizationUserFilesToSyncOrderByTypes;
import com.konfigthis.carbonai.client.model.OrganizationUserFilesToSyncQueryInput;
import com.konfigthis.carbonai.client.model.Pagination;
import com.konfigthis.carbonai.client.model.PresignedURLResponse;
import com.konfigthis.carbonai.client.model.RawTextInput;
import com.konfigthis.carbonai.client.model.ResyncFileQueryInput;
import com.konfigthis.carbonai.client.model.TMEmbeddingGenerators;
import com.konfigthis.carbonai.client.model.TranscriptionServiceNullable;
import com.konfigthis.carbonai.client.model.UploadFileFromUrlInput;
import com.konfigthis.carbonai.client.model.UserFile;
import com.konfigthis.carbonai.client.model.UserFilesV2;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.ws.rs.core.GenericType;

public class FilesApiGenerated {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public FilesApiGenerated() throws IllegalArgumentException {
        this(Configuration.getDefaultApiClient());
    }

    public FilesApiGenerated(ApiClient apiClient) throws IllegalArgumentException {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    private okhttp3.Call createUserFileTagsCall(OrganizationUserFileTagCreate organizationUserFileTagCreate, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = organizationUserFileTagCreate;

        // create path and map variables
        String localVarPath = "/create_user_file_tags";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "accessToken", "apiKey", "customerId" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call createUserFileTagsValidateBeforeCall(OrganizationUserFileTagCreate organizationUserFileTagCreate, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'organizationUserFileTagCreate' is set
        if (organizationUserFileTagCreate == null) {
            throw new ApiException("Missing the required parameter 'organizationUserFileTagCreate' when calling createUserFileTags(Async)");
        }

        return createUserFileTagsCall(organizationUserFileTagCreate, _callback);

    }


    private ApiResponse<UserFile> createUserFileTagsWithHttpInfo(OrganizationUserFileTagCreate organizationUserFileTagCreate) throws ApiException {
        okhttp3.Call localVarCall = createUserFileTagsValidateBeforeCall(organizationUserFileTagCreate, null);
        Type localVarReturnType = new TypeToken<UserFile>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call createUserFileTagsAsync(OrganizationUserFileTagCreate organizationUserFileTagCreate, final ApiCallback<UserFile> _callback) throws ApiException {

        okhttp3.Call localVarCall = createUserFileTagsValidateBeforeCall(organizationUserFileTagCreate, _callback);
        Type localVarReturnType = new TypeToken<UserFile>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public abstract class CreateUserFileTagsRequestBuilderGenerated {
        final Map<String, Object> tags;
        final Integer organizationUserFileId;

        public CreateUserFileTagsRequestBuilderGenerated(Map<String, Object> tags, Integer organizationUserFileId) {
            this.tags = tags;
            this.organizationUserFileId = organizationUserFileId;
        }

        /**
         * Build call for createUserFileTags
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            OrganizationUserFileTagCreate organizationUserFileTagCreate = buildBodyParams();
            return createUserFileTagsCall(organizationUserFileTagCreate, _callback);
        }

        private OrganizationUserFileTagCreate buildBodyParams() {
            OrganizationUserFileTagCreate organizationUserFileTagCreate = new OrganizationUserFileTagCreate();
            organizationUserFileTagCreate.tags(this.tags);
            organizationUserFileTagCreate.organizationUserFileId(this.organizationUserFileId);
            return organizationUserFileTagCreate;
        }

        /**
         * Execute createUserFileTags request
         * @return UserFile
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public UserFile execute() throws ApiException {
            OrganizationUserFileTagCreate organizationUserFileTagCreate = buildBodyParams();
            ApiResponse<UserFile> localVarResp = createUserFileTagsWithHttpInfo(organizationUserFileTagCreate);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute createUserFileTags request with HTTP info returned
         * @return ApiResponse&lt;UserFile&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<UserFile> executeWithHttpInfo() throws ApiException {
            OrganizationUserFileTagCreate organizationUserFileTagCreate = buildBodyParams();
            return createUserFileTagsWithHttpInfo(organizationUserFileTagCreate);
        }

        /**
         * Execute createUserFileTags request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<UserFile> _callback) throws ApiException {
            OrganizationUserFileTagCreate organizationUserFileTagCreate = buildBodyParams();
            return createUserFileTagsAsync(organizationUserFileTagCreate, _callback);
        }
    }

    /**
     * Create File Tags
     * A tag is a key-value pair that can be added to a file. This pair can then be used for searches (e.g. embedding searches) in order to narrow down the scope of the search. A file can have any number of tags. The following are reserved keys that cannot be used: - db_embedding_id - organization_id - user_id - organization_user_file_id  Carbon currently supports two data types for tag values - &#x60;string&#x60; and &#x60;list&lt;string&gt;&#x60;. Keys can only be &#x60;string&#x60;. If values other than &#x60;string&#x60; and &#x60;list&lt;string&gt;&#x60; are used, they&#39;re automatically converted to strings (e.g. 4 will become \&quot;4\&quot;).
     * @param organizationUserFileTagCreate  (required)
     * @return CreateUserFileTagsRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
     </table>
     */
    public FilesApi.CreateUserFileTagsRequestBuilder createUserFileTags(Map<String, Object> tags, Integer organizationUserFileId) throws IllegalArgumentException {
        if (tags == null) throw new IllegalArgumentException("\"tags\" is required but got null");
        if (organizationUserFileId == null) throw new IllegalArgumentException("\"organizationUserFileId\" is required but got null");
        return ((FilesApi) this).new CreateUserFileTagsRequestBuilder(tags, organizationUserFileId);
    }
    private okhttp3.Call deleteFileTagsCall(OrganizationUserFileTagsRemove organizationUserFileTagsRemove, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = organizationUserFileTagsRemove;

        // create path and map variables
        String localVarPath = "/delete_user_file_tags";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "accessToken", "apiKey", "customerId" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call deleteFileTagsValidateBeforeCall(OrganizationUserFileTagsRemove organizationUserFileTagsRemove, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'organizationUserFileTagsRemove' is set
        if (organizationUserFileTagsRemove == null) {
            throw new ApiException("Missing the required parameter 'organizationUserFileTagsRemove' when calling deleteFileTags(Async)");
        }

        return deleteFileTagsCall(organizationUserFileTagsRemove, _callback);

    }


    private ApiResponse<UserFile> deleteFileTagsWithHttpInfo(OrganizationUserFileTagsRemove organizationUserFileTagsRemove) throws ApiException {
        okhttp3.Call localVarCall = deleteFileTagsValidateBeforeCall(organizationUserFileTagsRemove, null);
        Type localVarReturnType = new TypeToken<UserFile>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call deleteFileTagsAsync(OrganizationUserFileTagsRemove organizationUserFileTagsRemove, final ApiCallback<UserFile> _callback) throws ApiException {

        okhttp3.Call localVarCall = deleteFileTagsValidateBeforeCall(organizationUserFileTagsRemove, _callback);
        Type localVarReturnType = new TypeToken<UserFile>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public abstract class DeleteFileTagsRequestBuilderGenerated {
        final List<String> tags;
        final Integer organizationUserFileId;

        public DeleteFileTagsRequestBuilderGenerated(List<String> tags, Integer organizationUserFileId) {
            this.tags = tags;
            this.organizationUserFileId = organizationUserFileId;
        }

        /**
         * Build call for deleteFileTags
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            OrganizationUserFileTagsRemove organizationUserFileTagsRemove = buildBodyParams();
            return deleteFileTagsCall(organizationUserFileTagsRemove, _callback);
        }

        private OrganizationUserFileTagsRemove buildBodyParams() {
            OrganizationUserFileTagsRemove organizationUserFileTagsRemove = new OrganizationUserFileTagsRemove();
            organizationUserFileTagsRemove.tags(this.tags);
            organizationUserFileTagsRemove.organizationUserFileId(this.organizationUserFileId);
            return organizationUserFileTagsRemove;
        }

        /**
         * Execute deleteFileTags request
         * @return UserFile
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public UserFile execute() throws ApiException {
            OrganizationUserFileTagsRemove organizationUserFileTagsRemove = buildBodyParams();
            ApiResponse<UserFile> localVarResp = deleteFileTagsWithHttpInfo(organizationUserFileTagsRemove);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute deleteFileTags request with HTTP info returned
         * @return ApiResponse&lt;UserFile&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<UserFile> executeWithHttpInfo() throws ApiException {
            OrganizationUserFileTagsRemove organizationUserFileTagsRemove = buildBodyParams();
            return deleteFileTagsWithHttpInfo(organizationUserFileTagsRemove);
        }

        /**
         * Execute deleteFileTags request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<UserFile> _callback) throws ApiException {
            OrganizationUserFileTagsRemove organizationUserFileTagsRemove = buildBodyParams();
            return deleteFileTagsAsync(organizationUserFileTagsRemove, _callback);
        }
    }

    /**
     * Delete File Tags
     * 
     * @param organizationUserFileTagsRemove  (required)
     * @return DeleteFileTagsRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
     </table>
     */
    public FilesApi.DeleteFileTagsRequestBuilder deleteFileTags(List<String> tags, Integer organizationUserFileId) throws IllegalArgumentException {
        if (tags == null) throw new IllegalArgumentException("\"tags\" is required but got null");
        if (organizationUserFileId == null) throw new IllegalArgumentException("\"organizationUserFileId\" is required but got null");
        return ((FilesApi) this).new DeleteFileTagsRequestBuilder(tags, organizationUserFileId);
    }
    private okhttp3.Call deleteManyCall(DeleteFilesQueryInput deleteFilesQueryInput, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = deleteFilesQueryInput;

        // create path and map variables
        String localVarPath = "/delete_files";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "accessToken", "apiKey", "customerId" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @Deprecated
    @SuppressWarnings("rawtypes")
    private okhttp3.Call deleteManyValidateBeforeCall(DeleteFilesQueryInput deleteFilesQueryInput, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'deleteFilesQueryInput' is set
        if (deleteFilesQueryInput == null) {
            throw new ApiException("Missing the required parameter 'deleteFilesQueryInput' when calling deleteMany(Async)");
        }

        return deleteManyCall(deleteFilesQueryInput, _callback);

    }


    private ApiResponse<GenericSuccessResponse> deleteManyWithHttpInfo(DeleteFilesQueryInput deleteFilesQueryInput) throws ApiException {
        okhttp3.Call localVarCall = deleteManyValidateBeforeCall(deleteFilesQueryInput, null);
        Type localVarReturnType = new TypeToken<GenericSuccessResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call deleteManyAsync(DeleteFilesQueryInput deleteFilesQueryInput, final ApiCallback<GenericSuccessResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = deleteManyValidateBeforeCall(deleteFilesQueryInput, _callback);
        Type localVarReturnType = new TypeToken<GenericSuccessResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public abstract class DeleteManyRequestBuilderGenerated {
        List<Integer> fileIds;
        List<ExternalFileSyncStatuses> syncStatuses;
        Boolean deleteNonSyncedOnly;
        Boolean sendWebhook;
        Boolean deleteChildFiles;

        public DeleteManyRequestBuilderGenerated() {
        }

        /**
         * Set fileIds
         * @param fileIds  (optional)
         * @return FilesApi.DeleteManyRequestBuilder
         */
        public FilesApi.DeleteManyRequestBuilder fileIds(List<Integer> fileIds) {
            this.fileIds = fileIds;
            return (FilesApi.DeleteManyRequestBuilder) this;
        }
        
        /**
         * Set syncStatuses
         * @param syncStatuses  (optional)
         * @return FilesApi.DeleteManyRequestBuilder
         */
        public FilesApi.DeleteManyRequestBuilder syncStatuses(List<ExternalFileSyncStatuses> syncStatuses) {
            this.syncStatuses = syncStatuses;
            return (FilesApi.DeleteManyRequestBuilder) this;
        }
        
        /**
         * Set deleteNonSyncedOnly
         * @param deleteNonSyncedOnly  (optional, default to false)
         * @return FilesApi.DeleteManyRequestBuilder
         */
        public FilesApi.DeleteManyRequestBuilder deleteNonSyncedOnly(Boolean deleteNonSyncedOnly) {
            this.deleteNonSyncedOnly = deleteNonSyncedOnly;
            return (FilesApi.DeleteManyRequestBuilder) this;
        }
        
        /**
         * Set sendWebhook
         * @param sendWebhook  (optional, default to false)
         * @return FilesApi.DeleteManyRequestBuilder
         */
        public FilesApi.DeleteManyRequestBuilder sendWebhook(Boolean sendWebhook) {
            this.sendWebhook = sendWebhook;
            return (FilesApi.DeleteManyRequestBuilder) this;
        }
        
        /**
         * Set deleteChildFiles
         * @param deleteChildFiles  (optional, default to false)
         * @return FilesApi.DeleteManyRequestBuilder
         */
        public FilesApi.DeleteManyRequestBuilder deleteChildFiles(Boolean deleteChildFiles) {
            this.deleteChildFiles = deleteChildFiles;
            return (FilesApi.DeleteManyRequestBuilder) this;
        }
        
        /**
         * Build call for deleteMany
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         * @deprecated
         */
        @Deprecated
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            DeleteFilesQueryInput deleteFilesQueryInput = buildBodyParams();
            return deleteManyCall(deleteFilesQueryInput, _callback);
        }

        private DeleteFilesQueryInput buildBodyParams() {
            DeleteFilesQueryInput deleteFilesQueryInput = new DeleteFilesQueryInput();
            deleteFilesQueryInput.fileIds(this.fileIds);
            deleteFilesQueryInput.syncStatuses(this.syncStatuses);
            deleteFilesQueryInput.deleteNonSyncedOnly(this.deleteNonSyncedOnly);
            deleteFilesQueryInput.sendWebhook(this.sendWebhook);
            deleteFilesQueryInput.deleteChildFiles(this.deleteChildFiles);
            return deleteFilesQueryInput;
        }

        /**
         * Execute deleteMany request
         * @return GenericSuccessResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         * @deprecated
         */
        @Deprecated
        public GenericSuccessResponse execute() throws ApiException {
            DeleteFilesQueryInput deleteFilesQueryInput = buildBodyParams();
            ApiResponse<GenericSuccessResponse> localVarResp = deleteManyWithHttpInfo(deleteFilesQueryInput);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute deleteMany request with HTTP info returned
         * @return ApiResponse&lt;GenericSuccessResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         * @deprecated
         */
        @Deprecated
        public ApiResponse<GenericSuccessResponse> executeWithHttpInfo() throws ApiException {
            DeleteFilesQueryInput deleteFilesQueryInput = buildBodyParams();
            return deleteManyWithHttpInfo(deleteFilesQueryInput);
        }

        /**
         * Execute deleteMany request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         * @deprecated
         */
        @Deprecated
        public okhttp3.Call executeAsync(final ApiCallback<GenericSuccessResponse> _callback) throws ApiException {
            DeleteFilesQueryInput deleteFilesQueryInput = buildBodyParams();
            return deleteManyAsync(deleteFilesQueryInput, _callback);
        }
    }

    /**
     * Delete Files Endpoint
     * 
     * @param deleteFilesQueryInput  (required)
     * @return DeleteManyRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
     </table>
     * @deprecated
     */
    @Deprecated
    public FilesApi.DeleteManyRequestBuilder deleteMany() throws IllegalArgumentException {
        return ((FilesApi) this).new DeleteManyRequestBuilder();
    }
    private okhttp3.Call deleteV2Call(DeleteFilesV2QueryInput deleteFilesV2QueryInput, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = deleteFilesV2QueryInput;

        // create path and map variables
        String localVarPath = "/delete_files_v2";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "accessToken", "apiKey", "customerId" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call deleteV2ValidateBeforeCall(DeleteFilesV2QueryInput deleteFilesV2QueryInput, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'deleteFilesV2QueryInput' is set
        if (deleteFilesV2QueryInput == null) {
            throw new ApiException("Missing the required parameter 'deleteFilesV2QueryInput' when calling deleteV2(Async)");
        }

        return deleteV2Call(deleteFilesV2QueryInput, _callback);

    }


    private ApiResponse<GenericSuccessResponse> deleteV2WithHttpInfo(DeleteFilesV2QueryInput deleteFilesV2QueryInput) throws ApiException {
        okhttp3.Call localVarCall = deleteV2ValidateBeforeCall(deleteFilesV2QueryInput, null);
        Type localVarReturnType = new TypeToken<GenericSuccessResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call deleteV2Async(DeleteFilesV2QueryInput deleteFilesV2QueryInput, final ApiCallback<GenericSuccessResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = deleteV2ValidateBeforeCall(deleteFilesV2QueryInput, _callback);
        Type localVarReturnType = new TypeToken<GenericSuccessResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public abstract class DeleteV2RequestBuilderGenerated {
        OrganizationUserFilesToSyncFilters filters;
        Boolean sendWebhook;
        Boolean preserveFileRecord;

        public DeleteV2RequestBuilderGenerated() {
        }

        /**
         * Set filters
         * @param filters  (optional)
         * @return FilesApi.DeleteV2RequestBuilder
         */
        public FilesApi.DeleteV2RequestBuilder filters(OrganizationUserFilesToSyncFilters filters) {
            this.filters = filters;
            return (FilesApi.DeleteV2RequestBuilder) this;
        }
        
        /**
         * Set sendWebhook
         * @param sendWebhook  (optional, default to false)
         * @return FilesApi.DeleteV2RequestBuilder
         */
        public FilesApi.DeleteV2RequestBuilder sendWebhook(Boolean sendWebhook) {
            this.sendWebhook = sendWebhook;
            return (FilesApi.DeleteV2RequestBuilder) this;
        }
        
        /**
         * Set preserveFileRecord
         * @param preserveFileRecord Whether or not to delete all data related to the file from the database, BUT to preserve the file metadata, allowing for         resyncs. By default &#x60;preserve_file_record&#x60; is false, which means that all data related to the file *as well as* its metadata will be deleted. Note that         even if &#x60;preserve_file_record&#x60; is true, raw files uploaded via the &#x60;uploadfile&#x60; endpoint still cannot be resynced. (optional, default to false)
         * @return FilesApi.DeleteV2RequestBuilder
         */
        public FilesApi.DeleteV2RequestBuilder preserveFileRecord(Boolean preserveFileRecord) {
            this.preserveFileRecord = preserveFileRecord;
            return (FilesApi.DeleteV2RequestBuilder) this;
        }
        
        /**
         * Build call for deleteV2
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            DeleteFilesV2QueryInput deleteFilesV2QueryInput = buildBodyParams();
            return deleteV2Call(deleteFilesV2QueryInput, _callback);
        }

        private DeleteFilesV2QueryInput buildBodyParams() {
            DeleteFilesV2QueryInput deleteFilesV2QueryInput = new DeleteFilesV2QueryInput();
            deleteFilesV2QueryInput.filters(this.filters);
            deleteFilesV2QueryInput.sendWebhook(this.sendWebhook);
            deleteFilesV2QueryInput.preserveFileRecord(this.preserveFileRecord);
            return deleteFilesV2QueryInput;
        }

        /**
         * Execute deleteV2 request
         * @return GenericSuccessResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public GenericSuccessResponse execute() throws ApiException {
            DeleteFilesV2QueryInput deleteFilesV2QueryInput = buildBodyParams();
            ApiResponse<GenericSuccessResponse> localVarResp = deleteV2WithHttpInfo(deleteFilesV2QueryInput);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute deleteV2 request with HTTP info returned
         * @return ApiResponse&lt;GenericSuccessResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<GenericSuccessResponse> executeWithHttpInfo() throws ApiException {
            DeleteFilesV2QueryInput deleteFilesV2QueryInput = buildBodyParams();
            return deleteV2WithHttpInfo(deleteFilesV2QueryInput);
        }

        /**
         * Execute deleteV2 request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<GenericSuccessResponse> _callback) throws ApiException {
            DeleteFilesV2QueryInput deleteFilesV2QueryInput = buildBodyParams();
            return deleteV2Async(deleteFilesV2QueryInput, _callback);
        }
    }

    /**
     * Delete Files V2 Endpoint
     * 
     * @param deleteFilesV2QueryInput  (required)
     * @return DeleteV2RequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
     </table>
     */
    public FilesApi.DeleteV2RequestBuilder deleteV2() throws IllegalArgumentException {
        return ((FilesApi) this).new DeleteV2RequestBuilder();
    }
    private okhttp3.Call getParsedFileCall(Integer fileId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/parsed_file/{file_id}"
            .replace("{" + "file_id" + "}", localVarApiClient.escapeString(fileId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "accessToken", "apiKey", "customerId" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @Deprecated
    @SuppressWarnings("rawtypes")
    private okhttp3.Call getParsedFileValidateBeforeCall(Integer fileId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'fileId' is set
        if (fileId == null) {
            throw new ApiException("Missing the required parameter 'fileId' when calling getParsedFile(Async)");
        }

        return getParsedFileCall(fileId, _callback);

    }


    private ApiResponse<PresignedURLResponse> getParsedFileWithHttpInfo(Integer fileId) throws ApiException {
        okhttp3.Call localVarCall = getParsedFileValidateBeforeCall(fileId, null);
        Type localVarReturnType = new TypeToken<PresignedURLResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getParsedFileAsync(Integer fileId, final ApiCallback<PresignedURLResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getParsedFileValidateBeforeCall(fileId, _callback);
        Type localVarReturnType = new TypeToken<PresignedURLResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public abstract class GetParsedFileRequestBuilderGenerated {
        final Integer fileId;

        public GetParsedFileRequestBuilderGenerated(Integer fileId) {
            this.fileId = fileId;
        }

        /**
         * Build call for getParsedFile
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         * @deprecated
         */
        @Deprecated
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getParsedFileCall(fileId, _callback);
        }


        /**
         * Execute getParsedFile request
         * @return PresignedURLResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         * @deprecated
         */
        @Deprecated
        public PresignedURLResponse execute() throws ApiException {
            ApiResponse<PresignedURLResponse> localVarResp = getParsedFileWithHttpInfo(fileId);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute getParsedFile request with HTTP info returned
         * @return ApiResponse&lt;PresignedURLResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         * @deprecated
         */
        @Deprecated
        public ApiResponse<PresignedURLResponse> executeWithHttpInfo() throws ApiException {
            return getParsedFileWithHttpInfo(fileId);
        }

        /**
         * Execute getParsedFile request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         * @deprecated
         */
        @Deprecated
        public okhttp3.Call executeAsync(final ApiCallback<PresignedURLResponse> _callback) throws ApiException {
            return getParsedFileAsync(fileId, _callback);
        }
    }

    /**
     * Parsed File
     * This route is deprecated. Use &#x60;/user_files_v2&#x60; instead.
     * @param fileId  (required)
     * @return GetParsedFileRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
     </table>
     * @deprecated
     */
    @Deprecated
    public FilesApi.GetParsedFileRequestBuilder getParsedFile(Integer fileId) throws IllegalArgumentException {
        if (fileId == null) throw new IllegalArgumentException("\"fileId\" is required but got null");
        return ((FilesApi) this).new GetParsedFileRequestBuilder(fileId);
    }
    private okhttp3.Call getRawFileCall(Integer fileId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/raw_file/{file_id}"
            .replace("{" + "file_id" + "}", localVarApiClient.escapeString(fileId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "accessToken", "apiKey", "customerId" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @Deprecated
    @SuppressWarnings("rawtypes")
    private okhttp3.Call getRawFileValidateBeforeCall(Integer fileId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'fileId' is set
        if (fileId == null) {
            throw new ApiException("Missing the required parameter 'fileId' when calling getRawFile(Async)");
        }

        return getRawFileCall(fileId, _callback);

    }


    private ApiResponse<PresignedURLResponse> getRawFileWithHttpInfo(Integer fileId) throws ApiException {
        okhttp3.Call localVarCall = getRawFileValidateBeforeCall(fileId, null);
        Type localVarReturnType = new TypeToken<PresignedURLResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getRawFileAsync(Integer fileId, final ApiCallback<PresignedURLResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getRawFileValidateBeforeCall(fileId, _callback);
        Type localVarReturnType = new TypeToken<PresignedURLResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public abstract class GetRawFileRequestBuilderGenerated {
        final Integer fileId;

        public GetRawFileRequestBuilderGenerated(Integer fileId) {
            this.fileId = fileId;
        }

        /**
         * Build call for getRawFile
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         * @deprecated
         */
        @Deprecated
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getRawFileCall(fileId, _callback);
        }


        /**
         * Execute getRawFile request
         * @return PresignedURLResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         * @deprecated
         */
        @Deprecated
        public PresignedURLResponse execute() throws ApiException {
            ApiResponse<PresignedURLResponse> localVarResp = getRawFileWithHttpInfo(fileId);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute getRawFile request with HTTP info returned
         * @return ApiResponse&lt;PresignedURLResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         * @deprecated
         */
        @Deprecated
        public ApiResponse<PresignedURLResponse> executeWithHttpInfo() throws ApiException {
            return getRawFileWithHttpInfo(fileId);
        }

        /**
         * Execute getRawFile request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         * @deprecated
         */
        @Deprecated
        public okhttp3.Call executeAsync(final ApiCallback<PresignedURLResponse> _callback) throws ApiException {
            return getRawFileAsync(fileId, _callback);
        }
    }

    /**
     * Raw File
     * This route is deprecated. Use &#x60;/user_files_v2&#x60; instead.
     * @param fileId  (required)
     * @return GetRawFileRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
     </table>
     * @deprecated
     */
    @Deprecated
    public FilesApi.GetRawFileRequestBuilder getRawFile(Integer fileId) throws IllegalArgumentException {
        if (fileId == null) throw new IllegalArgumentException("\"fileId\" is required but got null");
        return ((FilesApi) this).new GetRawFileRequestBuilder(fileId);
    }
    private okhttp3.Call modifyColdStorageParametersCall(ModifyColdStorageParametersQueryInput modifyColdStorageParametersQueryInput, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = modifyColdStorageParametersQueryInput;

        // create path and map variables
        String localVarPath = "/modify_cold_storage_parameters";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "accessToken", "apiKey", "customerId" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call modifyColdStorageParametersValidateBeforeCall(ModifyColdStorageParametersQueryInput modifyColdStorageParametersQueryInput, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'modifyColdStorageParametersQueryInput' is set
        if (modifyColdStorageParametersQueryInput == null) {
            throw new ApiException("Missing the required parameter 'modifyColdStorageParametersQueryInput' when calling modifyColdStorageParameters(Async)");
        }

        return modifyColdStorageParametersCall(modifyColdStorageParametersQueryInput, _callback);

    }


    private ApiResponse<Boolean> modifyColdStorageParametersWithHttpInfo(ModifyColdStorageParametersQueryInput modifyColdStorageParametersQueryInput) throws ApiException {
        okhttp3.Call localVarCall = modifyColdStorageParametersValidateBeforeCall(modifyColdStorageParametersQueryInput, null);
        Type localVarReturnType = new TypeToken<Boolean>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call modifyColdStorageParametersAsync(ModifyColdStorageParametersQueryInput modifyColdStorageParametersQueryInput, final ApiCallback<Boolean> _callback) throws ApiException {

        okhttp3.Call localVarCall = modifyColdStorageParametersValidateBeforeCall(modifyColdStorageParametersQueryInput, _callback);
        Type localVarReturnType = new TypeToken<Boolean>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public abstract class ModifyColdStorageParametersRequestBuilderGenerated {
        OrganizationUserFilesToSyncFilters filters;
        Boolean enableColdStorage;
        Integer hotStorageTimeToLive;

        public ModifyColdStorageParametersRequestBuilderGenerated() {
        }

        /**
         * Set filters
         * @param filters  (optional)
         * @return FilesApi.ModifyColdStorageParametersRequestBuilder
         */
        public FilesApi.ModifyColdStorageParametersRequestBuilder filters(OrganizationUserFilesToSyncFilters filters) {
            this.filters = filters;
            return (FilesApi.ModifyColdStorageParametersRequestBuilder) this;
        }
        
        /**
         * Set enableColdStorage
         * @param enableColdStorage  (optional)
         * @return FilesApi.ModifyColdStorageParametersRequestBuilder
         */
        public FilesApi.ModifyColdStorageParametersRequestBuilder enableColdStorage(Boolean enableColdStorage) {
            this.enableColdStorage = enableColdStorage;
            return (FilesApi.ModifyColdStorageParametersRequestBuilder) this;
        }
        
        /**
         * Set hotStorageTimeToLive
         * @param hotStorageTimeToLive  (optional)
         * @return FilesApi.ModifyColdStorageParametersRequestBuilder
         */
        public FilesApi.ModifyColdStorageParametersRequestBuilder hotStorageTimeToLive(Integer hotStorageTimeToLive) {
            this.hotStorageTimeToLive = hotStorageTimeToLive;
            return (FilesApi.ModifyColdStorageParametersRequestBuilder) this;
        }
        
        /**
         * Build call for modifyColdStorageParameters
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            ModifyColdStorageParametersQueryInput modifyColdStorageParametersQueryInput = buildBodyParams();
            return modifyColdStorageParametersCall(modifyColdStorageParametersQueryInput, _callback);
        }

        private ModifyColdStorageParametersQueryInput buildBodyParams() {
            ModifyColdStorageParametersQueryInput modifyColdStorageParametersQueryInput = new ModifyColdStorageParametersQueryInput();
            modifyColdStorageParametersQueryInput.filters(this.filters);
            modifyColdStorageParametersQueryInput.enableColdStorage(this.enableColdStorage);
            modifyColdStorageParametersQueryInput.hotStorageTimeToLive(this.hotStorageTimeToLive);
            return modifyColdStorageParametersQueryInput;
        }

        /**
         * Execute modifyColdStorageParameters request
         * @return Boolean
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public Boolean execute() throws ApiException {
            ModifyColdStorageParametersQueryInput modifyColdStorageParametersQueryInput = buildBodyParams();
            ApiResponse<Boolean> localVarResp = modifyColdStorageParametersWithHttpInfo(modifyColdStorageParametersQueryInput);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute modifyColdStorageParameters request with HTTP info returned
         * @return ApiResponse&lt;Boolean&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Boolean> executeWithHttpInfo() throws ApiException {
            ModifyColdStorageParametersQueryInput modifyColdStorageParametersQueryInput = buildBodyParams();
            return modifyColdStorageParametersWithHttpInfo(modifyColdStorageParametersQueryInput);
        }

        /**
         * Execute modifyColdStorageParameters request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Boolean> _callback) throws ApiException {
            ModifyColdStorageParametersQueryInput modifyColdStorageParametersQueryInput = buildBodyParams();
            return modifyColdStorageParametersAsync(modifyColdStorageParametersQueryInput, _callback);
        }
    }

    /**
     * Modify Cold Storage Parameters
     * 
     * @param modifyColdStorageParametersQueryInput  (required)
     * @return ModifyColdStorageParametersRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
     </table>
     */
    public FilesApi.ModifyColdStorageParametersRequestBuilder modifyColdStorageParameters() throws IllegalArgumentException {
        return ((FilesApi) this).new ModifyColdStorageParametersRequestBuilder();
    }
    private okhttp3.Call moveToHotStorageCall(MoveToHotStorageQueryInput moveToHotStorageQueryInput, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = moveToHotStorageQueryInput;

        // create path and map variables
        String localVarPath = "/move_to_hot_storage";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "accessToken", "apiKey", "customerId" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call moveToHotStorageValidateBeforeCall(MoveToHotStorageQueryInput moveToHotStorageQueryInput, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'moveToHotStorageQueryInput' is set
        if (moveToHotStorageQueryInput == null) {
            throw new ApiException("Missing the required parameter 'moveToHotStorageQueryInput' when calling moveToHotStorage(Async)");
        }

        return moveToHotStorageCall(moveToHotStorageQueryInput, _callback);

    }


    private ApiResponse<Boolean> moveToHotStorageWithHttpInfo(MoveToHotStorageQueryInput moveToHotStorageQueryInput) throws ApiException {
        okhttp3.Call localVarCall = moveToHotStorageValidateBeforeCall(moveToHotStorageQueryInput, null);
        Type localVarReturnType = new TypeToken<Boolean>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call moveToHotStorageAsync(MoveToHotStorageQueryInput moveToHotStorageQueryInput, final ApiCallback<Boolean> _callback) throws ApiException {

        okhttp3.Call localVarCall = moveToHotStorageValidateBeforeCall(moveToHotStorageQueryInput, _callback);
        Type localVarReturnType = new TypeToken<Boolean>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public abstract class MoveToHotStorageRequestBuilderGenerated {
        OrganizationUserFilesToSyncFilters filters;

        public MoveToHotStorageRequestBuilderGenerated() {
        }

        /**
         * Set filters
         * @param filters  (optional)
         * @return FilesApi.MoveToHotStorageRequestBuilder
         */
        public FilesApi.MoveToHotStorageRequestBuilder filters(OrganizationUserFilesToSyncFilters filters) {
            this.filters = filters;
            return (FilesApi.MoveToHotStorageRequestBuilder) this;
        }
        
        /**
         * Build call for moveToHotStorage
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            MoveToHotStorageQueryInput moveToHotStorageQueryInput = buildBodyParams();
            return moveToHotStorageCall(moveToHotStorageQueryInput, _callback);
        }

        private MoveToHotStorageQueryInput buildBodyParams() {
            MoveToHotStorageQueryInput moveToHotStorageQueryInput = new MoveToHotStorageQueryInput();
            moveToHotStorageQueryInput.filters(this.filters);
            return moveToHotStorageQueryInput;
        }

        /**
         * Execute moveToHotStorage request
         * @return Boolean
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public Boolean execute() throws ApiException {
            MoveToHotStorageQueryInput moveToHotStorageQueryInput = buildBodyParams();
            ApiResponse<Boolean> localVarResp = moveToHotStorageWithHttpInfo(moveToHotStorageQueryInput);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute moveToHotStorage request with HTTP info returned
         * @return ApiResponse&lt;Boolean&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Boolean> executeWithHttpInfo() throws ApiException {
            MoveToHotStorageQueryInput moveToHotStorageQueryInput = buildBodyParams();
            return moveToHotStorageWithHttpInfo(moveToHotStorageQueryInput);
        }

        /**
         * Execute moveToHotStorage request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Boolean> _callback) throws ApiException {
            MoveToHotStorageQueryInput moveToHotStorageQueryInput = buildBodyParams();
            return moveToHotStorageAsync(moveToHotStorageQueryInput, _callback);
        }
    }

    /**
     * Move To Hot Storage
     * 
     * @param moveToHotStorageQueryInput  (required)
     * @return MoveToHotStorageRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
     </table>
     */
    public FilesApi.MoveToHotStorageRequestBuilder moveToHotStorage() throws IllegalArgumentException {
        return ((FilesApi) this).new MoveToHotStorageRequestBuilder();
    }
    private okhttp3.Call queryUserFilesCall(OrganizationUserFilesToSyncQueryInput organizationUserFilesToSyncQueryInput, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = organizationUserFilesToSyncQueryInput;

        // create path and map variables
        String localVarPath = "/user_files_v2";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "accessToken", "apiKey", "customerId" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call queryUserFilesValidateBeforeCall(OrganizationUserFilesToSyncQueryInput organizationUserFilesToSyncQueryInput, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'organizationUserFilesToSyncQueryInput' is set
        if (organizationUserFilesToSyncQueryInput == null) {
            throw new ApiException("Missing the required parameter 'organizationUserFilesToSyncQueryInput' when calling queryUserFiles(Async)");
        }

        return queryUserFilesCall(organizationUserFilesToSyncQueryInput, _callback);

    }


    private ApiResponse<UserFilesV2> queryUserFilesWithHttpInfo(OrganizationUserFilesToSyncQueryInput organizationUserFilesToSyncQueryInput) throws ApiException {
        okhttp3.Call localVarCall = queryUserFilesValidateBeforeCall(organizationUserFilesToSyncQueryInput, null);
        Type localVarReturnType = new TypeToken<UserFilesV2>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call queryUserFilesAsync(OrganizationUserFilesToSyncQueryInput organizationUserFilesToSyncQueryInput, final ApiCallback<UserFilesV2> _callback) throws ApiException {

        okhttp3.Call localVarCall = queryUserFilesValidateBeforeCall(organizationUserFilesToSyncQueryInput, _callback);
        Type localVarReturnType = new TypeToken<UserFilesV2>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public abstract class QueryUserFilesRequestBuilderGenerated {
        Pagination pagination;
        OrganizationUserFilesToSyncOrderByTypes orderBy;
        OrderDir orderDir;
        OrganizationUserFilesToSyncFilters filters;
        Boolean includeRawFile;
        Boolean includeParsedTextFile;
        Boolean includeAdditionalFiles;
        Integer presignedUrlExpiryTimeSeconds;

        public QueryUserFilesRequestBuilderGenerated() {
        }

        /**
         * Set pagination
         * @param pagination  (optional)
         * @return FilesApi.QueryUserFilesRequestBuilder
         */
        public FilesApi.QueryUserFilesRequestBuilder pagination(Pagination pagination) {
            this.pagination = pagination;
            return (FilesApi.QueryUserFilesRequestBuilder) this;
        }
        
        /**
         * Set orderBy
         * @param orderBy  (optional)
         * @return FilesApi.QueryUserFilesRequestBuilder
         */
        public FilesApi.QueryUserFilesRequestBuilder orderBy(OrganizationUserFilesToSyncOrderByTypes orderBy) {
            this.orderBy = orderBy;
            return (FilesApi.QueryUserFilesRequestBuilder) this;
        }
        
        /**
         * Set orderDir
         * @param orderDir  (optional)
         * @return FilesApi.QueryUserFilesRequestBuilder
         */
        public FilesApi.QueryUserFilesRequestBuilder orderDir(OrderDir orderDir) {
            this.orderDir = orderDir;
            return (FilesApi.QueryUserFilesRequestBuilder) this;
        }
        
        /**
         * Set filters
         * @param filters  (optional)
         * @return FilesApi.QueryUserFilesRequestBuilder
         */
        public FilesApi.QueryUserFilesRequestBuilder filters(OrganizationUserFilesToSyncFilters filters) {
            this.filters = filters;
            return (FilesApi.QueryUserFilesRequestBuilder) this;
        }
        
        /**
         * Set includeRawFile
         * @param includeRawFile If true, the query will return presigned URLs for the raw file. Only relevant for the /user_files_v2 endpoint. (optional)
         * @return FilesApi.QueryUserFilesRequestBuilder
         */
        public FilesApi.QueryUserFilesRequestBuilder includeRawFile(Boolean includeRawFile) {
            this.includeRawFile = includeRawFile;
            return (FilesApi.QueryUserFilesRequestBuilder) this;
        }
        
        /**
         * Set includeParsedTextFile
         * @param includeParsedTextFile If true, the query will return presigned URLs for the parsed text file. Only relevant for the /user_files_v2 endpoint. (optional)
         * @return FilesApi.QueryUserFilesRequestBuilder
         */
        public FilesApi.QueryUserFilesRequestBuilder includeParsedTextFile(Boolean includeParsedTextFile) {
            this.includeParsedTextFile = includeParsedTextFile;
            return (FilesApi.QueryUserFilesRequestBuilder) this;
        }
        
        /**
         * Set includeAdditionalFiles
         * @param includeAdditionalFiles If true, the query will return presigned URLs for additional files. Only relevant for the /user_files_v2 endpoint. (optional)
         * @return FilesApi.QueryUserFilesRequestBuilder
         */
        public FilesApi.QueryUserFilesRequestBuilder includeAdditionalFiles(Boolean includeAdditionalFiles) {
            this.includeAdditionalFiles = includeAdditionalFiles;
            return (FilesApi.QueryUserFilesRequestBuilder) this;
        }
        
        /**
         * Set presignedUrlExpiryTimeSeconds
         * @param presignedUrlExpiryTimeSeconds The expiry time for the presigned URLs. Only relevant for the /user_files_v2 endpoint. (optional, default to 3600)
         * @return FilesApi.QueryUserFilesRequestBuilder
         */
        public FilesApi.QueryUserFilesRequestBuilder presignedUrlExpiryTimeSeconds(Integer presignedUrlExpiryTimeSeconds) {
            this.presignedUrlExpiryTimeSeconds = presignedUrlExpiryTimeSeconds;
            return (FilesApi.QueryUserFilesRequestBuilder) this;
        }
        
        /**
         * Build call for queryUserFiles
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            OrganizationUserFilesToSyncQueryInput organizationUserFilesToSyncQueryInput = buildBodyParams();
            return queryUserFilesCall(organizationUserFilesToSyncQueryInput, _callback);
        }

        private OrganizationUserFilesToSyncQueryInput buildBodyParams() {
            OrganizationUserFilesToSyncQueryInput organizationUserFilesToSyncQueryInput = new OrganizationUserFilesToSyncQueryInput();
            organizationUserFilesToSyncQueryInput.pagination(this.pagination);
            organizationUserFilesToSyncQueryInput.orderBy(this.orderBy);
            organizationUserFilesToSyncQueryInput.orderDir(this.orderDir);
            organizationUserFilesToSyncQueryInput.filters(this.filters);
            organizationUserFilesToSyncQueryInput.includeRawFile(this.includeRawFile);
            organizationUserFilesToSyncQueryInput.includeParsedTextFile(this.includeParsedTextFile);
            organizationUserFilesToSyncQueryInput.includeAdditionalFiles(this.includeAdditionalFiles);
            organizationUserFilesToSyncQueryInput.presignedUrlExpiryTimeSeconds(this.presignedUrlExpiryTimeSeconds);
            return organizationUserFilesToSyncQueryInput;
        }

        /**
         * Execute queryUserFiles request
         * @return UserFilesV2
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public UserFilesV2 execute() throws ApiException {
            OrganizationUserFilesToSyncQueryInput organizationUserFilesToSyncQueryInput = buildBodyParams();
            ApiResponse<UserFilesV2> localVarResp = queryUserFilesWithHttpInfo(organizationUserFilesToSyncQueryInput);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute queryUserFiles request with HTTP info returned
         * @return ApiResponse&lt;UserFilesV2&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<UserFilesV2> executeWithHttpInfo() throws ApiException {
            OrganizationUserFilesToSyncQueryInput organizationUserFilesToSyncQueryInput = buildBodyParams();
            return queryUserFilesWithHttpInfo(organizationUserFilesToSyncQueryInput);
        }

        /**
         * Execute queryUserFiles request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<UserFilesV2> _callback) throws ApiException {
            OrganizationUserFilesToSyncQueryInput organizationUserFilesToSyncQueryInput = buildBodyParams();
            return queryUserFilesAsync(organizationUserFilesToSyncQueryInput, _callback);
        }
    }

    /**
     * User Files V2
     * For pre-filtering documents, using &#x60;tags_v2&#x60; is preferred to using &#x60;tags&#x60; (which is now deprecated). If both &#x60;tags_v2&#x60; and &#x60;tags&#x60; are specified, &#x60;tags&#x60; is ignored. &#x60;tags_v2&#x60; enables building complex filters through the use of \&quot;AND\&quot;, \&quot;OR\&quot;, and negation logic. Take the below input as an example: &#x60;&#x60;&#x60;json {     \&quot;OR\&quot;: [         {             \&quot;key\&quot;: \&quot;subject\&quot;,             \&quot;value\&quot;: \&quot;holy-bible\&quot;,             \&quot;negate\&quot;: false         },         {             \&quot;key\&quot;: \&quot;person-of-interest\&quot;,             \&quot;value\&quot;: \&quot;jesus christ\&quot;,             \&quot;negate\&quot;: false         },         {             \&quot;key\&quot;: \&quot;genre\&quot;,             \&quot;value\&quot;: \&quot;religion\&quot;,             \&quot;negate\&quot;: true         }         {             \&quot;AND\&quot;: [                 {                     \&quot;key\&quot;: \&quot;subject\&quot;,                     \&quot;value\&quot;: \&quot;tao-te-ching\&quot;,                     \&quot;negate\&quot;: false                 },                 {                     \&quot;key\&quot;: \&quot;author\&quot;,                     \&quot;value\&quot;: \&quot;lao-tzu\&quot;,                     \&quot;negate\&quot;: false                 }             ]         }     ] } &#x60;&#x60;&#x60; In this case, files will be filtered such that: 1. \&quot;subject\&quot; &#x3D; \&quot;holy-bible\&quot; OR 2. \&quot;person-of-interest\&quot; &#x3D; \&quot;jesus christ\&quot; OR 3. \&quot;genre\&quot; !&#x3D; \&quot;religion\&quot; OR 4. \&quot;subject\&quot; &#x3D; \&quot;tao-te-ching\&quot; AND \&quot;author\&quot; &#x3D; \&quot;lao-tzu\&quot;  Note that the top level of the query must be either an \&quot;OR\&quot; or \&quot;AND\&quot; array. Currently, nesting is limited to 3. For tag blocks (those with \&quot;key\&quot;, \&quot;value\&quot;, and \&quot;negate\&quot; keys), the following typing rules apply: 1. \&quot;key\&quot; isn&#39;t optional and must be a &#x60;string&#x60; 2. \&quot;value\&quot; isn&#39;t optional and can be &#x60;any&#x60; or list[&#x60;any&#x60;] 3. \&quot;negate\&quot; is optional and must be &#x60;true&#x60; or &#x60;false&#x60;. If present and &#x60;true&#x60;, then the filter block is negated in the resulting query. It is &#x60;false&#x60; by default.
     * @param organizationUserFilesToSyncQueryInput  (required)
     * @return QueryUserFilesRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
     </table>
     */
    public FilesApi.QueryUserFilesRequestBuilder queryUserFiles() throws IllegalArgumentException {
        return ((FilesApi) this).new QueryUserFilesRequestBuilder();
    }
    private okhttp3.Call queryUserFilesDeprecatedCall(OrganizationUserFilesToSyncQueryInput organizationUserFilesToSyncQueryInput, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = organizationUserFilesToSyncQueryInput;

        // create path and map variables
        String localVarPath = "/user_files";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "accessToken", "apiKey", "customerId" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @Deprecated
    @SuppressWarnings("rawtypes")
    private okhttp3.Call queryUserFilesDeprecatedValidateBeforeCall(OrganizationUserFilesToSyncQueryInput organizationUserFilesToSyncQueryInput, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'organizationUserFilesToSyncQueryInput' is set
        if (organizationUserFilesToSyncQueryInput == null) {
            throw new ApiException("Missing the required parameter 'organizationUserFilesToSyncQueryInput' when calling queryUserFilesDeprecated(Async)");
        }

        return queryUserFilesDeprecatedCall(organizationUserFilesToSyncQueryInput, _callback);

    }


    private ApiResponse<List<UserFile>> queryUserFilesDeprecatedWithHttpInfo(OrganizationUserFilesToSyncQueryInput organizationUserFilesToSyncQueryInput) throws ApiException {
        okhttp3.Call localVarCall = queryUserFilesDeprecatedValidateBeforeCall(organizationUserFilesToSyncQueryInput, null);
        Type localVarReturnType = new TypeToken<List<UserFile>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call queryUserFilesDeprecatedAsync(OrganizationUserFilesToSyncQueryInput organizationUserFilesToSyncQueryInput, final ApiCallback<List<UserFile>> _callback) throws ApiException {

        okhttp3.Call localVarCall = queryUserFilesDeprecatedValidateBeforeCall(organizationUserFilesToSyncQueryInput, _callback);
        Type localVarReturnType = new TypeToken<List<UserFile>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public abstract class QueryUserFilesDeprecatedRequestBuilderGenerated {
        Pagination pagination;
        OrganizationUserFilesToSyncOrderByTypes orderBy;
        OrderDir orderDir;
        OrganizationUserFilesToSyncFilters filters;
        Boolean includeRawFile;
        Boolean includeParsedTextFile;
        Boolean includeAdditionalFiles;
        Integer presignedUrlExpiryTimeSeconds;

        public QueryUserFilesDeprecatedRequestBuilderGenerated() {
        }

        /**
         * Set pagination
         * @param pagination  (optional)
         * @return FilesApi.QueryUserFilesDeprecatedRequestBuilder
         */
        public FilesApi.QueryUserFilesDeprecatedRequestBuilder pagination(Pagination pagination) {
            this.pagination = pagination;
            return (FilesApi.QueryUserFilesDeprecatedRequestBuilder) this;
        }
        
        /**
         * Set orderBy
         * @param orderBy  (optional)
         * @return FilesApi.QueryUserFilesDeprecatedRequestBuilder
         */
        public FilesApi.QueryUserFilesDeprecatedRequestBuilder orderBy(OrganizationUserFilesToSyncOrderByTypes orderBy) {
            this.orderBy = orderBy;
            return (FilesApi.QueryUserFilesDeprecatedRequestBuilder) this;
        }
        
        /**
         * Set orderDir
         * @param orderDir  (optional)
         * @return FilesApi.QueryUserFilesDeprecatedRequestBuilder
         */
        public FilesApi.QueryUserFilesDeprecatedRequestBuilder orderDir(OrderDir orderDir) {
            this.orderDir = orderDir;
            return (FilesApi.QueryUserFilesDeprecatedRequestBuilder) this;
        }
        
        /**
         * Set filters
         * @param filters  (optional)
         * @return FilesApi.QueryUserFilesDeprecatedRequestBuilder
         */
        public FilesApi.QueryUserFilesDeprecatedRequestBuilder filters(OrganizationUserFilesToSyncFilters filters) {
            this.filters = filters;
            return (FilesApi.QueryUserFilesDeprecatedRequestBuilder) this;
        }
        
        /**
         * Set includeRawFile
         * @param includeRawFile If true, the query will return presigned URLs for the raw file. Only relevant for the /user_files_v2 endpoint. (optional)
         * @return FilesApi.QueryUserFilesDeprecatedRequestBuilder
         */
        public FilesApi.QueryUserFilesDeprecatedRequestBuilder includeRawFile(Boolean includeRawFile) {
            this.includeRawFile = includeRawFile;
            return (FilesApi.QueryUserFilesDeprecatedRequestBuilder) this;
        }
        
        /**
         * Set includeParsedTextFile
         * @param includeParsedTextFile If true, the query will return presigned URLs for the parsed text file. Only relevant for the /user_files_v2 endpoint. (optional)
         * @return FilesApi.QueryUserFilesDeprecatedRequestBuilder
         */
        public FilesApi.QueryUserFilesDeprecatedRequestBuilder includeParsedTextFile(Boolean includeParsedTextFile) {
            this.includeParsedTextFile = includeParsedTextFile;
            return (FilesApi.QueryUserFilesDeprecatedRequestBuilder) this;
        }
        
        /**
         * Set includeAdditionalFiles
         * @param includeAdditionalFiles If true, the query will return presigned URLs for additional files. Only relevant for the /user_files_v2 endpoint. (optional)
         * @return FilesApi.QueryUserFilesDeprecatedRequestBuilder
         */
        public FilesApi.QueryUserFilesDeprecatedRequestBuilder includeAdditionalFiles(Boolean includeAdditionalFiles) {
            this.includeAdditionalFiles = includeAdditionalFiles;
            return (FilesApi.QueryUserFilesDeprecatedRequestBuilder) this;
        }
        
        /**
         * Set presignedUrlExpiryTimeSeconds
         * @param presignedUrlExpiryTimeSeconds The expiry time for the presigned URLs. Only relevant for the /user_files_v2 endpoint. (optional, default to 3600)
         * @return FilesApi.QueryUserFilesDeprecatedRequestBuilder
         */
        public FilesApi.QueryUserFilesDeprecatedRequestBuilder presignedUrlExpiryTimeSeconds(Integer presignedUrlExpiryTimeSeconds) {
            this.presignedUrlExpiryTimeSeconds = presignedUrlExpiryTimeSeconds;
            return (FilesApi.QueryUserFilesDeprecatedRequestBuilder) this;
        }
        
        /**
         * Build call for queryUserFilesDeprecated
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         * @deprecated
         */
        @Deprecated
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            OrganizationUserFilesToSyncQueryInput organizationUserFilesToSyncQueryInput = buildBodyParams();
            return queryUserFilesDeprecatedCall(organizationUserFilesToSyncQueryInput, _callback);
        }

        private OrganizationUserFilesToSyncQueryInput buildBodyParams() {
            OrganizationUserFilesToSyncQueryInput organizationUserFilesToSyncQueryInput = new OrganizationUserFilesToSyncQueryInput();
            organizationUserFilesToSyncQueryInput.pagination(this.pagination);
            organizationUserFilesToSyncQueryInput.orderBy(this.orderBy);
            organizationUserFilesToSyncQueryInput.orderDir(this.orderDir);
            organizationUserFilesToSyncQueryInput.filters(this.filters);
            organizationUserFilesToSyncQueryInput.includeRawFile(this.includeRawFile);
            organizationUserFilesToSyncQueryInput.includeParsedTextFile(this.includeParsedTextFile);
            organizationUserFilesToSyncQueryInput.includeAdditionalFiles(this.includeAdditionalFiles);
            organizationUserFilesToSyncQueryInput.presignedUrlExpiryTimeSeconds(this.presignedUrlExpiryTimeSeconds);
            return organizationUserFilesToSyncQueryInput;
        }

        /**
         * Execute queryUserFilesDeprecated request
         * @return List&lt;UserFile&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         * @deprecated
         */
        @Deprecated
        public List<UserFile> execute() throws ApiException {
            OrganizationUserFilesToSyncQueryInput organizationUserFilesToSyncQueryInput = buildBodyParams();
            ApiResponse<List<UserFile>> localVarResp = queryUserFilesDeprecatedWithHttpInfo(organizationUserFilesToSyncQueryInput);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute queryUserFilesDeprecated request with HTTP info returned
         * @return ApiResponse&lt;List&lt;UserFile&gt;&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         * @deprecated
         */
        @Deprecated
        public ApiResponse<List<UserFile>> executeWithHttpInfo() throws ApiException {
            OrganizationUserFilesToSyncQueryInput organizationUserFilesToSyncQueryInput = buildBodyParams();
            return queryUserFilesDeprecatedWithHttpInfo(organizationUserFilesToSyncQueryInput);
        }

        /**
         * Execute queryUserFilesDeprecated request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         * @deprecated
         */
        @Deprecated
        public okhttp3.Call executeAsync(final ApiCallback<List<UserFile>> _callback) throws ApiException {
            OrganizationUserFilesToSyncQueryInput organizationUserFilesToSyncQueryInput = buildBodyParams();
            return queryUserFilesDeprecatedAsync(organizationUserFilesToSyncQueryInput, _callback);
        }
    }

    /**
     * User Files
     * This route is deprecated. Use &#x60;/user_files_v2&#x60; instead.
     * @param organizationUserFilesToSyncQueryInput  (required)
     * @return QueryUserFilesDeprecatedRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
     </table>
     * @deprecated
     */
    @Deprecated
    public FilesApi.QueryUserFilesDeprecatedRequestBuilder queryUserFilesDeprecated() throws IllegalArgumentException {
        return ((FilesApi) this).new QueryUserFilesDeprecatedRequestBuilder();
    }
    private okhttp3.Call resyncCall(ResyncFileQueryInput resyncFileQueryInput, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = resyncFileQueryInput;

        // create path and map variables
        String localVarPath = "/resync_file";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "accessToken", "apiKey", "customerId" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call resyncValidateBeforeCall(ResyncFileQueryInput resyncFileQueryInput, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'resyncFileQueryInput' is set
        if (resyncFileQueryInput == null) {
            throw new ApiException("Missing the required parameter 'resyncFileQueryInput' when calling resync(Async)");
        }

        return resyncCall(resyncFileQueryInput, _callback);

    }


    private ApiResponse<UserFile> resyncWithHttpInfo(ResyncFileQueryInput resyncFileQueryInput) throws ApiException {
        okhttp3.Call localVarCall = resyncValidateBeforeCall(resyncFileQueryInput, null);
        Type localVarReturnType = new TypeToken<UserFile>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call resyncAsync(ResyncFileQueryInput resyncFileQueryInput, final ApiCallback<UserFile> _callback) throws ApiException {

        okhttp3.Call localVarCall = resyncValidateBeforeCall(resyncFileQueryInput, _callback);
        Type localVarReturnType = new TypeToken<UserFile>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public abstract class ResyncRequestBuilderGenerated {
        final Integer fileId;
        Integer chunkSize;
        Integer chunkOverlap;
        Boolean forceEmbeddingGeneration;
        Boolean skipFileProcessing;

        public ResyncRequestBuilderGenerated(Integer fileId) {
            this.fileId = fileId;
        }

        /**
         * Set chunkSize
         * @param chunkSize  (optional)
         * @return FilesApi.ResyncRequestBuilder
         */
        public FilesApi.ResyncRequestBuilder chunkSize(Integer chunkSize) {
            this.chunkSize = chunkSize;
            return (FilesApi.ResyncRequestBuilder) this;
        }
        
        /**
         * Set chunkOverlap
         * @param chunkOverlap  (optional)
         * @return FilesApi.ResyncRequestBuilder
         */
        public FilesApi.ResyncRequestBuilder chunkOverlap(Integer chunkOverlap) {
            this.chunkOverlap = chunkOverlap;
            return (FilesApi.ResyncRequestBuilder) this;
        }
        
        /**
         * Set forceEmbeddingGeneration
         * @param forceEmbeddingGeneration  (optional, default to false)
         * @return FilesApi.ResyncRequestBuilder
         */
        public FilesApi.ResyncRequestBuilder forceEmbeddingGeneration(Boolean forceEmbeddingGeneration) {
            this.forceEmbeddingGeneration = forceEmbeddingGeneration;
            return (FilesApi.ResyncRequestBuilder) this;
        }
        
        /**
         * Set skipFileProcessing
         * @param skipFileProcessing  (optional, default to false)
         * @return FilesApi.ResyncRequestBuilder
         */
        public FilesApi.ResyncRequestBuilder skipFileProcessing(Boolean skipFileProcessing) {
            this.skipFileProcessing = skipFileProcessing;
            return (FilesApi.ResyncRequestBuilder) this;
        }
        
        /**
         * Build call for resync
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            ResyncFileQueryInput resyncFileQueryInput = buildBodyParams();
            return resyncCall(resyncFileQueryInput, _callback);
        }

        private ResyncFileQueryInput buildBodyParams() {
            ResyncFileQueryInput resyncFileQueryInput = new ResyncFileQueryInput();
            resyncFileQueryInput.fileId(this.fileId);
            resyncFileQueryInput.chunkSize(this.chunkSize);
            resyncFileQueryInput.chunkOverlap(this.chunkOverlap);
            resyncFileQueryInput.forceEmbeddingGeneration(this.forceEmbeddingGeneration);
            resyncFileQueryInput.skipFileProcessing(this.skipFileProcessing);
            return resyncFileQueryInput;
        }

        /**
         * Execute resync request
         * @return UserFile
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public UserFile execute() throws ApiException {
            ResyncFileQueryInput resyncFileQueryInput = buildBodyParams();
            ApiResponse<UserFile> localVarResp = resyncWithHttpInfo(resyncFileQueryInput);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute resync request with HTTP info returned
         * @return ApiResponse&lt;UserFile&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<UserFile> executeWithHttpInfo() throws ApiException {
            ResyncFileQueryInput resyncFileQueryInput = buildBodyParams();
            return resyncWithHttpInfo(resyncFileQueryInput);
        }

        /**
         * Execute resync request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<UserFile> _callback) throws ApiException {
            ResyncFileQueryInput resyncFileQueryInput = buildBodyParams();
            return resyncAsync(resyncFileQueryInput, _callback);
        }
    }

    /**
     * Resync File
     * 
     * @param resyncFileQueryInput  (required)
     * @return ResyncRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
     </table>
     */
    public FilesApi.ResyncRequestBuilder resync(Integer fileId) throws IllegalArgumentException {
        if (fileId == null) throw new IllegalArgumentException("\"fileId\" is required but got null");
        return ((FilesApi) this).new ResyncRequestBuilder(fileId);
    }
    private okhttp3.Call uploadCall(File _file, BodyCreateUploadFileUploadfilePost bodyCreateUploadFileUploadfilePost, Integer chunkSize, Integer chunkOverlap, Boolean skipEmbeddingGeneration, Boolean setPageAsBoundary, TMEmbeddingGenerators embeddingModel, Boolean useOcr, Boolean generateSparseVectors, Boolean prependFilenameToChunks, Integer maxItemsPerChunk, Boolean parsePdfTablesWithOcr, Boolean detectAudioLanguage, TranscriptionServiceNullable transcriptionService, Boolean includeSpeakerLabels, FileContentTypesNullable mediaType, Boolean splitRows, Boolean enableColdStorage, Integer hotStorageTimeToLive, Boolean generateChunksOnly, Boolean storeFileOnly, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = bodyCreateUploadFileUploadfilePost;

        // create path and map variables
        String localVarPath = "/uploadfile";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (_file != null) {
            localVarFormParams.put("file", _file);
        }

        if (chunkSize != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("chunk_size", chunkSize));
        }

        if (chunkOverlap != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("chunk_overlap", chunkOverlap));
        }

        if (skipEmbeddingGeneration != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("skip_embedding_generation", skipEmbeddingGeneration));
        }

        if (setPageAsBoundary != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("set_page_as_boundary", setPageAsBoundary));
        }

        if (embeddingModel != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("embedding_model", embeddingModel));
        }

        if (useOcr != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("use_ocr", useOcr));
        }

        if (generateSparseVectors != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("generate_sparse_vectors", generateSparseVectors));
        }

        if (prependFilenameToChunks != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("prepend_filename_to_chunks", prependFilenameToChunks));
        }

        if (maxItemsPerChunk != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("max_items_per_chunk", maxItemsPerChunk));
        }

        if (parsePdfTablesWithOcr != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("parse_pdf_tables_with_ocr", parsePdfTablesWithOcr));
        }

        if (detectAudioLanguage != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("detect_audio_language", detectAudioLanguage));
        }

        if (transcriptionService != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("transcription_service", transcriptionService));
        }

        if (includeSpeakerLabels != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("include_speaker_labels", includeSpeakerLabels));
        }

        if (mediaType != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("media_type", mediaType));
        }

        if (splitRows != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("split_rows", splitRows));
        }

        if (enableColdStorage != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("enable_cold_storage", enableColdStorage));
        }

        if (hotStorageTimeToLive != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("hot_storage_time_to_live", hotStorageTimeToLive));
        }

        if (generateChunksOnly != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("generate_chunks_only", generateChunksOnly));
        }

        if (storeFileOnly != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("store_file_only", storeFileOnly));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "multipart/form-data"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "accessToken", "apiKey", "customerId" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call uploadValidateBeforeCall(File _file, BodyCreateUploadFileUploadfilePost bodyCreateUploadFileUploadfilePost, Integer chunkSize, Integer chunkOverlap, Boolean skipEmbeddingGeneration, Boolean setPageAsBoundary, TMEmbeddingGenerators embeddingModel, Boolean useOcr, Boolean generateSparseVectors, Boolean prependFilenameToChunks, Integer maxItemsPerChunk, Boolean parsePdfTablesWithOcr, Boolean detectAudioLanguage, TranscriptionServiceNullable transcriptionService, Boolean includeSpeakerLabels, FileContentTypesNullable mediaType, Boolean splitRows, Boolean enableColdStorage, Integer hotStorageTimeToLive, Boolean generateChunksOnly, Boolean storeFileOnly, final ApiCallback _callback) throws ApiException {
        // verify the required parameter '_file' is set
        if (_file == null) {
            throw new ApiException("Missing the required parameter '_file' when calling upload(Async)");
        }

        // verify the required parameter 'bodyCreateUploadFileUploadfilePost' is set
        if (bodyCreateUploadFileUploadfilePost == null) {
            throw new ApiException("Missing the required parameter 'bodyCreateUploadFileUploadfilePost' when calling upload(Async)");
        }

        return uploadCall(_file, bodyCreateUploadFileUploadfilePost, chunkSize, chunkOverlap, skipEmbeddingGeneration, setPageAsBoundary, embeddingModel, useOcr, generateSparseVectors, prependFilenameToChunks, maxItemsPerChunk, parsePdfTablesWithOcr, detectAudioLanguage, transcriptionService, includeSpeakerLabels, mediaType, splitRows, enableColdStorage, hotStorageTimeToLive, generateChunksOnly, storeFileOnly, _callback);

    }


    private ApiResponse<UserFile> uploadWithHttpInfo(File _file, BodyCreateUploadFileUploadfilePost bodyCreateUploadFileUploadfilePost, Integer chunkSize, Integer chunkOverlap, Boolean skipEmbeddingGeneration, Boolean setPageAsBoundary, TMEmbeddingGenerators embeddingModel, Boolean useOcr, Boolean generateSparseVectors, Boolean prependFilenameToChunks, Integer maxItemsPerChunk, Boolean parsePdfTablesWithOcr, Boolean detectAudioLanguage, TranscriptionServiceNullable transcriptionService, Boolean includeSpeakerLabels, FileContentTypesNullable mediaType, Boolean splitRows, Boolean enableColdStorage, Integer hotStorageTimeToLive, Boolean generateChunksOnly, Boolean storeFileOnly) throws ApiException {
        okhttp3.Call localVarCall = uploadValidateBeforeCall(_file, bodyCreateUploadFileUploadfilePost, chunkSize, chunkOverlap, skipEmbeddingGeneration, setPageAsBoundary, embeddingModel, useOcr, generateSparseVectors, prependFilenameToChunks, maxItemsPerChunk, parsePdfTablesWithOcr, detectAudioLanguage, transcriptionService, includeSpeakerLabels, mediaType, splitRows, enableColdStorage, hotStorageTimeToLive, generateChunksOnly, storeFileOnly, null);
        Type localVarReturnType = new TypeToken<UserFile>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call uploadAsync(File _file, BodyCreateUploadFileUploadfilePost bodyCreateUploadFileUploadfilePost, Integer chunkSize, Integer chunkOverlap, Boolean skipEmbeddingGeneration, Boolean setPageAsBoundary, TMEmbeddingGenerators embeddingModel, Boolean useOcr, Boolean generateSparseVectors, Boolean prependFilenameToChunks, Integer maxItemsPerChunk, Boolean parsePdfTablesWithOcr, Boolean detectAudioLanguage, TranscriptionServiceNullable transcriptionService, Boolean includeSpeakerLabels, FileContentTypesNullable mediaType, Boolean splitRows, Boolean enableColdStorage, Integer hotStorageTimeToLive, Boolean generateChunksOnly, Boolean storeFileOnly, final ApiCallback<UserFile> _callback) throws ApiException {

        okhttp3.Call localVarCall = uploadValidateBeforeCall(_file, bodyCreateUploadFileUploadfilePost, chunkSize, chunkOverlap, skipEmbeddingGeneration, setPageAsBoundary, embeddingModel, useOcr, generateSparseVectors, prependFilenameToChunks, maxItemsPerChunk, parsePdfTablesWithOcr, detectAudioLanguage, transcriptionService, includeSpeakerLabels, mediaType, splitRows, enableColdStorage, hotStorageTimeToLive, generateChunksOnly, storeFileOnly, _callback);
        Type localVarReturnType = new TypeToken<UserFile>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public abstract class UploadRequestBuilderGenerated {
        final File _file;
        Integer chunkSize;
        Integer chunkOverlap;
        Boolean skipEmbeddingGeneration;
        Boolean setPageAsBoundary;
        TMEmbeddingGenerators embeddingModel;
        Boolean useOcr;
        Boolean generateSparseVectors;
        Boolean prependFilenameToChunks;
        Integer maxItemsPerChunk;
        Boolean parsePdfTablesWithOcr;
        Boolean detectAudioLanguage;
        TranscriptionServiceNullable transcriptionService;
        Boolean includeSpeakerLabels;
        FileContentTypesNullable mediaType;
        Boolean splitRows;
        Boolean enableColdStorage;
        Integer hotStorageTimeToLive;
        Boolean generateChunksOnly;
        Boolean storeFileOnly;

        public UploadRequestBuilderGenerated(File _file) {
            this._file = _file;
        }

        /**
         * Set chunkSize
         * @param chunkSize Chunk size in tiktoken tokens to be used when processing file. (optional)
         * @return FilesApi.UploadRequestBuilder
         */
        public FilesApi.UploadRequestBuilder chunkSize(Integer chunkSize) {
            this.chunkSize = chunkSize;
            return (FilesApi.UploadRequestBuilder) this;
        }
        
        /**
         * Set chunkOverlap
         * @param chunkOverlap Chunk overlap in tiktoken tokens to be used when processing file. (optional)
         * @return FilesApi.UploadRequestBuilder
         */
        public FilesApi.UploadRequestBuilder chunkOverlap(Integer chunkOverlap) {
            this.chunkOverlap = chunkOverlap;
            return (FilesApi.UploadRequestBuilder) this;
        }
        
        /**
         * Set skipEmbeddingGeneration
         * @param skipEmbeddingGeneration Flag to control whether or not embeddings should be generated and stored             when processing file. (optional, default to false)
         * @return FilesApi.UploadRequestBuilder
         */
        public FilesApi.UploadRequestBuilder skipEmbeddingGeneration(Boolean skipEmbeddingGeneration) {
            this.skipEmbeddingGeneration = skipEmbeddingGeneration;
            return (FilesApi.UploadRequestBuilder) this;
        }
        
        /**
         * Set setPageAsBoundary
         * @param setPageAsBoundary Flag to control whether or not to set the a page&#39;s worth of content as the maximum             amount of content that can appear in a chunk. Only valid for PDFs. See description route description for             more information. (optional, default to false)
         * @return FilesApi.UploadRequestBuilder
         */
        public FilesApi.UploadRequestBuilder setPageAsBoundary(Boolean setPageAsBoundary) {
            this.setPageAsBoundary = setPageAsBoundary;
            return (FilesApi.UploadRequestBuilder) this;
        }
        
        /**
         * Set embeddingModel
         * @param embeddingModel Embedding model that will be used to embed file chunks. (optional)
         * @return FilesApi.UploadRequestBuilder
         */
        public FilesApi.UploadRequestBuilder embeddingModel(TMEmbeddingGenerators embeddingModel) {
            this.embeddingModel = embeddingModel;
            return (FilesApi.UploadRequestBuilder) this;
        }
        
        /**
         * Set useOcr
         * @param useOcr Whether or not to use OCR when processing files. Valid for PDFs, JPEGs, and PNGs. Useful for documents with             tables, images, and/or scanned text. (optional, default to false)
         * @return FilesApi.UploadRequestBuilder
         */
        public FilesApi.UploadRequestBuilder useOcr(Boolean useOcr) {
            this.useOcr = useOcr;
            return (FilesApi.UploadRequestBuilder) this;
        }
        
        /**
         * Set generateSparseVectors
         * @param generateSparseVectors Whether or not to generate sparse vectors for the file. This is *required* for the file to be a             candidate for hybrid search. (optional, default to false)
         * @return FilesApi.UploadRequestBuilder
         */
        public FilesApi.UploadRequestBuilder generateSparseVectors(Boolean generateSparseVectors) {
            this.generateSparseVectors = generateSparseVectors;
            return (FilesApi.UploadRequestBuilder) this;
        }
        
        /**
         * Set prependFilenameToChunks
         * @param prependFilenameToChunks Whether or not to prepend the file&#39;s name to chunks. (optional, default to false)
         * @return FilesApi.UploadRequestBuilder
         */
        public FilesApi.UploadRequestBuilder prependFilenameToChunks(Boolean prependFilenameToChunks) {
            this.prependFilenameToChunks = prependFilenameToChunks;
            return (FilesApi.UploadRequestBuilder) this;
        }
        
        /**
         * Set maxItemsPerChunk
         * @param maxItemsPerChunk Number of objects per chunk. For csv, tsv, xlsx, and json files only. (optional)
         * @return FilesApi.UploadRequestBuilder
         */
        public FilesApi.UploadRequestBuilder maxItemsPerChunk(Integer maxItemsPerChunk) {
            this.maxItemsPerChunk = maxItemsPerChunk;
            return (FilesApi.UploadRequestBuilder) this;
        }
        
        /**
         * Set parsePdfTablesWithOcr
         * @param parsePdfTablesWithOcr Whether to use rich table parsing when &#x60;use_ocr&#x60; is enabled. (optional, default to false)
         * @return FilesApi.UploadRequestBuilder
         */
        public FilesApi.UploadRequestBuilder parsePdfTablesWithOcr(Boolean parsePdfTablesWithOcr) {
            this.parsePdfTablesWithOcr = parsePdfTablesWithOcr;
            return (FilesApi.UploadRequestBuilder) this;
        }
        
        /**
         * Set detectAudioLanguage
         * @param detectAudioLanguage Whether to automatically detect the language of the uploaded audio file. (optional, default to false)
         * @return FilesApi.UploadRequestBuilder
         */
        public FilesApi.UploadRequestBuilder detectAudioLanguage(Boolean detectAudioLanguage) {
            this.detectAudioLanguage = detectAudioLanguage;
            return (FilesApi.UploadRequestBuilder) this;
        }
        
        /**
         * Set transcriptionService
         * @param transcriptionService The transcription service to use for audio files. If no service is specified, &#39;deepgram&#39; will be used. (optional)
         * @return FilesApi.UploadRequestBuilder
         */
        public FilesApi.UploadRequestBuilder transcriptionService(TranscriptionServiceNullable transcriptionService) {
            this.transcriptionService = transcriptionService;
            return (FilesApi.UploadRequestBuilder) this;
        }
        
        /**
         * Set includeSpeakerLabels
         * @param includeSpeakerLabels Detect multiple speakers and label segments of speech by speaker for audio files. (optional, default to false)
         * @return FilesApi.UploadRequestBuilder
         */
        public FilesApi.UploadRequestBuilder includeSpeakerLabels(Boolean includeSpeakerLabels) {
            this.includeSpeakerLabels = includeSpeakerLabels;
            return (FilesApi.UploadRequestBuilder) this;
        }
        
        /**
         * Set mediaType
         * @param mediaType The media type of the file. If not provided, it will be inferred from the file extension. (optional)
         * @return FilesApi.UploadRequestBuilder
         */
        public FilesApi.UploadRequestBuilder mediaType(FileContentTypesNullable mediaType) {
            this.mediaType = mediaType;
            return (FilesApi.UploadRequestBuilder) this;
        }
        
        /**
         * Set splitRows
         * @param splitRows Whether to split tabular rows into chunks. Currently only valid for CSV, TSV, and XLSX files. (optional, default to false)
         * @return FilesApi.UploadRequestBuilder
         */
        public FilesApi.UploadRequestBuilder splitRows(Boolean splitRows) {
            this.splitRows = splitRows;
            return (FilesApi.UploadRequestBuilder) this;
        }
        
        /**
         * Set enableColdStorage
         * @param enableColdStorage Enable cold storage for the file. If set to true, the file will be moved to cold storage after a certain period of inactivity. Default is false. (optional, default to false)
         * @return FilesApi.UploadRequestBuilder
         */
        public FilesApi.UploadRequestBuilder enableColdStorage(Boolean enableColdStorage) {
            this.enableColdStorage = enableColdStorage;
            return (FilesApi.UploadRequestBuilder) this;
        }
        
        /**
         * Set hotStorageTimeToLive
         * @param hotStorageTimeToLive Time in days after which the file will be moved to cold storage. Must be one of [1, 3, 7, 14, 30]. (optional)
         * @return FilesApi.UploadRequestBuilder
         */
        public FilesApi.UploadRequestBuilder hotStorageTimeToLive(Integer hotStorageTimeToLive) {
            this.hotStorageTimeToLive = hotStorageTimeToLive;
            return (FilesApi.UploadRequestBuilder) this;
        }
        
        /**
         * Set generateChunksOnly
         * @param generateChunksOnly If this flag is enabled, the file will be chunked and stored with Carbon,             but no embeddings will be generated. This overrides the skip_embedding_generation flag. (optional, default to false)
         * @return FilesApi.UploadRequestBuilder
         */
        public FilesApi.UploadRequestBuilder generateChunksOnly(Boolean generateChunksOnly) {
            this.generateChunksOnly = generateChunksOnly;
            return (FilesApi.UploadRequestBuilder) this;
        }
        
        /**
         * Set storeFileOnly
         * @param storeFileOnly If this flag is enabled, the file will be stored with Carbon, but no processing will be done. (optional, default to false)
         * @return FilesApi.UploadRequestBuilder
         */
        public FilesApi.UploadRequestBuilder storeFileOnly(Boolean storeFileOnly) {
            this.storeFileOnly = storeFileOnly;
            return (FilesApi.UploadRequestBuilder) this;
        }
        
        /**
         * Build call for upload
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            BodyCreateUploadFileUploadfilePost bodyCreateUploadFileUploadfilePost = buildBodyParams();
            return uploadCall(_file, bodyCreateUploadFileUploadfilePost, chunkSize, chunkOverlap, skipEmbeddingGeneration, setPageAsBoundary, embeddingModel, useOcr, generateSparseVectors, prependFilenameToChunks, maxItemsPerChunk, parsePdfTablesWithOcr, detectAudioLanguage, transcriptionService, includeSpeakerLabels, mediaType, splitRows, enableColdStorage, hotStorageTimeToLive, generateChunksOnly, storeFileOnly, _callback);
        }

        private BodyCreateUploadFileUploadfilePost buildBodyParams() {
            BodyCreateUploadFileUploadfilePost bodyCreateUploadFileUploadfilePost = new BodyCreateUploadFileUploadfilePost();
            bodyCreateUploadFileUploadfilePost._file(this._file);
            return bodyCreateUploadFileUploadfilePost;
        }

        /**
         * Execute upload request
         * @return UserFile
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public UserFile execute() throws ApiException {
            BodyCreateUploadFileUploadfilePost bodyCreateUploadFileUploadfilePost = buildBodyParams();
            ApiResponse<UserFile> localVarResp = uploadWithHttpInfo(_file, bodyCreateUploadFileUploadfilePost, chunkSize, chunkOverlap, skipEmbeddingGeneration, setPageAsBoundary, embeddingModel, useOcr, generateSparseVectors, prependFilenameToChunks, maxItemsPerChunk, parsePdfTablesWithOcr, detectAudioLanguage, transcriptionService, includeSpeakerLabels, mediaType, splitRows, enableColdStorage, hotStorageTimeToLive, generateChunksOnly, storeFileOnly);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute upload request with HTTP info returned
         * @return ApiResponse&lt;UserFile&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<UserFile> executeWithHttpInfo() throws ApiException {
            BodyCreateUploadFileUploadfilePost bodyCreateUploadFileUploadfilePost = buildBodyParams();
            return uploadWithHttpInfo(_file, bodyCreateUploadFileUploadfilePost, chunkSize, chunkOverlap, skipEmbeddingGeneration, setPageAsBoundary, embeddingModel, useOcr, generateSparseVectors, prependFilenameToChunks, maxItemsPerChunk, parsePdfTablesWithOcr, detectAudioLanguage, transcriptionService, includeSpeakerLabels, mediaType, splitRows, enableColdStorage, hotStorageTimeToLive, generateChunksOnly, storeFileOnly);
        }

        /**
         * Execute upload request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<UserFile> _callback) throws ApiException {
            BodyCreateUploadFileUploadfilePost bodyCreateUploadFileUploadfilePost = buildBodyParams();
            return uploadAsync(_file, bodyCreateUploadFileUploadfilePost, chunkSize, chunkOverlap, skipEmbeddingGeneration, setPageAsBoundary, embeddingModel, useOcr, generateSparseVectors, prependFilenameToChunks, maxItemsPerChunk, parsePdfTablesWithOcr, detectAudioLanguage, transcriptionService, includeSpeakerLabels, mediaType, splitRows, enableColdStorage, hotStorageTimeToLive, generateChunksOnly, storeFileOnly, _callback);
        }
    }

    /**
     * Create Upload File
     * This endpoint is used to directly upload local files to Carbon. The &#x60;POST&#x60; request should be a multipart form request. Note that the &#x60;set_page_as_boundary&#x60; query parameter is applicable only to PDFs for now. When this value is set, PDF chunks are at most one page long. Additional information can be retrieved for each chunk, however, namely the coordinates of the bounding box around the chunk (this can be used for things like text highlighting). Following is a description of all possible query parameters: - &#x60;chunk_size&#x60;: the chunk size (in tokens) applied when splitting the document - &#x60;chunk_overlap&#x60;: the chunk overlap (in tokens) applied when splitting the document - &#x60;skip_embedding_generation&#x60;: whether or not to skip the generation of chunks and embeddings - &#x60;set_page_as_boundary&#x60;: described above - &#x60;embedding_model&#x60;: the model used to generate embeddings for the document chunks - &#x60;use_ocr&#x60;: whether or not to use OCR as a preprocessing step prior to generating chunks. Valid for PDFs, JPEGs, and PNGs - &#x60;generate_sparse_vectors&#x60;: whether or not to generate sparse vectors for the file. Required for hybrid search. - &#x60;prepend_filename_to_chunks&#x60;: whether or not to prepend the filename to the chunk text   Carbon supports multiple models for use in generating embeddings for files. For images, we support Vertex AI&#39;s multimodal model; for text, we support OpenAI&#39;s &#x60;text-embedding-ada-002&#x60; and Cohere&#39;s embed-multilingual-v3.0. The model can be specified via the &#x60;embedding_model&#x60; parameter (in the POST body for &#x60;/embeddings&#x60;, and a query  parameter in &#x60;/uploadfile&#x60;). If no model is supplied, the &#x60;text-embedding-ada-002&#x60; is used by default. When performing embedding queries, embeddings from files that used the specified model will be considered in the query. For example, if files A and B have embeddings generated with &#x60;OPENAI&#x60;, and files C and D have embeddings generated with &#x60;COHERE_MULTILINGUAL_V3&#x60;, then by default, queries will only consider files A and B. If &#x60;COHERE_MULTILINGUAL_V3&#x60; is specified as the &#x60;embedding_model&#x60; in &#x60;/embeddings&#x60;, then only files C and D will be considered. Make sure that the set of all files you want considered for a query have embeddings generated via the same model. For now, **do not** set &#x60;VERTEX_MULTIMODAL&#x60; as an &#x60;embedding_model&#x60;. This model is used automatically by Carbon when it detects an image file.
     * @param _file  (required)
     * @param bodyCreateUploadFileUploadfilePost  (required)
     * @return UploadRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
     </table>
     */
    public FilesApi.UploadRequestBuilder upload(File _file) throws IllegalArgumentException {
        if (_file == null) throw new IllegalArgumentException("\"_file\" is required but got null");
        return ((FilesApi) this).new UploadRequestBuilder(_file);
    }
    private okhttp3.Call uploadFromUrlCall(UploadFileFromUrlInput uploadFileFromUrlInput, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = uploadFileFromUrlInput;

        // create path and map variables
        String localVarPath = "/upload_file_from_url";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "accessToken", "apiKey", "customerId" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call uploadFromUrlValidateBeforeCall(UploadFileFromUrlInput uploadFileFromUrlInput, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'uploadFileFromUrlInput' is set
        if (uploadFileFromUrlInput == null) {
            throw new ApiException("Missing the required parameter 'uploadFileFromUrlInput' when calling uploadFromUrl(Async)");
        }

        return uploadFromUrlCall(uploadFileFromUrlInput, _callback);

    }


    private ApiResponse<UserFile> uploadFromUrlWithHttpInfo(UploadFileFromUrlInput uploadFileFromUrlInput) throws ApiException {
        okhttp3.Call localVarCall = uploadFromUrlValidateBeforeCall(uploadFileFromUrlInput, null);
        Type localVarReturnType = new TypeToken<UserFile>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call uploadFromUrlAsync(UploadFileFromUrlInput uploadFileFromUrlInput, final ApiCallback<UserFile> _callback) throws ApiException {

        okhttp3.Call localVarCall = uploadFromUrlValidateBeforeCall(uploadFileFromUrlInput, _callback);
        Type localVarReturnType = new TypeToken<UserFile>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public abstract class UploadFromUrlRequestBuilderGenerated {
        final String url;
        String fileName;
        Integer chunkSize;
        Integer chunkOverlap;
        Boolean skipEmbeddingGeneration;
        Boolean setPageAsBoundary;
        EmbeddingGenerators embeddingModel;
        Boolean generateSparseVectors;
        Boolean useTextract;
        Boolean prependFilenameToChunks;
        Integer maxItemsPerChunk;
        Boolean parsePdfTablesWithOcr;
        Boolean detectAudioLanguage;
        TranscriptionServiceNullable transcriptionService;
        Boolean includeSpeakerLabels;
        FileContentTypesNullable mediaType;
        Boolean splitRows;
        ColdStorageProps coldStorageParams;
        Boolean generateChunksOnly;
        Boolean storeFileOnly;

        public UploadFromUrlRequestBuilderGenerated(String url) {
            this.url = url;
        }

        /**
         * Set fileName
         * @param fileName  (optional)
         * @return FilesApi.UploadFromUrlRequestBuilder
         */
        public FilesApi.UploadFromUrlRequestBuilder fileName(String fileName) {
            this.fileName = fileName;
            return (FilesApi.UploadFromUrlRequestBuilder) this;
        }
        
        /**
         * Set chunkSize
         * @param chunkSize  (optional)
         * @return FilesApi.UploadFromUrlRequestBuilder
         */
        public FilesApi.UploadFromUrlRequestBuilder chunkSize(Integer chunkSize) {
            this.chunkSize = chunkSize;
            return (FilesApi.UploadFromUrlRequestBuilder) this;
        }
        
        /**
         * Set chunkOverlap
         * @param chunkOverlap  (optional)
         * @return FilesApi.UploadFromUrlRequestBuilder
         */
        public FilesApi.UploadFromUrlRequestBuilder chunkOverlap(Integer chunkOverlap) {
            this.chunkOverlap = chunkOverlap;
            return (FilesApi.UploadFromUrlRequestBuilder) this;
        }
        
        /**
         * Set skipEmbeddingGeneration
         * @param skipEmbeddingGeneration  (optional, default to false)
         * @return FilesApi.UploadFromUrlRequestBuilder
         */
        public FilesApi.UploadFromUrlRequestBuilder skipEmbeddingGeneration(Boolean skipEmbeddingGeneration) {
            this.skipEmbeddingGeneration = skipEmbeddingGeneration;
            return (FilesApi.UploadFromUrlRequestBuilder) this;
        }
        
        /**
         * Set setPageAsBoundary
         * @param setPageAsBoundary  (optional, default to false)
         * @return FilesApi.UploadFromUrlRequestBuilder
         */
        public FilesApi.UploadFromUrlRequestBuilder setPageAsBoundary(Boolean setPageAsBoundary) {
            this.setPageAsBoundary = setPageAsBoundary;
            return (FilesApi.UploadFromUrlRequestBuilder) this;
        }
        
        /**
         * Set embeddingModel
         * @param embeddingModel  (optional)
         * @return FilesApi.UploadFromUrlRequestBuilder
         */
        public FilesApi.UploadFromUrlRequestBuilder embeddingModel(EmbeddingGenerators embeddingModel) {
            this.embeddingModel = embeddingModel;
            return (FilesApi.UploadFromUrlRequestBuilder) this;
        }
        
        /**
         * Set generateSparseVectors
         * @param generateSparseVectors  (optional, default to false)
         * @return FilesApi.UploadFromUrlRequestBuilder
         */
        public FilesApi.UploadFromUrlRequestBuilder generateSparseVectors(Boolean generateSparseVectors) {
            this.generateSparseVectors = generateSparseVectors;
            return (FilesApi.UploadFromUrlRequestBuilder) this;
        }
        
        /**
         * Set useTextract
         * @param useTextract  (optional, default to false)
         * @return FilesApi.UploadFromUrlRequestBuilder
         */
        public FilesApi.UploadFromUrlRequestBuilder useTextract(Boolean useTextract) {
            this.useTextract = useTextract;
            return (FilesApi.UploadFromUrlRequestBuilder) this;
        }
        
        /**
         * Set prependFilenameToChunks
         * @param prependFilenameToChunks  (optional, default to false)
         * @return FilesApi.UploadFromUrlRequestBuilder
         */
        public FilesApi.UploadFromUrlRequestBuilder prependFilenameToChunks(Boolean prependFilenameToChunks) {
            this.prependFilenameToChunks = prependFilenameToChunks;
            return (FilesApi.UploadFromUrlRequestBuilder) this;
        }
        
        /**
         * Set maxItemsPerChunk
         * @param maxItemsPerChunk Number of objects per chunk. For csv, tsv, xlsx, and json files only. (optional)
         * @return FilesApi.UploadFromUrlRequestBuilder
         */
        public FilesApi.UploadFromUrlRequestBuilder maxItemsPerChunk(Integer maxItemsPerChunk) {
            this.maxItemsPerChunk = maxItemsPerChunk;
            return (FilesApi.UploadFromUrlRequestBuilder) this;
        }
        
        /**
         * Set parsePdfTablesWithOcr
         * @param parsePdfTablesWithOcr  (optional, default to false)
         * @return FilesApi.UploadFromUrlRequestBuilder
         */
        public FilesApi.UploadFromUrlRequestBuilder parsePdfTablesWithOcr(Boolean parsePdfTablesWithOcr) {
            this.parsePdfTablesWithOcr = parsePdfTablesWithOcr;
            return (FilesApi.UploadFromUrlRequestBuilder) this;
        }
        
        /**
         * Set detectAudioLanguage
         * @param detectAudioLanguage  (optional, default to false)
         * @return FilesApi.UploadFromUrlRequestBuilder
         */
        public FilesApi.UploadFromUrlRequestBuilder detectAudioLanguage(Boolean detectAudioLanguage) {
            this.detectAudioLanguage = detectAudioLanguage;
            return (FilesApi.UploadFromUrlRequestBuilder) this;
        }
        
        /**
         * Set transcriptionService
         * @param transcriptionService  (optional)
         * @return FilesApi.UploadFromUrlRequestBuilder
         */
        public FilesApi.UploadFromUrlRequestBuilder transcriptionService(TranscriptionServiceNullable transcriptionService) {
            this.transcriptionService = transcriptionService;
            return (FilesApi.UploadFromUrlRequestBuilder) this;
        }
        
        /**
         * Set includeSpeakerLabels
         * @param includeSpeakerLabels  (optional, default to false)
         * @return FilesApi.UploadFromUrlRequestBuilder
         */
        public FilesApi.UploadFromUrlRequestBuilder includeSpeakerLabels(Boolean includeSpeakerLabels) {
            this.includeSpeakerLabels = includeSpeakerLabels;
            return (FilesApi.UploadFromUrlRequestBuilder) this;
        }
        
        /**
         * Set mediaType
         * @param mediaType  (optional)
         * @return FilesApi.UploadFromUrlRequestBuilder
         */
        public FilesApi.UploadFromUrlRequestBuilder mediaType(FileContentTypesNullable mediaType) {
            this.mediaType = mediaType;
            return (FilesApi.UploadFromUrlRequestBuilder) this;
        }
        
        /**
         * Set splitRows
         * @param splitRows  (optional, default to false)
         * @return FilesApi.UploadFromUrlRequestBuilder
         */
        public FilesApi.UploadFromUrlRequestBuilder splitRows(Boolean splitRows) {
            this.splitRows = splitRows;
            return (FilesApi.UploadFromUrlRequestBuilder) this;
        }
        
        /**
         * Set coldStorageParams
         * @param coldStorageParams  (optional)
         * @return FilesApi.UploadFromUrlRequestBuilder
         */
        public FilesApi.UploadFromUrlRequestBuilder coldStorageParams(ColdStorageProps coldStorageParams) {
            this.coldStorageParams = coldStorageParams;
            return (FilesApi.UploadFromUrlRequestBuilder) this;
        }
        
        /**
         * Set generateChunksOnly
         * @param generateChunksOnly If this flag is enabled, the file will be chunked and stored with Carbon,         but no embeddings will be generated. This overrides the skip_embedding_generation flag. (optional, default to false)
         * @return FilesApi.UploadFromUrlRequestBuilder
         */
        public FilesApi.UploadFromUrlRequestBuilder generateChunksOnly(Boolean generateChunksOnly) {
            this.generateChunksOnly = generateChunksOnly;
            return (FilesApi.UploadFromUrlRequestBuilder) this;
        }
        
        /**
         * Set storeFileOnly
         * @param storeFileOnly If this flag is enabled, the file will be stored with Carbon, but no processing will be done. (optional, default to false)
         * @return FilesApi.UploadFromUrlRequestBuilder
         */
        public FilesApi.UploadFromUrlRequestBuilder storeFileOnly(Boolean storeFileOnly) {
            this.storeFileOnly = storeFileOnly;
            return (FilesApi.UploadFromUrlRequestBuilder) this;
        }
        
        /**
         * Build call for uploadFromUrl
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            UploadFileFromUrlInput uploadFileFromUrlInput = buildBodyParams();
            return uploadFromUrlCall(uploadFileFromUrlInput, _callback);
        }

        private UploadFileFromUrlInput buildBodyParams() {
            UploadFileFromUrlInput uploadFileFromUrlInput = new UploadFileFromUrlInput();
            uploadFileFromUrlInput.url(this.url);
            uploadFileFromUrlInput.fileName(this.fileName);
            uploadFileFromUrlInput.chunkSize(this.chunkSize);
            uploadFileFromUrlInput.chunkOverlap(this.chunkOverlap);
            uploadFileFromUrlInput.skipEmbeddingGeneration(this.skipEmbeddingGeneration);
            uploadFileFromUrlInput.setPageAsBoundary(this.setPageAsBoundary);
            uploadFileFromUrlInput.embeddingModel(this.embeddingModel);
            uploadFileFromUrlInput.generateSparseVectors(this.generateSparseVectors);
            uploadFileFromUrlInput.useTextract(this.useTextract);
            uploadFileFromUrlInput.prependFilenameToChunks(this.prependFilenameToChunks);
            uploadFileFromUrlInput.maxItemsPerChunk(this.maxItemsPerChunk);
            uploadFileFromUrlInput.parsePdfTablesWithOcr(this.parsePdfTablesWithOcr);
            uploadFileFromUrlInput.detectAudioLanguage(this.detectAudioLanguage);
            uploadFileFromUrlInput.transcriptionService(this.transcriptionService);
            uploadFileFromUrlInput.includeSpeakerLabels(this.includeSpeakerLabels);
            uploadFileFromUrlInput.mediaType(this.mediaType);
            uploadFileFromUrlInput.splitRows(this.splitRows);
            uploadFileFromUrlInput.coldStorageParams(this.coldStorageParams);
            uploadFileFromUrlInput.generateChunksOnly(this.generateChunksOnly);
            uploadFileFromUrlInput.storeFileOnly(this.storeFileOnly);
            return uploadFileFromUrlInput;
        }

        /**
         * Execute uploadFromUrl request
         * @return UserFile
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public UserFile execute() throws ApiException {
            UploadFileFromUrlInput uploadFileFromUrlInput = buildBodyParams();
            ApiResponse<UserFile> localVarResp = uploadFromUrlWithHttpInfo(uploadFileFromUrlInput);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute uploadFromUrl request with HTTP info returned
         * @return ApiResponse&lt;UserFile&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<UserFile> executeWithHttpInfo() throws ApiException {
            UploadFileFromUrlInput uploadFileFromUrlInput = buildBodyParams();
            return uploadFromUrlWithHttpInfo(uploadFileFromUrlInput);
        }

        /**
         * Execute uploadFromUrl request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<UserFile> _callback) throws ApiException {
            UploadFileFromUrlInput uploadFileFromUrlInput = buildBodyParams();
            return uploadFromUrlAsync(uploadFileFromUrlInput, _callback);
        }
    }

    /**
     * Create Upload File From Url
     * 
     * @param uploadFileFromUrlInput  (required)
     * @return UploadFromUrlRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
     </table>
     */
    public FilesApi.UploadFromUrlRequestBuilder uploadFromUrl(String url) throws IllegalArgumentException {
        if (url == null) throw new IllegalArgumentException("\"url\" is required but got null");
            

        return ((FilesApi) this).new UploadFromUrlRequestBuilder(url);
    }
    private okhttp3.Call uploadTextCall(RawTextInput rawTextInput, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = rawTextInput;

        // create path and map variables
        String localVarPath = "/upload_text";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "accessToken", "apiKey", "customerId" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call uploadTextValidateBeforeCall(RawTextInput rawTextInput, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'rawTextInput' is set
        if (rawTextInput == null) {
            throw new ApiException("Missing the required parameter 'rawTextInput' when calling uploadText(Async)");
        }

        return uploadTextCall(rawTextInput, _callback);

    }


    private ApiResponse<UserFile> uploadTextWithHttpInfo(RawTextInput rawTextInput) throws ApiException {
        okhttp3.Call localVarCall = uploadTextValidateBeforeCall(rawTextInput, null);
        Type localVarReturnType = new TypeToken<UserFile>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call uploadTextAsync(RawTextInput rawTextInput, final ApiCallback<UserFile> _callback) throws ApiException {

        okhttp3.Call localVarCall = uploadTextValidateBeforeCall(rawTextInput, _callback);
        Type localVarReturnType = new TypeToken<UserFile>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public abstract class UploadTextRequestBuilderGenerated {
        final String contents;
        String name;
        Integer chunkSize;
        Integer chunkOverlap;
        Boolean skipEmbeddingGeneration;
        Integer overwriteFileId;
        EmbeddingGeneratorsNullable embeddingModel;
        Boolean generateSparseVectors;
        ColdStorageProps coldStorageParams;
        Boolean generateChunksOnly;
        Boolean storeFileOnly;

        public UploadTextRequestBuilderGenerated(String contents) {
            this.contents = contents;
        }

        /**
         * Set name
         * @param name  (optional)
         * @return FilesApi.UploadTextRequestBuilder
         */
        public FilesApi.UploadTextRequestBuilder name(String name) {
            this.name = name;
            return (FilesApi.UploadTextRequestBuilder) this;
        }
        
        /**
         * Set chunkSize
         * @param chunkSize  (optional)
         * @return FilesApi.UploadTextRequestBuilder
         */
        public FilesApi.UploadTextRequestBuilder chunkSize(Integer chunkSize) {
            this.chunkSize = chunkSize;
            return (FilesApi.UploadTextRequestBuilder) this;
        }
        
        /**
         * Set chunkOverlap
         * @param chunkOverlap  (optional)
         * @return FilesApi.UploadTextRequestBuilder
         */
        public FilesApi.UploadTextRequestBuilder chunkOverlap(Integer chunkOverlap) {
            this.chunkOverlap = chunkOverlap;
            return (FilesApi.UploadTextRequestBuilder) this;
        }
        
        /**
         * Set skipEmbeddingGeneration
         * @param skipEmbeddingGeneration  (optional, default to false)
         * @return FilesApi.UploadTextRequestBuilder
         */
        public FilesApi.UploadTextRequestBuilder skipEmbeddingGeneration(Boolean skipEmbeddingGeneration) {
            this.skipEmbeddingGeneration = skipEmbeddingGeneration;
            return (FilesApi.UploadTextRequestBuilder) this;
        }
        
        /**
         * Set overwriteFileId
         * @param overwriteFileId  (optional)
         * @return FilesApi.UploadTextRequestBuilder
         */
        public FilesApi.UploadTextRequestBuilder overwriteFileId(Integer overwriteFileId) {
            this.overwriteFileId = overwriteFileId;
            return (FilesApi.UploadTextRequestBuilder) this;
        }
        
        /**
         * Set embeddingModel
         * @param embeddingModel  (optional, default to OPENAI)
         * @return FilesApi.UploadTextRequestBuilder
         */
        public FilesApi.UploadTextRequestBuilder embeddingModel(EmbeddingGeneratorsNullable embeddingModel) {
            this.embeddingModel = embeddingModel;
            return (FilesApi.UploadTextRequestBuilder) this;
        }
        
        /**
         * Set generateSparseVectors
         * @param generateSparseVectors  (optional, default to false)
         * @return FilesApi.UploadTextRequestBuilder
         */
        public FilesApi.UploadTextRequestBuilder generateSparseVectors(Boolean generateSparseVectors) {
            this.generateSparseVectors = generateSparseVectors;
            return (FilesApi.UploadTextRequestBuilder) this;
        }
        
        /**
         * Set coldStorageParams
         * @param coldStorageParams  (optional)
         * @return FilesApi.UploadTextRequestBuilder
         */
        public FilesApi.UploadTextRequestBuilder coldStorageParams(ColdStorageProps coldStorageParams) {
            this.coldStorageParams = coldStorageParams;
            return (FilesApi.UploadTextRequestBuilder) this;
        }
        
        /**
         * Set generateChunksOnly
         * @param generateChunksOnly If this flag is enabled, the file will be chunked and stored with Carbon,         but no embeddings will be generated. This overrides the skip_embedding_generation flag. (optional, default to false)
         * @return FilesApi.UploadTextRequestBuilder
         */
        public FilesApi.UploadTextRequestBuilder generateChunksOnly(Boolean generateChunksOnly) {
            this.generateChunksOnly = generateChunksOnly;
            return (FilesApi.UploadTextRequestBuilder) this;
        }
        
        /**
         * Set storeFileOnly
         * @param storeFileOnly If this flag is enabled, the file will be stored with Carbon, but no processing will be done. (optional, default to false)
         * @return FilesApi.UploadTextRequestBuilder
         */
        public FilesApi.UploadTextRequestBuilder storeFileOnly(Boolean storeFileOnly) {
            this.storeFileOnly = storeFileOnly;
            return (FilesApi.UploadTextRequestBuilder) this;
        }
        
        /**
         * Build call for uploadText
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            RawTextInput rawTextInput = buildBodyParams();
            return uploadTextCall(rawTextInput, _callback);
        }

        private RawTextInput buildBodyParams() {
            RawTextInput rawTextInput = new RawTextInput();
            rawTextInput.contents(this.contents);
            rawTextInput.name(this.name);
            rawTextInput.chunkSize(this.chunkSize);
            rawTextInput.chunkOverlap(this.chunkOverlap);
            rawTextInput.skipEmbeddingGeneration(this.skipEmbeddingGeneration);
            rawTextInput.overwriteFileId(this.overwriteFileId);
            rawTextInput.embeddingModel(this.embeddingModel);
            rawTextInput.generateSparseVectors(this.generateSparseVectors);
            rawTextInput.coldStorageParams(this.coldStorageParams);
            rawTextInput.generateChunksOnly(this.generateChunksOnly);
            rawTextInput.storeFileOnly(this.storeFileOnly);
            return rawTextInput;
        }

        /**
         * Execute uploadText request
         * @return UserFile
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public UserFile execute() throws ApiException {
            RawTextInput rawTextInput = buildBodyParams();
            ApiResponse<UserFile> localVarResp = uploadTextWithHttpInfo(rawTextInput);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute uploadText request with HTTP info returned
         * @return ApiResponse&lt;UserFile&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<UserFile> executeWithHttpInfo() throws ApiException {
            RawTextInput rawTextInput = buildBodyParams();
            return uploadTextWithHttpInfo(rawTextInput);
        }

        /**
         * Execute uploadText request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<UserFile> _callback) throws ApiException {
            RawTextInput rawTextInput = buildBodyParams();
            return uploadTextAsync(rawTextInput, _callback);
        }
    }

    /**
     * Create Raw Text
     * Carbon supports multiple models for use in generating embeddings for files. For images, we support Vertex AI&#39;s multimodal model; for text, we support OpenAI&#39;s &#x60;text-embedding-ada-002&#x60; and Cohere&#39;s embed-multilingual-v3.0. The model can be specified via the &#x60;embedding_model&#x60; parameter (in the POST body for &#x60;/embeddings&#x60;, and a query  parameter in &#x60;/uploadfile&#x60;). If no model is supplied, the &#x60;text-embedding-ada-002&#x60; is used by default. When performing embedding queries, embeddings from files that used the specified model will be considered in the query. For example, if files A and B have embeddings generated with &#x60;OPENAI&#x60;, and files C and D have embeddings generated with &#x60;COHERE_MULTILINGUAL_V3&#x60;, then by default, queries will only consider files A and B. If &#x60;COHERE_MULTILINGUAL_V3&#x60; is specified as the &#x60;embedding_model&#x60; in &#x60;/embeddings&#x60;, then only files C and D will be considered. Make sure that the set of all files you want considered for a query have embeddings generated via the same model. For now, **do not** set &#x60;VERTEX_MULTIMODAL&#x60; as an &#x60;embedding_model&#x60;. This model is used automatically by Carbon when it detects an image file.
     * @param rawTextInput  (required)
     * @return UploadTextRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
     </table>
     */
    public FilesApi.UploadTextRequestBuilder uploadText(String contents) throws IllegalArgumentException {
        if (contents == null) throw new IllegalArgumentException("\"contents\" is required but got null");
            if (contents != null && contents.length() < 5) {
              throw new IllegalArgumentException("Invalid value for contents. Length must be greater than or equal to 5.");
            }

        return ((FilesApi) this).new UploadTextRequestBuilder(contents);
    }
}
