/*
 * Carbon
 * Connect external data to LLMs, no matter the source.
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by Konfig (https://konfigthis.com).
 * Do not edit the class manually.
 */


package com.konfigthis.carbonai.client.api;

import com.konfigthis.carbonai.client.ApiCallback;
import com.konfigthis.carbonai.client.ApiClient;
import com.konfigthis.carbonai.client.ApiException;
import com.konfigthis.carbonai.client.ApiResponse;
import com.konfigthis.carbonai.client.Configuration;
import com.konfigthis.carbonai.client.Pair;
import com.konfigthis.carbonai.client.ProgressRequestBody;
import com.konfigthis.carbonai.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import com.konfigthis.carbonai.client.model.BodyCreateUploadFileUploadfilePost;
import com.konfigthis.carbonai.client.model.DeleteFilesQueryInput;
import com.konfigthis.carbonai.client.model.DeleteFilesV2QueryInput;
import com.konfigthis.carbonai.client.model.EmbeddingGenerators;
import com.konfigthis.carbonai.client.model.EmbeddingGeneratorsNullable;
import com.konfigthis.carbonai.client.model.ExternalFileSyncStatuses;
import java.io.File;
import com.konfigthis.carbonai.client.model.FileContentTypesNullable;
import com.konfigthis.carbonai.client.model.GenericSuccessResponse;
import com.konfigthis.carbonai.client.model.OrderDir;
import com.konfigthis.carbonai.client.model.OrganizationUserFileTagCreate;
import com.konfigthis.carbonai.client.model.OrganizationUserFileTagsRemove;
import com.konfigthis.carbonai.client.model.OrganizationUserFilesToSyncFilters;
import com.konfigthis.carbonai.client.model.OrganizationUserFilesToSyncOrderByTypes;
import com.konfigthis.carbonai.client.model.OrganizationUserFilesToSyncQueryInput;
import com.konfigthis.carbonai.client.model.Pagination;
import com.konfigthis.carbonai.client.model.PresignedURLResponse;
import com.konfigthis.carbonai.client.model.RawTextInput;
import com.konfigthis.carbonai.client.model.ResyncFileQueryInput;
import com.konfigthis.carbonai.client.model.TMEmbeddingGenerators;
import com.konfigthis.carbonai.client.model.UploadFileFromUrlInput;
import com.konfigthis.carbonai.client.model.UserFile;
import com.konfigthis.carbonai.client.model.UserFilesV2;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.ws.rs.core.GenericType;

public class FilesApiGenerated {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public FilesApiGenerated() throws IllegalArgumentException {
        this(Configuration.getDefaultApiClient());
    }

    public FilesApiGenerated(ApiClient apiClient) throws IllegalArgumentException {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    private okhttp3.Call createUserFileTagsCall(OrganizationUserFileTagCreate organizationUserFileTagCreate, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = organizationUserFileTagCreate;

        // create path and map variables
        String localVarPath = "/create_user_file_tags";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "accessToken", "apiKey", "customerId" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call createUserFileTagsValidateBeforeCall(OrganizationUserFileTagCreate organizationUserFileTagCreate, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'organizationUserFileTagCreate' is set
        if (organizationUserFileTagCreate == null) {
            throw new ApiException("Missing the required parameter 'organizationUserFileTagCreate' when calling createUserFileTags(Async)");
        }

        return createUserFileTagsCall(organizationUserFileTagCreate, _callback);

    }


    private ApiResponse<UserFile> createUserFileTagsWithHttpInfo(OrganizationUserFileTagCreate organizationUserFileTagCreate) throws ApiException {
        okhttp3.Call localVarCall = createUserFileTagsValidateBeforeCall(organizationUserFileTagCreate, null);
        Type localVarReturnType = new TypeToken<UserFile>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call createUserFileTagsAsync(OrganizationUserFileTagCreate organizationUserFileTagCreate, final ApiCallback<UserFile> _callback) throws ApiException {

        okhttp3.Call localVarCall = createUserFileTagsValidateBeforeCall(organizationUserFileTagCreate, _callback);
        Type localVarReturnType = new TypeToken<UserFile>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class CreateUserFileTagsRequestBuilder {
        private final Map<String, Object> tags;
        private final Integer organizationUserFileId;

        private CreateUserFileTagsRequestBuilder(Map<String, Object> tags, Integer organizationUserFileId) {
            this.tags = tags;
            this.organizationUserFileId = organizationUserFileId;
        }

        /**
         * Build call for createUserFileTags
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            OrganizationUserFileTagCreate organizationUserFileTagCreate = buildBodyParams();
            return createUserFileTagsCall(organizationUserFileTagCreate, _callback);
        }

        private OrganizationUserFileTagCreate buildBodyParams() {
            OrganizationUserFileTagCreate organizationUserFileTagCreate = new OrganizationUserFileTagCreate();
            organizationUserFileTagCreate.tags(this.tags);
            organizationUserFileTagCreate.organizationUserFileId(this.organizationUserFileId);
            return organizationUserFileTagCreate;
        }

        /**
         * Execute createUserFileTags request
         * @return UserFile
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public UserFile execute() throws ApiException {
            OrganizationUserFileTagCreate organizationUserFileTagCreate = buildBodyParams();
            ApiResponse<UserFile> localVarResp = createUserFileTagsWithHttpInfo(organizationUserFileTagCreate);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute createUserFileTags request with HTTP info returned
         * @return ApiResponse&lt;UserFile&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<UserFile> executeWithHttpInfo() throws ApiException {
            OrganizationUserFileTagCreate organizationUserFileTagCreate = buildBodyParams();
            return createUserFileTagsWithHttpInfo(organizationUserFileTagCreate);
        }

        /**
         * Execute createUserFileTags request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<UserFile> _callback) throws ApiException {
            OrganizationUserFileTagCreate organizationUserFileTagCreate = buildBodyParams();
            return createUserFileTagsAsync(organizationUserFileTagCreate, _callback);
        }
    }

    /**
     * Create File Tags
     * A tag is a key-value pair that can be added to a file. This pair can then be used for searches (e.g. embedding searches) in order to narrow down the scope of the search. A file can have any number of tags. The following are reserved keys that cannot be used: - db_embedding_id - organization_id - user_id - organization_user_file_id  Carbon currently supports two data types for tag values - &#x60;string&#x60; and &#x60;list&lt;string&gt;&#x60;. Keys can only be &#x60;string&#x60;. If values other than &#x60;string&#x60; and &#x60;list&lt;string&gt;&#x60; are used, they&#39;re automatically converted to strings (e.g. 4 will become \&quot;4\&quot;).
     * @param organizationUserFileTagCreate  (required)
     * @return CreateUserFileTagsRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
     </table>
     */
    public CreateUserFileTagsRequestBuilder createUserFileTags(Map<String, Object> tags, Integer organizationUserFileId) throws IllegalArgumentException {
        if (tags == null) throw new IllegalArgumentException("\"tags\" is required but got null");
        if (organizationUserFileId == null) throw new IllegalArgumentException("\"organizationUserFileId\" is required but got null");
        return new CreateUserFileTagsRequestBuilder(tags, organizationUserFileId);
    }
    private okhttp3.Call deleteCall(Integer fileId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/deletefile/{file_id}"
            .replace("{" + "file_id" + "}", localVarApiClient.escapeString(fileId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "accessToken", "apiKey", "customerId" };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @Deprecated
    @SuppressWarnings("rawtypes")
    private okhttp3.Call deleteValidateBeforeCall(Integer fileId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'fileId' is set
        if (fileId == null) {
            throw new ApiException("Missing the required parameter 'fileId' when calling delete(Async)");
        }

        return deleteCall(fileId, _callback);

    }


    private ApiResponse<GenericSuccessResponse> deleteWithHttpInfo(Integer fileId) throws ApiException {
        okhttp3.Call localVarCall = deleteValidateBeforeCall(fileId, null);
        Type localVarReturnType = new TypeToken<GenericSuccessResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call deleteAsync(Integer fileId, final ApiCallback<GenericSuccessResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = deleteValidateBeforeCall(fileId, _callback);
        Type localVarReturnType = new TypeToken<GenericSuccessResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class DeleteRequestBuilder {
        private final Integer fileId;

        private DeleteRequestBuilder(Integer fileId) {
            this.fileId = fileId;
        }

        /**
         * Build call for delete
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         * @deprecated
         */
        @Deprecated
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return deleteCall(fileId, _callback);
        }


        /**
         * Execute delete request
         * @return GenericSuccessResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         * @deprecated
         */
        @Deprecated
        public GenericSuccessResponse execute() throws ApiException {
            ApiResponse<GenericSuccessResponse> localVarResp = deleteWithHttpInfo(fileId);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute delete request with HTTP info returned
         * @return ApiResponse&lt;GenericSuccessResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         * @deprecated
         */
        @Deprecated
        public ApiResponse<GenericSuccessResponse> executeWithHttpInfo() throws ApiException {
            return deleteWithHttpInfo(fileId);
        }

        /**
         * Execute delete request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         * @deprecated
         */
        @Deprecated
        public okhttp3.Call executeAsync(final ApiCallback<GenericSuccessResponse> _callback) throws ApiException {
            return deleteAsync(fileId, _callback);
        }
    }

    /**
     * Delete File Endpoint
     * 
     * @param fileId  (required)
     * @return DeleteRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
     </table>
     * @deprecated
     */
    @Deprecated
    public DeleteRequestBuilder delete(Integer fileId) throws IllegalArgumentException {
        if (fileId == null) throw new IllegalArgumentException("\"fileId\" is required but got null");
        return new DeleteRequestBuilder(fileId);
    }
    private okhttp3.Call deleteFileTagsCall(OrganizationUserFileTagsRemove organizationUserFileTagsRemove, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = organizationUserFileTagsRemove;

        // create path and map variables
        String localVarPath = "/delete_user_file_tags";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "accessToken", "apiKey", "customerId" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call deleteFileTagsValidateBeforeCall(OrganizationUserFileTagsRemove organizationUserFileTagsRemove, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'organizationUserFileTagsRemove' is set
        if (organizationUserFileTagsRemove == null) {
            throw new ApiException("Missing the required parameter 'organizationUserFileTagsRemove' when calling deleteFileTags(Async)");
        }

        return deleteFileTagsCall(organizationUserFileTagsRemove, _callback);

    }


    private ApiResponse<UserFile> deleteFileTagsWithHttpInfo(OrganizationUserFileTagsRemove organizationUserFileTagsRemove) throws ApiException {
        okhttp3.Call localVarCall = deleteFileTagsValidateBeforeCall(organizationUserFileTagsRemove, null);
        Type localVarReturnType = new TypeToken<UserFile>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call deleteFileTagsAsync(OrganizationUserFileTagsRemove organizationUserFileTagsRemove, final ApiCallback<UserFile> _callback) throws ApiException {

        okhttp3.Call localVarCall = deleteFileTagsValidateBeforeCall(organizationUserFileTagsRemove, _callback);
        Type localVarReturnType = new TypeToken<UserFile>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class DeleteFileTagsRequestBuilder {
        private final List<String> tags;
        private final Integer organizationUserFileId;

        private DeleteFileTagsRequestBuilder(List<String> tags, Integer organizationUserFileId) {
            this.tags = tags;
            this.organizationUserFileId = organizationUserFileId;
        }

        /**
         * Build call for deleteFileTags
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            OrganizationUserFileTagsRemove organizationUserFileTagsRemove = buildBodyParams();
            return deleteFileTagsCall(organizationUserFileTagsRemove, _callback);
        }

        private OrganizationUserFileTagsRemove buildBodyParams() {
            OrganizationUserFileTagsRemove organizationUserFileTagsRemove = new OrganizationUserFileTagsRemove();
            organizationUserFileTagsRemove.tags(this.tags);
            organizationUserFileTagsRemove.organizationUserFileId(this.organizationUserFileId);
            return organizationUserFileTagsRemove;
        }

        /**
         * Execute deleteFileTags request
         * @return UserFile
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public UserFile execute() throws ApiException {
            OrganizationUserFileTagsRemove organizationUserFileTagsRemove = buildBodyParams();
            ApiResponse<UserFile> localVarResp = deleteFileTagsWithHttpInfo(organizationUserFileTagsRemove);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute deleteFileTags request with HTTP info returned
         * @return ApiResponse&lt;UserFile&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<UserFile> executeWithHttpInfo() throws ApiException {
            OrganizationUserFileTagsRemove organizationUserFileTagsRemove = buildBodyParams();
            return deleteFileTagsWithHttpInfo(organizationUserFileTagsRemove);
        }

        /**
         * Execute deleteFileTags request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<UserFile> _callback) throws ApiException {
            OrganizationUserFileTagsRemove organizationUserFileTagsRemove = buildBodyParams();
            return deleteFileTagsAsync(organizationUserFileTagsRemove, _callback);
        }
    }

    /**
     * Delete File Tags
     * 
     * @param organizationUserFileTagsRemove  (required)
     * @return DeleteFileTagsRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
     </table>
     */
    public DeleteFileTagsRequestBuilder deleteFileTags(List<String> tags, Integer organizationUserFileId) throws IllegalArgumentException {
        if (tags == null) throw new IllegalArgumentException("\"tags\" is required but got null");
        if (organizationUserFileId == null) throw new IllegalArgumentException("\"organizationUserFileId\" is required but got null");
        return new DeleteFileTagsRequestBuilder(tags, organizationUserFileId);
    }
    private okhttp3.Call deleteManyCall(DeleteFilesQueryInput deleteFilesQueryInput, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = deleteFilesQueryInput;

        // create path and map variables
        String localVarPath = "/delete_files";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "accessToken", "apiKey", "customerId" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @Deprecated
    @SuppressWarnings("rawtypes")
    private okhttp3.Call deleteManyValidateBeforeCall(DeleteFilesQueryInput deleteFilesQueryInput, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'deleteFilesQueryInput' is set
        if (deleteFilesQueryInput == null) {
            throw new ApiException("Missing the required parameter 'deleteFilesQueryInput' when calling deleteMany(Async)");
        }

        return deleteManyCall(deleteFilesQueryInput, _callback);

    }


    private ApiResponse<GenericSuccessResponse> deleteManyWithHttpInfo(DeleteFilesQueryInput deleteFilesQueryInput) throws ApiException {
        okhttp3.Call localVarCall = deleteManyValidateBeforeCall(deleteFilesQueryInput, null);
        Type localVarReturnType = new TypeToken<GenericSuccessResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call deleteManyAsync(DeleteFilesQueryInput deleteFilesQueryInput, final ApiCallback<GenericSuccessResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = deleteManyValidateBeforeCall(deleteFilesQueryInput, _callback);
        Type localVarReturnType = new TypeToken<GenericSuccessResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class DeleteManyRequestBuilder {
        private List<Integer> fileIds;
        private List<ExternalFileSyncStatuses> syncStatuses;
        private Boolean deleteNonSyncedOnly;
        private Boolean sendWebhook;
        private Boolean deleteChildFiles;

        private DeleteManyRequestBuilder() {
        }

        /**
         * Set fileIds
         * @param fileIds  (optional)
         * @return DeleteManyRequestBuilder
         */
        public DeleteManyRequestBuilder fileIds(List<Integer> fileIds) {
            this.fileIds = fileIds;
            return this;
        }
        
        /**
         * Set syncStatuses
         * @param syncStatuses  (optional)
         * @return DeleteManyRequestBuilder
         */
        public DeleteManyRequestBuilder syncStatuses(List<ExternalFileSyncStatuses> syncStatuses) {
            this.syncStatuses = syncStatuses;
            return this;
        }
        
        /**
         * Set deleteNonSyncedOnly
         * @param deleteNonSyncedOnly  (optional, default to false)
         * @return DeleteManyRequestBuilder
         */
        public DeleteManyRequestBuilder deleteNonSyncedOnly(Boolean deleteNonSyncedOnly) {
            this.deleteNonSyncedOnly = deleteNonSyncedOnly;
            return this;
        }
        
        /**
         * Set sendWebhook
         * @param sendWebhook  (optional, default to false)
         * @return DeleteManyRequestBuilder
         */
        public DeleteManyRequestBuilder sendWebhook(Boolean sendWebhook) {
            this.sendWebhook = sendWebhook;
            return this;
        }
        
        /**
         * Set deleteChildFiles
         * @param deleteChildFiles  (optional, default to false)
         * @return DeleteManyRequestBuilder
         */
        public DeleteManyRequestBuilder deleteChildFiles(Boolean deleteChildFiles) {
            this.deleteChildFiles = deleteChildFiles;
            return this;
        }
        
        /**
         * Build call for deleteMany
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         * @deprecated
         */
        @Deprecated
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            DeleteFilesQueryInput deleteFilesQueryInput = buildBodyParams();
            return deleteManyCall(deleteFilesQueryInput, _callback);
        }

        private DeleteFilesQueryInput buildBodyParams() {
            DeleteFilesQueryInput deleteFilesQueryInput = new DeleteFilesQueryInput();
            deleteFilesQueryInput.fileIds(this.fileIds);
            deleteFilesQueryInput.syncStatuses(this.syncStatuses);
            deleteFilesQueryInput.deleteNonSyncedOnly(this.deleteNonSyncedOnly);
            deleteFilesQueryInput.sendWebhook(this.sendWebhook);
            deleteFilesQueryInput.deleteChildFiles(this.deleteChildFiles);
            return deleteFilesQueryInput;
        }

        /**
         * Execute deleteMany request
         * @return GenericSuccessResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         * @deprecated
         */
        @Deprecated
        public GenericSuccessResponse execute() throws ApiException {
            DeleteFilesQueryInput deleteFilesQueryInput = buildBodyParams();
            ApiResponse<GenericSuccessResponse> localVarResp = deleteManyWithHttpInfo(deleteFilesQueryInput);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute deleteMany request with HTTP info returned
         * @return ApiResponse&lt;GenericSuccessResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         * @deprecated
         */
        @Deprecated
        public ApiResponse<GenericSuccessResponse> executeWithHttpInfo() throws ApiException {
            DeleteFilesQueryInput deleteFilesQueryInput = buildBodyParams();
            return deleteManyWithHttpInfo(deleteFilesQueryInput);
        }

        /**
         * Execute deleteMany request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         * @deprecated
         */
        @Deprecated
        public okhttp3.Call executeAsync(final ApiCallback<GenericSuccessResponse> _callback) throws ApiException {
            DeleteFilesQueryInput deleteFilesQueryInput = buildBodyParams();
            return deleteManyAsync(deleteFilesQueryInput, _callback);
        }
    }

    /**
     * Delete Files Endpoint
     * 
     * @param deleteFilesQueryInput  (required)
     * @return DeleteManyRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
     </table>
     * @deprecated
     */
    @Deprecated
    public DeleteManyRequestBuilder deleteMany() throws IllegalArgumentException {
        return new DeleteManyRequestBuilder();
    }
    private okhttp3.Call deleteV2Call(DeleteFilesV2QueryInput deleteFilesV2QueryInput, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = deleteFilesV2QueryInput;

        // create path and map variables
        String localVarPath = "/delete_files_v2";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "accessToken", "apiKey", "customerId" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call deleteV2ValidateBeforeCall(DeleteFilesV2QueryInput deleteFilesV2QueryInput, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'deleteFilesV2QueryInput' is set
        if (deleteFilesV2QueryInput == null) {
            throw new ApiException("Missing the required parameter 'deleteFilesV2QueryInput' when calling deleteV2(Async)");
        }

        return deleteV2Call(deleteFilesV2QueryInput, _callback);

    }


    private ApiResponse<GenericSuccessResponse> deleteV2WithHttpInfo(DeleteFilesV2QueryInput deleteFilesV2QueryInput) throws ApiException {
        okhttp3.Call localVarCall = deleteV2ValidateBeforeCall(deleteFilesV2QueryInput, null);
        Type localVarReturnType = new TypeToken<GenericSuccessResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call deleteV2Async(DeleteFilesV2QueryInput deleteFilesV2QueryInput, final ApiCallback<GenericSuccessResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = deleteV2ValidateBeforeCall(deleteFilesV2QueryInput, _callback);
        Type localVarReturnType = new TypeToken<GenericSuccessResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class DeleteV2RequestBuilder {
        private OrganizationUserFilesToSyncFilters filters;
        private Boolean sendWebhook;

        private DeleteV2RequestBuilder() {
        }

        /**
         * Set filters
         * @param filters  (optional)
         * @return DeleteV2RequestBuilder
         */
        public DeleteV2RequestBuilder filters(OrganizationUserFilesToSyncFilters filters) {
            this.filters = filters;
            return this;
        }
        
        /**
         * Set sendWebhook
         * @param sendWebhook  (optional, default to false)
         * @return DeleteV2RequestBuilder
         */
        public DeleteV2RequestBuilder sendWebhook(Boolean sendWebhook) {
            this.sendWebhook = sendWebhook;
            return this;
        }
        
        /**
         * Build call for deleteV2
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            DeleteFilesV2QueryInput deleteFilesV2QueryInput = buildBodyParams();
            return deleteV2Call(deleteFilesV2QueryInput, _callback);
        }

        private DeleteFilesV2QueryInput buildBodyParams() {
            DeleteFilesV2QueryInput deleteFilesV2QueryInput = new DeleteFilesV2QueryInput();
            deleteFilesV2QueryInput.filters(this.filters);
            deleteFilesV2QueryInput.sendWebhook(this.sendWebhook);
            return deleteFilesV2QueryInput;
        }

        /**
         * Execute deleteV2 request
         * @return GenericSuccessResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public GenericSuccessResponse execute() throws ApiException {
            DeleteFilesV2QueryInput deleteFilesV2QueryInput = buildBodyParams();
            ApiResponse<GenericSuccessResponse> localVarResp = deleteV2WithHttpInfo(deleteFilesV2QueryInput);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute deleteV2 request with HTTP info returned
         * @return ApiResponse&lt;GenericSuccessResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<GenericSuccessResponse> executeWithHttpInfo() throws ApiException {
            DeleteFilesV2QueryInput deleteFilesV2QueryInput = buildBodyParams();
            return deleteV2WithHttpInfo(deleteFilesV2QueryInput);
        }

        /**
         * Execute deleteV2 request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<GenericSuccessResponse> _callback) throws ApiException {
            DeleteFilesV2QueryInput deleteFilesV2QueryInput = buildBodyParams();
            return deleteV2Async(deleteFilesV2QueryInput, _callback);
        }
    }

    /**
     * Delete Files V2 Endpoint
     * 
     * @param deleteFilesV2QueryInput  (required)
     * @return DeleteV2RequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
     </table>
     */
    public DeleteV2RequestBuilder deleteV2() throws IllegalArgumentException {
        return new DeleteV2RequestBuilder();
    }
    private okhttp3.Call getParsedFileCall(Integer fileId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/parsed_file/{file_id}"
            .replace("{" + "file_id" + "}", localVarApiClient.escapeString(fileId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "accessToken", "apiKey", "customerId" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @Deprecated
    @SuppressWarnings("rawtypes")
    private okhttp3.Call getParsedFileValidateBeforeCall(Integer fileId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'fileId' is set
        if (fileId == null) {
            throw new ApiException("Missing the required parameter 'fileId' when calling getParsedFile(Async)");
        }

        return getParsedFileCall(fileId, _callback);

    }


    private ApiResponse<PresignedURLResponse> getParsedFileWithHttpInfo(Integer fileId) throws ApiException {
        okhttp3.Call localVarCall = getParsedFileValidateBeforeCall(fileId, null);
        Type localVarReturnType = new TypeToken<PresignedURLResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getParsedFileAsync(Integer fileId, final ApiCallback<PresignedURLResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getParsedFileValidateBeforeCall(fileId, _callback);
        Type localVarReturnType = new TypeToken<PresignedURLResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class GetParsedFileRequestBuilder {
        private final Integer fileId;

        private GetParsedFileRequestBuilder(Integer fileId) {
            this.fileId = fileId;
        }

        /**
         * Build call for getParsedFile
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         * @deprecated
         */
        @Deprecated
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getParsedFileCall(fileId, _callback);
        }


        /**
         * Execute getParsedFile request
         * @return PresignedURLResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         * @deprecated
         */
        @Deprecated
        public PresignedURLResponse execute() throws ApiException {
            ApiResponse<PresignedURLResponse> localVarResp = getParsedFileWithHttpInfo(fileId);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute getParsedFile request with HTTP info returned
         * @return ApiResponse&lt;PresignedURLResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         * @deprecated
         */
        @Deprecated
        public ApiResponse<PresignedURLResponse> executeWithHttpInfo() throws ApiException {
            return getParsedFileWithHttpInfo(fileId);
        }

        /**
         * Execute getParsedFile request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         * @deprecated
         */
        @Deprecated
        public okhttp3.Call executeAsync(final ApiCallback<PresignedURLResponse> _callback) throws ApiException {
            return getParsedFileAsync(fileId, _callback);
        }
    }

    /**
     * Parsed File
     * This route is deprecated. Use &#x60;/user_files_v2&#x60; instead.
     * @param fileId  (required)
     * @return GetParsedFileRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
     </table>
     * @deprecated
     */
    @Deprecated
    public GetParsedFileRequestBuilder getParsedFile(Integer fileId) throws IllegalArgumentException {
        if (fileId == null) throw new IllegalArgumentException("\"fileId\" is required but got null");
        return new GetParsedFileRequestBuilder(fileId);
    }
    private okhttp3.Call getRawFileCall(Integer fileId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/raw_file/{file_id}"
            .replace("{" + "file_id" + "}", localVarApiClient.escapeString(fileId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "accessToken", "apiKey", "customerId" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @Deprecated
    @SuppressWarnings("rawtypes")
    private okhttp3.Call getRawFileValidateBeforeCall(Integer fileId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'fileId' is set
        if (fileId == null) {
            throw new ApiException("Missing the required parameter 'fileId' when calling getRawFile(Async)");
        }

        return getRawFileCall(fileId, _callback);

    }


    private ApiResponse<PresignedURLResponse> getRawFileWithHttpInfo(Integer fileId) throws ApiException {
        okhttp3.Call localVarCall = getRawFileValidateBeforeCall(fileId, null);
        Type localVarReturnType = new TypeToken<PresignedURLResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getRawFileAsync(Integer fileId, final ApiCallback<PresignedURLResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getRawFileValidateBeforeCall(fileId, _callback);
        Type localVarReturnType = new TypeToken<PresignedURLResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class GetRawFileRequestBuilder {
        private final Integer fileId;

        private GetRawFileRequestBuilder(Integer fileId) {
            this.fileId = fileId;
        }

        /**
         * Build call for getRawFile
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         * @deprecated
         */
        @Deprecated
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getRawFileCall(fileId, _callback);
        }


        /**
         * Execute getRawFile request
         * @return PresignedURLResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         * @deprecated
         */
        @Deprecated
        public PresignedURLResponse execute() throws ApiException {
            ApiResponse<PresignedURLResponse> localVarResp = getRawFileWithHttpInfo(fileId);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute getRawFile request with HTTP info returned
         * @return ApiResponse&lt;PresignedURLResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         * @deprecated
         */
        @Deprecated
        public ApiResponse<PresignedURLResponse> executeWithHttpInfo() throws ApiException {
            return getRawFileWithHttpInfo(fileId);
        }

        /**
         * Execute getRawFile request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         * @deprecated
         */
        @Deprecated
        public okhttp3.Call executeAsync(final ApiCallback<PresignedURLResponse> _callback) throws ApiException {
            return getRawFileAsync(fileId, _callback);
        }
    }

    /**
     * Raw File
     * This route is deprecated. Use &#x60;/user_files_v2&#x60; instead.
     * @param fileId  (required)
     * @return GetRawFileRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
     </table>
     * @deprecated
     */
    @Deprecated
    public GetRawFileRequestBuilder getRawFile(Integer fileId) throws IllegalArgumentException {
        if (fileId == null) throw new IllegalArgumentException("\"fileId\" is required but got null");
        return new GetRawFileRequestBuilder(fileId);
    }
    private okhttp3.Call queryUserFilesCall(OrganizationUserFilesToSyncQueryInput organizationUserFilesToSyncQueryInput, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = organizationUserFilesToSyncQueryInput;

        // create path and map variables
        String localVarPath = "/user_files_v2";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "accessToken", "apiKey", "customerId" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call queryUserFilesValidateBeforeCall(OrganizationUserFilesToSyncQueryInput organizationUserFilesToSyncQueryInput, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'organizationUserFilesToSyncQueryInput' is set
        if (organizationUserFilesToSyncQueryInput == null) {
            throw new ApiException("Missing the required parameter 'organizationUserFilesToSyncQueryInput' when calling queryUserFiles(Async)");
        }

        return queryUserFilesCall(organizationUserFilesToSyncQueryInput, _callback);

    }


    private ApiResponse<UserFilesV2> queryUserFilesWithHttpInfo(OrganizationUserFilesToSyncQueryInput organizationUserFilesToSyncQueryInput) throws ApiException {
        okhttp3.Call localVarCall = queryUserFilesValidateBeforeCall(organizationUserFilesToSyncQueryInput, null);
        Type localVarReturnType = new TypeToken<UserFilesV2>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call queryUserFilesAsync(OrganizationUserFilesToSyncQueryInput organizationUserFilesToSyncQueryInput, final ApiCallback<UserFilesV2> _callback) throws ApiException {

        okhttp3.Call localVarCall = queryUserFilesValidateBeforeCall(organizationUserFilesToSyncQueryInput, _callback);
        Type localVarReturnType = new TypeToken<UserFilesV2>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class QueryUserFilesRequestBuilder {
        private Pagination pagination;
        private OrganizationUserFilesToSyncOrderByTypes orderBy;
        private OrderDir orderDir;
        private OrganizationUserFilesToSyncFilters filters;
        private Boolean includeRawFile;
        private Boolean includeParsedTextFile;
        private Boolean includeAdditionalFiles;

        private QueryUserFilesRequestBuilder() {
        }

        /**
         * Set pagination
         * @param pagination  (optional)
         * @return QueryUserFilesRequestBuilder
         */
        public QueryUserFilesRequestBuilder pagination(Pagination pagination) {
            this.pagination = pagination;
            return this;
        }
        
        /**
         * Set orderBy
         * @param orderBy  (optional)
         * @return QueryUserFilesRequestBuilder
         */
        public QueryUserFilesRequestBuilder orderBy(OrganizationUserFilesToSyncOrderByTypes orderBy) {
            this.orderBy = orderBy;
            return this;
        }
        
        /**
         * Set orderDir
         * @param orderDir  (optional)
         * @return QueryUserFilesRequestBuilder
         */
        public QueryUserFilesRequestBuilder orderDir(OrderDir orderDir) {
            this.orderDir = orderDir;
            return this;
        }
        
        /**
         * Set filters
         * @param filters  (optional)
         * @return QueryUserFilesRequestBuilder
         */
        public QueryUserFilesRequestBuilder filters(OrganizationUserFilesToSyncFilters filters) {
            this.filters = filters;
            return this;
        }
        
        /**
         * Set includeRawFile
         * @param includeRawFile  (optional)
         * @return QueryUserFilesRequestBuilder
         */
        public QueryUserFilesRequestBuilder includeRawFile(Boolean includeRawFile) {
            this.includeRawFile = includeRawFile;
            return this;
        }
        
        /**
         * Set includeParsedTextFile
         * @param includeParsedTextFile  (optional)
         * @return QueryUserFilesRequestBuilder
         */
        public QueryUserFilesRequestBuilder includeParsedTextFile(Boolean includeParsedTextFile) {
            this.includeParsedTextFile = includeParsedTextFile;
            return this;
        }
        
        /**
         * Set includeAdditionalFiles
         * @param includeAdditionalFiles  (optional)
         * @return QueryUserFilesRequestBuilder
         */
        public QueryUserFilesRequestBuilder includeAdditionalFiles(Boolean includeAdditionalFiles) {
            this.includeAdditionalFiles = includeAdditionalFiles;
            return this;
        }
        
        /**
         * Build call for queryUserFiles
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            OrganizationUserFilesToSyncQueryInput organizationUserFilesToSyncQueryInput = buildBodyParams();
            return queryUserFilesCall(organizationUserFilesToSyncQueryInput, _callback);
        }

        private OrganizationUserFilesToSyncQueryInput buildBodyParams() {
            OrganizationUserFilesToSyncQueryInput organizationUserFilesToSyncQueryInput = new OrganizationUserFilesToSyncQueryInput();
            organizationUserFilesToSyncQueryInput.pagination(this.pagination);
            organizationUserFilesToSyncQueryInput.orderBy(this.orderBy);
            organizationUserFilesToSyncQueryInput.orderDir(this.orderDir);
            organizationUserFilesToSyncQueryInput.filters(this.filters);
            organizationUserFilesToSyncQueryInput.includeRawFile(this.includeRawFile);
            organizationUserFilesToSyncQueryInput.includeParsedTextFile(this.includeParsedTextFile);
            organizationUserFilesToSyncQueryInput.includeAdditionalFiles(this.includeAdditionalFiles);
            return organizationUserFilesToSyncQueryInput;
        }

        /**
         * Execute queryUserFiles request
         * @return UserFilesV2
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public UserFilesV2 execute() throws ApiException {
            OrganizationUserFilesToSyncQueryInput organizationUserFilesToSyncQueryInput = buildBodyParams();
            ApiResponse<UserFilesV2> localVarResp = queryUserFilesWithHttpInfo(organizationUserFilesToSyncQueryInput);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute queryUserFiles request with HTTP info returned
         * @return ApiResponse&lt;UserFilesV2&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<UserFilesV2> executeWithHttpInfo() throws ApiException {
            OrganizationUserFilesToSyncQueryInput organizationUserFilesToSyncQueryInput = buildBodyParams();
            return queryUserFilesWithHttpInfo(organizationUserFilesToSyncQueryInput);
        }

        /**
         * Execute queryUserFiles request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<UserFilesV2> _callback) throws ApiException {
            OrganizationUserFilesToSyncQueryInput organizationUserFilesToSyncQueryInput = buildBodyParams();
            return queryUserFilesAsync(organizationUserFilesToSyncQueryInput, _callback);
        }
    }

    /**
     * User Files V2
     * For pre-filtering documents, using &#x60;tags_v2&#x60; is preferred to using &#x60;tags&#x60; (which is now deprecated). If both &#x60;tags_v2&#x60; and &#x60;tags&#x60; are specified, &#x60;tags&#x60; is ignored. &#x60;tags_v2&#x60; enables building complex filters through the use of \&quot;AND\&quot;, \&quot;OR\&quot;, and negation logic. Take the below input as an example: &#x60;&#x60;&#x60;json {     \&quot;OR\&quot;: [         {             \&quot;key\&quot;: \&quot;subject\&quot;,             \&quot;value\&quot;: \&quot;holy-bible\&quot;,             \&quot;negate\&quot;: false         },         {             \&quot;key\&quot;: \&quot;person-of-interest\&quot;,             \&quot;value\&quot;: \&quot;jesus christ\&quot;,             \&quot;negate\&quot;: false         },         {             \&quot;key\&quot;: \&quot;genre\&quot;,             \&quot;value\&quot;: \&quot;religion\&quot;,             \&quot;negate\&quot;: true         }         {             \&quot;AND\&quot;: [                 {                     \&quot;key\&quot;: \&quot;subject\&quot;,                     \&quot;value\&quot;: \&quot;tao-te-ching\&quot;,                     \&quot;negate\&quot;: false                 },                 {                     \&quot;key\&quot;: \&quot;author\&quot;,                     \&quot;value\&quot;: \&quot;lao-tzu\&quot;,                     \&quot;negate\&quot;: false                 }             ]         }     ] } &#x60;&#x60;&#x60; In this case, files will be filtered such that: 1. \&quot;subject\&quot; &#x3D; \&quot;holy-bible\&quot; OR 2. \&quot;person-of-interest\&quot; &#x3D; \&quot;jesus christ\&quot; OR 3. \&quot;genre\&quot; !&#x3D; \&quot;religion\&quot; OR 4. \&quot;subject\&quot; &#x3D; \&quot;tao-te-ching\&quot; AND \&quot;author\&quot; &#x3D; \&quot;lao-tzu\&quot;  Note that the top level of the query must be either an \&quot;OR\&quot; or \&quot;AND\&quot; array. Currently, nesting is limited to 3. For tag blocks (those with \&quot;key\&quot;, \&quot;value\&quot;, and \&quot;negate\&quot; keys), the following typing rules apply: 1. \&quot;key\&quot; isn&#39;t optional and must be a &#x60;string&#x60; 2. \&quot;value\&quot; isn&#39;t optional and can be &#x60;any&#x60; or list[&#x60;any&#x60;] 3. \&quot;negate\&quot; is optional and must be &#x60;true&#x60; or &#x60;false&#x60;. If present and &#x60;true&#x60;, then the filter block is negated in the resulting query. It is &#x60;false&#x60; by default.
     * @param organizationUserFilesToSyncQueryInput  (required)
     * @return QueryUserFilesRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
     </table>
     */
    public QueryUserFilesRequestBuilder queryUserFiles() throws IllegalArgumentException {
        return new QueryUserFilesRequestBuilder();
    }
    private okhttp3.Call queryUserFilesDeprecatedCall(OrganizationUserFilesToSyncQueryInput organizationUserFilesToSyncQueryInput, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = organizationUserFilesToSyncQueryInput;

        // create path and map variables
        String localVarPath = "/user_files";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "accessToken", "apiKey", "customerId" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @Deprecated
    @SuppressWarnings("rawtypes")
    private okhttp3.Call queryUserFilesDeprecatedValidateBeforeCall(OrganizationUserFilesToSyncQueryInput organizationUserFilesToSyncQueryInput, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'organizationUserFilesToSyncQueryInput' is set
        if (organizationUserFilesToSyncQueryInput == null) {
            throw new ApiException("Missing the required parameter 'organizationUserFilesToSyncQueryInput' when calling queryUserFilesDeprecated(Async)");
        }

        return queryUserFilesDeprecatedCall(organizationUserFilesToSyncQueryInput, _callback);

    }


    private ApiResponse<List<UserFile>> queryUserFilesDeprecatedWithHttpInfo(OrganizationUserFilesToSyncQueryInput organizationUserFilesToSyncQueryInput) throws ApiException {
        okhttp3.Call localVarCall = queryUserFilesDeprecatedValidateBeforeCall(organizationUserFilesToSyncQueryInput, null);
        Type localVarReturnType = new TypeToken<List<UserFile>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call queryUserFilesDeprecatedAsync(OrganizationUserFilesToSyncQueryInput organizationUserFilesToSyncQueryInput, final ApiCallback<List<UserFile>> _callback) throws ApiException {

        okhttp3.Call localVarCall = queryUserFilesDeprecatedValidateBeforeCall(organizationUserFilesToSyncQueryInput, _callback);
        Type localVarReturnType = new TypeToken<List<UserFile>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class QueryUserFilesDeprecatedRequestBuilder {
        private Pagination pagination;
        private OrganizationUserFilesToSyncOrderByTypes orderBy;
        private OrderDir orderDir;
        private OrganizationUserFilesToSyncFilters filters;
        private Boolean includeRawFile;
        private Boolean includeParsedTextFile;
        private Boolean includeAdditionalFiles;

        private QueryUserFilesDeprecatedRequestBuilder() {
        }

        /**
         * Set pagination
         * @param pagination  (optional)
         * @return QueryUserFilesDeprecatedRequestBuilder
         */
        public QueryUserFilesDeprecatedRequestBuilder pagination(Pagination pagination) {
            this.pagination = pagination;
            return this;
        }
        
        /**
         * Set orderBy
         * @param orderBy  (optional)
         * @return QueryUserFilesDeprecatedRequestBuilder
         */
        public QueryUserFilesDeprecatedRequestBuilder orderBy(OrganizationUserFilesToSyncOrderByTypes orderBy) {
            this.orderBy = orderBy;
            return this;
        }
        
        /**
         * Set orderDir
         * @param orderDir  (optional)
         * @return QueryUserFilesDeprecatedRequestBuilder
         */
        public QueryUserFilesDeprecatedRequestBuilder orderDir(OrderDir orderDir) {
            this.orderDir = orderDir;
            return this;
        }
        
        /**
         * Set filters
         * @param filters  (optional)
         * @return QueryUserFilesDeprecatedRequestBuilder
         */
        public QueryUserFilesDeprecatedRequestBuilder filters(OrganizationUserFilesToSyncFilters filters) {
            this.filters = filters;
            return this;
        }
        
        /**
         * Set includeRawFile
         * @param includeRawFile  (optional)
         * @return QueryUserFilesDeprecatedRequestBuilder
         */
        public QueryUserFilesDeprecatedRequestBuilder includeRawFile(Boolean includeRawFile) {
            this.includeRawFile = includeRawFile;
            return this;
        }
        
        /**
         * Set includeParsedTextFile
         * @param includeParsedTextFile  (optional)
         * @return QueryUserFilesDeprecatedRequestBuilder
         */
        public QueryUserFilesDeprecatedRequestBuilder includeParsedTextFile(Boolean includeParsedTextFile) {
            this.includeParsedTextFile = includeParsedTextFile;
            return this;
        }
        
        /**
         * Set includeAdditionalFiles
         * @param includeAdditionalFiles  (optional)
         * @return QueryUserFilesDeprecatedRequestBuilder
         */
        public QueryUserFilesDeprecatedRequestBuilder includeAdditionalFiles(Boolean includeAdditionalFiles) {
            this.includeAdditionalFiles = includeAdditionalFiles;
            return this;
        }
        
        /**
         * Build call for queryUserFilesDeprecated
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         * @deprecated
         */
        @Deprecated
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            OrganizationUserFilesToSyncQueryInput organizationUserFilesToSyncQueryInput = buildBodyParams();
            return queryUserFilesDeprecatedCall(organizationUserFilesToSyncQueryInput, _callback);
        }

        private OrganizationUserFilesToSyncQueryInput buildBodyParams() {
            OrganizationUserFilesToSyncQueryInput organizationUserFilesToSyncQueryInput = new OrganizationUserFilesToSyncQueryInput();
            organizationUserFilesToSyncQueryInput.pagination(this.pagination);
            organizationUserFilesToSyncQueryInput.orderBy(this.orderBy);
            organizationUserFilesToSyncQueryInput.orderDir(this.orderDir);
            organizationUserFilesToSyncQueryInput.filters(this.filters);
            organizationUserFilesToSyncQueryInput.includeRawFile(this.includeRawFile);
            organizationUserFilesToSyncQueryInput.includeParsedTextFile(this.includeParsedTextFile);
            organizationUserFilesToSyncQueryInput.includeAdditionalFiles(this.includeAdditionalFiles);
            return organizationUserFilesToSyncQueryInput;
        }

        /**
         * Execute queryUserFilesDeprecated request
         * @return List&lt;UserFile&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         * @deprecated
         */
        @Deprecated
        public List<UserFile> execute() throws ApiException {
            OrganizationUserFilesToSyncQueryInput organizationUserFilesToSyncQueryInput = buildBodyParams();
            ApiResponse<List<UserFile>> localVarResp = queryUserFilesDeprecatedWithHttpInfo(organizationUserFilesToSyncQueryInput);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute queryUserFilesDeprecated request with HTTP info returned
         * @return ApiResponse&lt;List&lt;UserFile&gt;&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         * @deprecated
         */
        @Deprecated
        public ApiResponse<List<UserFile>> executeWithHttpInfo() throws ApiException {
            OrganizationUserFilesToSyncQueryInput organizationUserFilesToSyncQueryInput = buildBodyParams();
            return queryUserFilesDeprecatedWithHttpInfo(organizationUserFilesToSyncQueryInput);
        }

        /**
         * Execute queryUserFilesDeprecated request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         * @deprecated
         */
        @Deprecated
        public okhttp3.Call executeAsync(final ApiCallback<List<UserFile>> _callback) throws ApiException {
            OrganizationUserFilesToSyncQueryInput organizationUserFilesToSyncQueryInput = buildBodyParams();
            return queryUserFilesDeprecatedAsync(organizationUserFilesToSyncQueryInput, _callback);
        }
    }

    /**
     * User Files
     * This route is deprecated. Use &#x60;/user_files_v2&#x60; instead.
     * @param organizationUserFilesToSyncQueryInput  (required)
     * @return QueryUserFilesDeprecatedRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
     </table>
     * @deprecated
     */
    @Deprecated
    public QueryUserFilesDeprecatedRequestBuilder queryUserFilesDeprecated() throws IllegalArgumentException {
        return new QueryUserFilesDeprecatedRequestBuilder();
    }
    private okhttp3.Call resyncCall(ResyncFileQueryInput resyncFileQueryInput, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = resyncFileQueryInput;

        // create path and map variables
        String localVarPath = "/resync_file";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "accessToken", "apiKey", "customerId" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call resyncValidateBeforeCall(ResyncFileQueryInput resyncFileQueryInput, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'resyncFileQueryInput' is set
        if (resyncFileQueryInput == null) {
            throw new ApiException("Missing the required parameter 'resyncFileQueryInput' when calling resync(Async)");
        }

        return resyncCall(resyncFileQueryInput, _callback);

    }


    private ApiResponse<UserFile> resyncWithHttpInfo(ResyncFileQueryInput resyncFileQueryInput) throws ApiException {
        okhttp3.Call localVarCall = resyncValidateBeforeCall(resyncFileQueryInput, null);
        Type localVarReturnType = new TypeToken<UserFile>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call resyncAsync(ResyncFileQueryInput resyncFileQueryInput, final ApiCallback<UserFile> _callback) throws ApiException {

        okhttp3.Call localVarCall = resyncValidateBeforeCall(resyncFileQueryInput, _callback);
        Type localVarReturnType = new TypeToken<UserFile>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class ResyncRequestBuilder {
        private final Integer fileId;
        private Integer chunkSize;
        private Integer chunkOverlap;
        private Boolean forceEmbeddingGeneration;

        private ResyncRequestBuilder(Integer fileId) {
            this.fileId = fileId;
        }

        /**
         * Set chunkSize
         * @param chunkSize  (optional)
         * @return ResyncRequestBuilder
         */
        public ResyncRequestBuilder chunkSize(Integer chunkSize) {
            this.chunkSize = chunkSize;
            return this;
        }
        
        /**
         * Set chunkOverlap
         * @param chunkOverlap  (optional)
         * @return ResyncRequestBuilder
         */
        public ResyncRequestBuilder chunkOverlap(Integer chunkOverlap) {
            this.chunkOverlap = chunkOverlap;
            return this;
        }
        
        /**
         * Set forceEmbeddingGeneration
         * @param forceEmbeddingGeneration  (optional, default to false)
         * @return ResyncRequestBuilder
         */
        public ResyncRequestBuilder forceEmbeddingGeneration(Boolean forceEmbeddingGeneration) {
            this.forceEmbeddingGeneration = forceEmbeddingGeneration;
            return this;
        }
        
        /**
         * Build call for resync
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            ResyncFileQueryInput resyncFileQueryInput = buildBodyParams();
            return resyncCall(resyncFileQueryInput, _callback);
        }

        private ResyncFileQueryInput buildBodyParams() {
            ResyncFileQueryInput resyncFileQueryInput = new ResyncFileQueryInput();
            resyncFileQueryInput.fileId(this.fileId);
            resyncFileQueryInput.chunkSize(this.chunkSize);
            resyncFileQueryInput.chunkOverlap(this.chunkOverlap);
            resyncFileQueryInput.forceEmbeddingGeneration(this.forceEmbeddingGeneration);
            return resyncFileQueryInput;
        }

        /**
         * Execute resync request
         * @return UserFile
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public UserFile execute() throws ApiException {
            ResyncFileQueryInput resyncFileQueryInput = buildBodyParams();
            ApiResponse<UserFile> localVarResp = resyncWithHttpInfo(resyncFileQueryInput);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute resync request with HTTP info returned
         * @return ApiResponse&lt;UserFile&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<UserFile> executeWithHttpInfo() throws ApiException {
            ResyncFileQueryInput resyncFileQueryInput = buildBodyParams();
            return resyncWithHttpInfo(resyncFileQueryInput);
        }

        /**
         * Execute resync request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<UserFile> _callback) throws ApiException {
            ResyncFileQueryInput resyncFileQueryInput = buildBodyParams();
            return resyncAsync(resyncFileQueryInput, _callback);
        }
    }

    /**
     * Resync File
     * 
     * @param resyncFileQueryInput  (required)
     * @return ResyncRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
     </table>
     */
    public ResyncRequestBuilder resync(Integer fileId) throws IllegalArgumentException {
        if (fileId == null) throw new IllegalArgumentException("\"fileId\" is required but got null");
        return new ResyncRequestBuilder(fileId);
    }
    private okhttp3.Call uploadCall(File _file, BodyCreateUploadFileUploadfilePost bodyCreateUploadFileUploadfilePost, Integer chunkSize, Integer chunkOverlap, Boolean skipEmbeddingGeneration, Boolean setPageAsBoundary, TMEmbeddingGenerators embeddingModel, Boolean useOcr, Boolean generateSparseVectors, Boolean prependFilenameToChunks, Integer maxItemsPerChunk, Boolean parsePdfTablesWithOcr, Boolean detectAudioLanguage, FileContentTypesNullable mediaType, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = bodyCreateUploadFileUploadfilePost;

        // create path and map variables
        String localVarPath = "/uploadfile";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (_file != null) {
            localVarFormParams.put("file", _file);
        }

        if (chunkSize != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("chunk_size", chunkSize));
        }

        if (chunkOverlap != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("chunk_overlap", chunkOverlap));
        }

        if (skipEmbeddingGeneration != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("skip_embedding_generation", skipEmbeddingGeneration));
        }

        if (setPageAsBoundary != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("set_page_as_boundary", setPageAsBoundary));
        }

        if (embeddingModel != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("embedding_model", embeddingModel));
        }

        if (useOcr != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("use_ocr", useOcr));
        }

        if (generateSparseVectors != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("generate_sparse_vectors", generateSparseVectors));
        }

        if (prependFilenameToChunks != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("prepend_filename_to_chunks", prependFilenameToChunks));
        }

        if (maxItemsPerChunk != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("max_items_per_chunk", maxItemsPerChunk));
        }

        if (parsePdfTablesWithOcr != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("parse_pdf_tables_with_ocr", parsePdfTablesWithOcr));
        }

        if (detectAudioLanguage != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("detect_audio_language", detectAudioLanguage));
        }

        if (mediaType != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("media_type", mediaType));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "multipart/form-data"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "accessToken", "apiKey", "customerId" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call uploadValidateBeforeCall(File _file, BodyCreateUploadFileUploadfilePost bodyCreateUploadFileUploadfilePost, Integer chunkSize, Integer chunkOverlap, Boolean skipEmbeddingGeneration, Boolean setPageAsBoundary, TMEmbeddingGenerators embeddingModel, Boolean useOcr, Boolean generateSparseVectors, Boolean prependFilenameToChunks, Integer maxItemsPerChunk, Boolean parsePdfTablesWithOcr, Boolean detectAudioLanguage, FileContentTypesNullable mediaType, final ApiCallback _callback) throws ApiException {
        // verify the required parameter '_file' is set
        if (_file == null) {
            throw new ApiException("Missing the required parameter '_file' when calling upload(Async)");
        }

        // verify the required parameter 'bodyCreateUploadFileUploadfilePost' is set
        if (bodyCreateUploadFileUploadfilePost == null) {
            throw new ApiException("Missing the required parameter 'bodyCreateUploadFileUploadfilePost' when calling upload(Async)");
        }

        return uploadCall(_file, bodyCreateUploadFileUploadfilePost, chunkSize, chunkOverlap, skipEmbeddingGeneration, setPageAsBoundary, embeddingModel, useOcr, generateSparseVectors, prependFilenameToChunks, maxItemsPerChunk, parsePdfTablesWithOcr, detectAudioLanguage, mediaType, _callback);

    }


    private ApiResponse<UserFile> uploadWithHttpInfo(File _file, BodyCreateUploadFileUploadfilePost bodyCreateUploadFileUploadfilePost, Integer chunkSize, Integer chunkOverlap, Boolean skipEmbeddingGeneration, Boolean setPageAsBoundary, TMEmbeddingGenerators embeddingModel, Boolean useOcr, Boolean generateSparseVectors, Boolean prependFilenameToChunks, Integer maxItemsPerChunk, Boolean parsePdfTablesWithOcr, Boolean detectAudioLanguage, FileContentTypesNullable mediaType) throws ApiException {
        okhttp3.Call localVarCall = uploadValidateBeforeCall(_file, bodyCreateUploadFileUploadfilePost, chunkSize, chunkOverlap, skipEmbeddingGeneration, setPageAsBoundary, embeddingModel, useOcr, generateSparseVectors, prependFilenameToChunks, maxItemsPerChunk, parsePdfTablesWithOcr, detectAudioLanguage, mediaType, null);
        Type localVarReturnType = new TypeToken<UserFile>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call uploadAsync(File _file, BodyCreateUploadFileUploadfilePost bodyCreateUploadFileUploadfilePost, Integer chunkSize, Integer chunkOverlap, Boolean skipEmbeddingGeneration, Boolean setPageAsBoundary, TMEmbeddingGenerators embeddingModel, Boolean useOcr, Boolean generateSparseVectors, Boolean prependFilenameToChunks, Integer maxItemsPerChunk, Boolean parsePdfTablesWithOcr, Boolean detectAudioLanguage, FileContentTypesNullable mediaType, final ApiCallback<UserFile> _callback) throws ApiException {

        okhttp3.Call localVarCall = uploadValidateBeforeCall(_file, bodyCreateUploadFileUploadfilePost, chunkSize, chunkOverlap, skipEmbeddingGeneration, setPageAsBoundary, embeddingModel, useOcr, generateSparseVectors, prependFilenameToChunks, maxItemsPerChunk, parsePdfTablesWithOcr, detectAudioLanguage, mediaType, _callback);
        Type localVarReturnType = new TypeToken<UserFile>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class UploadRequestBuilder {
        private final File _file;
        private Integer chunkSize;
        private Integer chunkOverlap;
        private Boolean skipEmbeddingGeneration;
        private Boolean setPageAsBoundary;
        private TMEmbeddingGenerators embeddingModel;
        private Boolean useOcr;
        private Boolean generateSparseVectors;
        private Boolean prependFilenameToChunks;
        private Integer maxItemsPerChunk;
        private Boolean parsePdfTablesWithOcr;
        private Boolean detectAudioLanguage;
        private FileContentTypesNullable mediaType;

        private UploadRequestBuilder(File _file) {
            this._file = _file;
        }

        /**
         * Set chunkSize
         * @param chunkSize Chunk size in tiktoken tokens to be used when processing file. (optional)
         * @return UploadRequestBuilder
         */
        public UploadRequestBuilder chunkSize(Integer chunkSize) {
            this.chunkSize = chunkSize;
            return this;
        }
        
        /**
         * Set chunkOverlap
         * @param chunkOverlap Chunk overlap in tiktoken tokens to be used when processing file. (optional)
         * @return UploadRequestBuilder
         */
        public UploadRequestBuilder chunkOverlap(Integer chunkOverlap) {
            this.chunkOverlap = chunkOverlap;
            return this;
        }
        
        /**
         * Set skipEmbeddingGeneration
         * @param skipEmbeddingGeneration Flag to control whether or not embeddings should be generated and stored             when processing file. (optional, default to false)
         * @return UploadRequestBuilder
         */
        public UploadRequestBuilder skipEmbeddingGeneration(Boolean skipEmbeddingGeneration) {
            this.skipEmbeddingGeneration = skipEmbeddingGeneration;
            return this;
        }
        
        /**
         * Set setPageAsBoundary
         * @param setPageAsBoundary Flag to control whether or not to set the a page&#39;s worth of content as the maximum             amount of content that can appear in a chunk. Only valid for PDFs. See description route description for             more information. (optional, default to false)
         * @return UploadRequestBuilder
         */
        public UploadRequestBuilder setPageAsBoundary(Boolean setPageAsBoundary) {
            this.setPageAsBoundary = setPageAsBoundary;
            return this;
        }
        
        /**
         * Set embeddingModel
         * @param embeddingModel Embedding model that will be used to embed file chunks. (optional)
         * @return UploadRequestBuilder
         */
        public UploadRequestBuilder embeddingModel(TMEmbeddingGenerators embeddingModel) {
            this.embeddingModel = embeddingModel;
            return this;
        }
        
        /**
         * Set useOcr
         * @param useOcr Whether or not to use OCR when processing files. Only valid for PDFs. Useful for documents with             tables, images, and/or scanned text. (optional, default to false)
         * @return UploadRequestBuilder
         */
        public UploadRequestBuilder useOcr(Boolean useOcr) {
            this.useOcr = useOcr;
            return this;
        }
        
        /**
         * Set generateSparseVectors
         * @param generateSparseVectors Whether or not to generate sparse vectors for the file. This is *required* for the file to be a             candidate for hybrid search. (optional, default to false)
         * @return UploadRequestBuilder
         */
        public UploadRequestBuilder generateSparseVectors(Boolean generateSparseVectors) {
            this.generateSparseVectors = generateSparseVectors;
            return this;
        }
        
        /**
         * Set prependFilenameToChunks
         * @param prependFilenameToChunks Whether or not to prepend the file&#39;s name to chunks. (optional, default to false)
         * @return UploadRequestBuilder
         */
        public UploadRequestBuilder prependFilenameToChunks(Boolean prependFilenameToChunks) {
            this.prependFilenameToChunks = prependFilenameToChunks;
            return this;
        }
        
        /**
         * Set maxItemsPerChunk
         * @param maxItemsPerChunk Number of objects per chunk. For csv, tsv, xlsx, and json files only. (optional)
         * @return UploadRequestBuilder
         */
        public UploadRequestBuilder maxItemsPerChunk(Integer maxItemsPerChunk) {
            this.maxItemsPerChunk = maxItemsPerChunk;
            return this;
        }
        
        /**
         * Set parsePdfTablesWithOcr
         * @param parsePdfTablesWithOcr Whether to use rich table parsing when &#x60;use_ocr&#x60; is enabled. (optional, default to false)
         * @return UploadRequestBuilder
         */
        public UploadRequestBuilder parsePdfTablesWithOcr(Boolean parsePdfTablesWithOcr) {
            this.parsePdfTablesWithOcr = parsePdfTablesWithOcr;
            return this;
        }
        
        /**
         * Set detectAudioLanguage
         * @param detectAudioLanguage Whether to automatically detect the language of the uploaded audio file. (optional, default to false)
         * @return UploadRequestBuilder
         */
        public UploadRequestBuilder detectAudioLanguage(Boolean detectAudioLanguage) {
            this.detectAudioLanguage = detectAudioLanguage;
            return this;
        }
        
        /**
         * Set mediaType
         * @param mediaType The media type of the file. If not provided, it will be inferred from the file extension. (optional, default to TEXT)
         * @return UploadRequestBuilder
         */
        public UploadRequestBuilder mediaType(FileContentTypesNullable mediaType) {
            this.mediaType = mediaType;
            return this;
        }
        
        /**
         * Build call for upload
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            BodyCreateUploadFileUploadfilePost bodyCreateUploadFileUploadfilePost = buildBodyParams();
            return uploadCall(_file, bodyCreateUploadFileUploadfilePost, chunkSize, chunkOverlap, skipEmbeddingGeneration, setPageAsBoundary, embeddingModel, useOcr, generateSparseVectors, prependFilenameToChunks, maxItemsPerChunk, parsePdfTablesWithOcr, detectAudioLanguage, mediaType, _callback);
        }

        private BodyCreateUploadFileUploadfilePost buildBodyParams() {
            BodyCreateUploadFileUploadfilePost bodyCreateUploadFileUploadfilePost = new BodyCreateUploadFileUploadfilePost();
            bodyCreateUploadFileUploadfilePost._file(this._file);
            return bodyCreateUploadFileUploadfilePost;
        }

        /**
         * Execute upload request
         * @return UserFile
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public UserFile execute() throws ApiException {
            BodyCreateUploadFileUploadfilePost bodyCreateUploadFileUploadfilePost = buildBodyParams();
            ApiResponse<UserFile> localVarResp = uploadWithHttpInfo(_file, bodyCreateUploadFileUploadfilePost, chunkSize, chunkOverlap, skipEmbeddingGeneration, setPageAsBoundary, embeddingModel, useOcr, generateSparseVectors, prependFilenameToChunks, maxItemsPerChunk, parsePdfTablesWithOcr, detectAudioLanguage, mediaType);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute upload request with HTTP info returned
         * @return ApiResponse&lt;UserFile&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<UserFile> executeWithHttpInfo() throws ApiException {
            BodyCreateUploadFileUploadfilePost bodyCreateUploadFileUploadfilePost = buildBodyParams();
            return uploadWithHttpInfo(_file, bodyCreateUploadFileUploadfilePost, chunkSize, chunkOverlap, skipEmbeddingGeneration, setPageAsBoundary, embeddingModel, useOcr, generateSparseVectors, prependFilenameToChunks, maxItemsPerChunk, parsePdfTablesWithOcr, detectAudioLanguage, mediaType);
        }

        /**
         * Execute upload request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<UserFile> _callback) throws ApiException {
            BodyCreateUploadFileUploadfilePost bodyCreateUploadFileUploadfilePost = buildBodyParams();
            return uploadAsync(_file, bodyCreateUploadFileUploadfilePost, chunkSize, chunkOverlap, skipEmbeddingGeneration, setPageAsBoundary, embeddingModel, useOcr, generateSparseVectors, prependFilenameToChunks, maxItemsPerChunk, parsePdfTablesWithOcr, detectAudioLanguage, mediaType, _callback);
        }
    }

    /**
     * Create Upload File
     * This endpoint is used to directly upload local files to Carbon. The &#x60;POST&#x60; request should be a multipart form request. Note that the &#x60;set_page_as_boundary&#x60; query parameter is applicable only to PDFs for now. When this value is set, PDF chunks are at most one page long. Additional information can be retrieved for each chunk, however, namely the coordinates of the bounding box around the chunk (this can be used for things like text highlighting). Following is a description of all possible query parameters: - &#x60;chunk_size&#x60;: the chunk size (in tokens) applied when splitting the document - &#x60;chunk_overlap&#x60;: the chunk overlap (in tokens) applied when splitting the document - &#x60;skip_embedding_generation&#x60;: whether or not to skip the generation of chunks and embeddings - &#x60;set_page_as_boundary&#x60;: described above - &#x60;embedding_model&#x60;: the model used to generate embeddings for the document chunks - &#x60;use_ocr&#x60;: whether or not to use OCR as a preprocessing step prior to generating chunks (only valid for PDFs currently) - &#x60;generate_sparse_vectors&#x60;: whether or not to generate sparse vectors for the file. Required for hybrid search. - &#x60;prepend_filename_to_chunks&#x60;: whether or not to prepend the filename to the chunk text   Carbon supports multiple models for use in generating embeddings for files. For images, we support Vertex AI&#39;s multimodal model; for text, we support OpenAI&#39;s &#x60;text-embedding-ada-002&#x60; and Cohere&#39;s embed-multilingual-v3.0. The model can be specified via the &#x60;embedding_model&#x60; parameter (in the POST body for &#x60;/embeddings&#x60;, and a query  parameter in &#x60;/uploadfile&#x60;). If no model is supplied, the &#x60;text-embedding-ada-002&#x60; is used by default. When performing embedding queries, embeddings from files that used the specified model will be considered in the query. For example, if files A and B have embeddings generated with &#x60;OPENAI&#x60;, and files C and D have embeddings generated with &#x60;COHERE_MULTILINGUAL_V3&#x60;, then by default, queries will only consider files A and B. If &#x60;COHERE_MULTILINGUAL_V3&#x60; is specified as the &#x60;embedding_model&#x60; in &#x60;/embeddings&#x60;, then only files C and D will be considered. Make sure that the set of all files you want considered for a query have embeddings generated via the same model. For now, **do not** set &#x60;VERTEX_MULTIMODAL&#x60; as an &#x60;embedding_model&#x60;. This model is used automatically by Carbon when it detects an image file.
     * @param _file  (required)
     * @param bodyCreateUploadFileUploadfilePost  (required)
     * @return UploadRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
     </table>
     */
    public UploadRequestBuilder upload(File _file) throws IllegalArgumentException {
        if (_file == null) throw new IllegalArgumentException("\"_file\" is required but got null");
        return new UploadRequestBuilder(_file);
    }
    private okhttp3.Call uploadFromUrlCall(UploadFileFromUrlInput uploadFileFromUrlInput, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = uploadFileFromUrlInput;

        // create path and map variables
        String localVarPath = "/upload_file_from_url";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "accessToken", "apiKey", "customerId" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call uploadFromUrlValidateBeforeCall(UploadFileFromUrlInput uploadFileFromUrlInput, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'uploadFileFromUrlInput' is set
        if (uploadFileFromUrlInput == null) {
            throw new ApiException("Missing the required parameter 'uploadFileFromUrlInput' when calling uploadFromUrl(Async)");
        }

        return uploadFromUrlCall(uploadFileFromUrlInput, _callback);

    }


    private ApiResponse<UserFile> uploadFromUrlWithHttpInfo(UploadFileFromUrlInput uploadFileFromUrlInput) throws ApiException {
        okhttp3.Call localVarCall = uploadFromUrlValidateBeforeCall(uploadFileFromUrlInput, null);
        Type localVarReturnType = new TypeToken<UserFile>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call uploadFromUrlAsync(UploadFileFromUrlInput uploadFileFromUrlInput, final ApiCallback<UserFile> _callback) throws ApiException {

        okhttp3.Call localVarCall = uploadFromUrlValidateBeforeCall(uploadFileFromUrlInput, _callback);
        Type localVarReturnType = new TypeToken<UserFile>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class UploadFromUrlRequestBuilder {
        private final String url;
        private String fileName;
        private Integer chunkSize;
        private Integer chunkOverlap;
        private Boolean skipEmbeddingGeneration;
        private Boolean setPageAsBoundary;
        private EmbeddingGenerators embeddingModel;
        private Boolean generateSparseVectors;
        private Boolean useTextract;
        private Boolean prependFilenameToChunks;
        private Integer maxItemsPerChunk;
        private Boolean parsePdfTablesWithOcr;
        private Boolean detectAudioLanguage;

        private UploadFromUrlRequestBuilder(String url) {
            this.url = url;
        }

        /**
         * Set fileName
         * @param fileName  (optional)
         * @return UploadFromUrlRequestBuilder
         */
        public UploadFromUrlRequestBuilder fileName(String fileName) {
            this.fileName = fileName;
            return this;
        }
        
        /**
         * Set chunkSize
         * @param chunkSize  (optional)
         * @return UploadFromUrlRequestBuilder
         */
        public UploadFromUrlRequestBuilder chunkSize(Integer chunkSize) {
            this.chunkSize = chunkSize;
            return this;
        }
        
        /**
         * Set chunkOverlap
         * @param chunkOverlap  (optional)
         * @return UploadFromUrlRequestBuilder
         */
        public UploadFromUrlRequestBuilder chunkOverlap(Integer chunkOverlap) {
            this.chunkOverlap = chunkOverlap;
            return this;
        }
        
        /**
         * Set skipEmbeddingGeneration
         * @param skipEmbeddingGeneration  (optional, default to false)
         * @return UploadFromUrlRequestBuilder
         */
        public UploadFromUrlRequestBuilder skipEmbeddingGeneration(Boolean skipEmbeddingGeneration) {
            this.skipEmbeddingGeneration = skipEmbeddingGeneration;
            return this;
        }
        
        /**
         * Set setPageAsBoundary
         * @param setPageAsBoundary  (optional, default to false)
         * @return UploadFromUrlRequestBuilder
         */
        public UploadFromUrlRequestBuilder setPageAsBoundary(Boolean setPageAsBoundary) {
            this.setPageAsBoundary = setPageAsBoundary;
            return this;
        }
        
        /**
         * Set embeddingModel
         * @param embeddingModel  (optional)
         * @return UploadFromUrlRequestBuilder
         */
        public UploadFromUrlRequestBuilder embeddingModel(EmbeddingGenerators embeddingModel) {
            this.embeddingModel = embeddingModel;
            return this;
        }
        
        /**
         * Set generateSparseVectors
         * @param generateSparseVectors  (optional, default to false)
         * @return UploadFromUrlRequestBuilder
         */
        public UploadFromUrlRequestBuilder generateSparseVectors(Boolean generateSparseVectors) {
            this.generateSparseVectors = generateSparseVectors;
            return this;
        }
        
        /**
         * Set useTextract
         * @param useTextract  (optional, default to false)
         * @return UploadFromUrlRequestBuilder
         */
        public UploadFromUrlRequestBuilder useTextract(Boolean useTextract) {
            this.useTextract = useTextract;
            return this;
        }
        
        /**
         * Set prependFilenameToChunks
         * @param prependFilenameToChunks  (optional, default to false)
         * @return UploadFromUrlRequestBuilder
         */
        public UploadFromUrlRequestBuilder prependFilenameToChunks(Boolean prependFilenameToChunks) {
            this.prependFilenameToChunks = prependFilenameToChunks;
            return this;
        }
        
        /**
         * Set maxItemsPerChunk
         * @param maxItemsPerChunk Number of objects per chunk. For csv, tsv, xlsx, and json files only. (optional)
         * @return UploadFromUrlRequestBuilder
         */
        public UploadFromUrlRequestBuilder maxItemsPerChunk(Integer maxItemsPerChunk) {
            this.maxItemsPerChunk = maxItemsPerChunk;
            return this;
        }
        
        /**
         * Set parsePdfTablesWithOcr
         * @param parsePdfTablesWithOcr  (optional, default to false)
         * @return UploadFromUrlRequestBuilder
         */
        public UploadFromUrlRequestBuilder parsePdfTablesWithOcr(Boolean parsePdfTablesWithOcr) {
            this.parsePdfTablesWithOcr = parsePdfTablesWithOcr;
            return this;
        }
        
        /**
         * Set detectAudioLanguage
         * @param detectAudioLanguage  (optional, default to false)
         * @return UploadFromUrlRequestBuilder
         */
        public UploadFromUrlRequestBuilder detectAudioLanguage(Boolean detectAudioLanguage) {
            this.detectAudioLanguage = detectAudioLanguage;
            return this;
        }
        
        /**
         * Build call for uploadFromUrl
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            UploadFileFromUrlInput uploadFileFromUrlInput = buildBodyParams();
            return uploadFromUrlCall(uploadFileFromUrlInput, _callback);
        }

        private UploadFileFromUrlInput buildBodyParams() {
            UploadFileFromUrlInput uploadFileFromUrlInput = new UploadFileFromUrlInput();
            uploadFileFromUrlInput.url(this.url);
            uploadFileFromUrlInput.fileName(this.fileName);
            uploadFileFromUrlInput.chunkSize(this.chunkSize);
            uploadFileFromUrlInput.chunkOverlap(this.chunkOverlap);
            uploadFileFromUrlInput.skipEmbeddingGeneration(this.skipEmbeddingGeneration);
            uploadFileFromUrlInput.setPageAsBoundary(this.setPageAsBoundary);
            uploadFileFromUrlInput.embeddingModel(this.embeddingModel);
            uploadFileFromUrlInput.generateSparseVectors(this.generateSparseVectors);
            uploadFileFromUrlInput.useTextract(this.useTextract);
            uploadFileFromUrlInput.prependFilenameToChunks(this.prependFilenameToChunks);
            uploadFileFromUrlInput.maxItemsPerChunk(this.maxItemsPerChunk);
            uploadFileFromUrlInput.parsePdfTablesWithOcr(this.parsePdfTablesWithOcr);
            uploadFileFromUrlInput.detectAudioLanguage(this.detectAudioLanguage);
            return uploadFileFromUrlInput;
        }

        /**
         * Execute uploadFromUrl request
         * @return UserFile
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public UserFile execute() throws ApiException {
            UploadFileFromUrlInput uploadFileFromUrlInput = buildBodyParams();
            ApiResponse<UserFile> localVarResp = uploadFromUrlWithHttpInfo(uploadFileFromUrlInput);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute uploadFromUrl request with HTTP info returned
         * @return ApiResponse&lt;UserFile&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<UserFile> executeWithHttpInfo() throws ApiException {
            UploadFileFromUrlInput uploadFileFromUrlInput = buildBodyParams();
            return uploadFromUrlWithHttpInfo(uploadFileFromUrlInput);
        }

        /**
         * Execute uploadFromUrl request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<UserFile> _callback) throws ApiException {
            UploadFileFromUrlInput uploadFileFromUrlInput = buildBodyParams();
            return uploadFromUrlAsync(uploadFileFromUrlInput, _callback);
        }
    }

    /**
     * Create Upload File From Url
     * 
     * @param uploadFileFromUrlInput  (required)
     * @return UploadFromUrlRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
     </table>
     */
    public UploadFromUrlRequestBuilder uploadFromUrl(String url) throws IllegalArgumentException {
        if (url == null) throw new IllegalArgumentException("\"url\" is required but got null");
            

        return new UploadFromUrlRequestBuilder(url);
    }
    private okhttp3.Call uploadTextCall(RawTextInput rawTextInput, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = rawTextInput;

        // create path and map variables
        String localVarPath = "/upload_text";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "accessToken", "apiKey", "customerId" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call uploadTextValidateBeforeCall(RawTextInput rawTextInput, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'rawTextInput' is set
        if (rawTextInput == null) {
            throw new ApiException("Missing the required parameter 'rawTextInput' when calling uploadText(Async)");
        }

        return uploadTextCall(rawTextInput, _callback);

    }


    private ApiResponse<UserFile> uploadTextWithHttpInfo(RawTextInput rawTextInput) throws ApiException {
        okhttp3.Call localVarCall = uploadTextValidateBeforeCall(rawTextInput, null);
        Type localVarReturnType = new TypeToken<UserFile>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call uploadTextAsync(RawTextInput rawTextInput, final ApiCallback<UserFile> _callback) throws ApiException {

        okhttp3.Call localVarCall = uploadTextValidateBeforeCall(rawTextInput, _callback);
        Type localVarReturnType = new TypeToken<UserFile>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class UploadTextRequestBuilder {
        private final String contents;
        private String name;
        private Integer chunkSize;
        private Integer chunkOverlap;
        private Boolean skipEmbeddingGeneration;
        private Integer overwriteFileId;
        private EmbeddingGeneratorsNullable embeddingModel;
        private Boolean generateSparseVectors;

        private UploadTextRequestBuilder(String contents) {
            this.contents = contents;
        }

        /**
         * Set name
         * @param name  (optional)
         * @return UploadTextRequestBuilder
         */
        public UploadTextRequestBuilder name(String name) {
            this.name = name;
            return this;
        }
        
        /**
         * Set chunkSize
         * @param chunkSize  (optional)
         * @return UploadTextRequestBuilder
         */
        public UploadTextRequestBuilder chunkSize(Integer chunkSize) {
            this.chunkSize = chunkSize;
            return this;
        }
        
        /**
         * Set chunkOverlap
         * @param chunkOverlap  (optional)
         * @return UploadTextRequestBuilder
         */
        public UploadTextRequestBuilder chunkOverlap(Integer chunkOverlap) {
            this.chunkOverlap = chunkOverlap;
            return this;
        }
        
        /**
         * Set skipEmbeddingGeneration
         * @param skipEmbeddingGeneration  (optional, default to false)
         * @return UploadTextRequestBuilder
         */
        public UploadTextRequestBuilder skipEmbeddingGeneration(Boolean skipEmbeddingGeneration) {
            this.skipEmbeddingGeneration = skipEmbeddingGeneration;
            return this;
        }
        
        /**
         * Set overwriteFileId
         * @param overwriteFileId  (optional)
         * @return UploadTextRequestBuilder
         */
        public UploadTextRequestBuilder overwriteFileId(Integer overwriteFileId) {
            this.overwriteFileId = overwriteFileId;
            return this;
        }
        
        /**
         * Set embeddingModel
         * @param embeddingModel  (optional, default to OPENAI)
         * @return UploadTextRequestBuilder
         */
        public UploadTextRequestBuilder embeddingModel(EmbeddingGeneratorsNullable embeddingModel) {
            this.embeddingModel = embeddingModel;
            return this;
        }
        
        /**
         * Set generateSparseVectors
         * @param generateSparseVectors  (optional, default to false)
         * @return UploadTextRequestBuilder
         */
        public UploadTextRequestBuilder generateSparseVectors(Boolean generateSparseVectors) {
            this.generateSparseVectors = generateSparseVectors;
            return this;
        }
        
        /**
         * Build call for uploadText
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            RawTextInput rawTextInput = buildBodyParams();
            return uploadTextCall(rawTextInput, _callback);
        }

        private RawTextInput buildBodyParams() {
            RawTextInput rawTextInput = new RawTextInput();
            rawTextInput.contents(this.contents);
            rawTextInput.name(this.name);
            rawTextInput.chunkSize(this.chunkSize);
            rawTextInput.chunkOverlap(this.chunkOverlap);
            rawTextInput.skipEmbeddingGeneration(this.skipEmbeddingGeneration);
            rawTextInput.overwriteFileId(this.overwriteFileId);
            rawTextInput.embeddingModel(this.embeddingModel);
            rawTextInput.generateSparseVectors(this.generateSparseVectors);
            return rawTextInput;
        }

        /**
         * Execute uploadText request
         * @return UserFile
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public UserFile execute() throws ApiException {
            RawTextInput rawTextInput = buildBodyParams();
            ApiResponse<UserFile> localVarResp = uploadTextWithHttpInfo(rawTextInput);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute uploadText request with HTTP info returned
         * @return ApiResponse&lt;UserFile&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<UserFile> executeWithHttpInfo() throws ApiException {
            RawTextInput rawTextInput = buildBodyParams();
            return uploadTextWithHttpInfo(rawTextInput);
        }

        /**
         * Execute uploadText request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<UserFile> _callback) throws ApiException {
            RawTextInput rawTextInput = buildBodyParams();
            return uploadTextAsync(rawTextInput, _callback);
        }
    }

    /**
     * Create Raw Text
     * Carbon supports multiple models for use in generating embeddings for files. For images, we support Vertex AI&#39;s multimodal model; for text, we support OpenAI&#39;s &#x60;text-embedding-ada-002&#x60; and Cohere&#39;s embed-multilingual-v3.0. The model can be specified via the &#x60;embedding_model&#x60; parameter (in the POST body for &#x60;/embeddings&#x60;, and a query  parameter in &#x60;/uploadfile&#x60;). If no model is supplied, the &#x60;text-embedding-ada-002&#x60; is used by default. When performing embedding queries, embeddings from files that used the specified model will be considered in the query. For example, if files A and B have embeddings generated with &#x60;OPENAI&#x60;, and files C and D have embeddings generated with &#x60;COHERE_MULTILINGUAL_V3&#x60;, then by default, queries will only consider files A and B. If &#x60;COHERE_MULTILINGUAL_V3&#x60; is specified as the &#x60;embedding_model&#x60; in &#x60;/embeddings&#x60;, then only files C and D will be considered. Make sure that the set of all files you want considered for a query have embeddings generated via the same model. For now, **do not** set &#x60;VERTEX_MULTIMODAL&#x60; as an &#x60;embedding_model&#x60;. This model is used automatically by Carbon when it detects an image file.
     * @param rawTextInput  (required)
     * @return UploadTextRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
     </table>
     */
    public UploadTextRequestBuilder uploadText(String contents) throws IllegalArgumentException {
        if (contents == null) throw new IllegalArgumentException("\"contents\" is required but got null");
            if (contents != null && contents.length() < 5) {
              throw new IllegalArgumentException("Invalid value for contents. Length must be greater than or equal to 5.");
            }

        return new UploadTextRequestBuilder(contents);
    }
}
