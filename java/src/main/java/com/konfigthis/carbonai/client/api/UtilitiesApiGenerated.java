/*
 * Carbon
 * Connect external data to LLMs, no matter the source.
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by Konfig (https://konfigthis.com).
 * Do not edit the class manually.
 */


package com.konfigthis.carbonai.client.api;

import com.konfigthis.carbonai.client.ApiCallback;
import com.konfigthis.carbonai.client.ApiClient;
import com.konfigthis.carbonai.client.ApiException;
import com.konfigthis.carbonai.client.ApiResponse;
import com.konfigthis.carbonai.client.Configuration;
import com.konfigthis.carbonai.client.Pair;
import com.konfigthis.carbonai.client.ProgressRequestBody;
import com.konfigthis.carbonai.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import com.konfigthis.carbonai.client.model.EmbeddingGenerators;
import com.konfigthis.carbonai.client.model.FetchURLsRequest;
import com.konfigthis.carbonai.client.model.FetchURLsResponse;
import com.konfigthis.carbonai.client.model.OrderDirV2;
import com.konfigthis.carbonai.client.model.Pagination;
import com.konfigthis.carbonai.client.model.SitemapScrapeRequest;
import com.konfigthis.carbonai.client.model.UserWebPageOrderByTypes;
import com.konfigthis.carbonai.client.model.UserWebPagesFilters;
import com.konfigthis.carbonai.client.model.UserWebPagesRequest;
import com.konfigthis.carbonai.client.model.WebscrapeRequest;
import com.konfigthis.carbonai.client.model.YoutubeTranscriptResponse;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.ws.rs.core.GenericType;

public class UtilitiesApiGenerated {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public UtilitiesApiGenerated() throws IllegalArgumentException {
        this(Configuration.getDefaultApiClient());
    }

    public UtilitiesApiGenerated(ApiClient apiClient) throws IllegalArgumentException {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    private okhttp3.Call fetchUrlsCall(String url, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/fetch_urls";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (url != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("url", url));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "accessToken", "apiKey", "customerId" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @Deprecated
    @SuppressWarnings("rawtypes")
    private okhttp3.Call fetchUrlsValidateBeforeCall(String url, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'url' is set
        if (url == null) {
            throw new ApiException("Missing the required parameter 'url' when calling fetchUrls(Async)");
        }

        return fetchUrlsCall(url, _callback);

    }


    private ApiResponse<FetchURLsResponse> fetchUrlsWithHttpInfo(String url) throws ApiException {
        okhttp3.Call localVarCall = fetchUrlsValidateBeforeCall(url, null);
        Type localVarReturnType = new TypeToken<FetchURLsResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call fetchUrlsAsync(String url, final ApiCallback<FetchURLsResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = fetchUrlsValidateBeforeCall(url, _callback);
        Type localVarReturnType = new TypeToken<FetchURLsResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public abstract class FetchUrlsRequestBuilderGenerated {
        final String url;

        public FetchUrlsRequestBuilderGenerated(String url) {
            this.url = url;
        }

        /**
         * Build call for fetchUrls
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         * @deprecated
         */
        @Deprecated
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return fetchUrlsCall(url, _callback);
        }


        /**
         * Execute fetchUrls request
         * @return FetchURLsResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         * @deprecated
         */
        @Deprecated
        public FetchURLsResponse execute() throws ApiException {
            ApiResponse<FetchURLsResponse> localVarResp = fetchUrlsWithHttpInfo(url);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute fetchUrls request with HTTP info returned
         * @return ApiResponse&lt;FetchURLsResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         * @deprecated
         */
        @Deprecated
        public ApiResponse<FetchURLsResponse> executeWithHttpInfo() throws ApiException {
            return fetchUrlsWithHttpInfo(url);
        }

        /**
         * Execute fetchUrls request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         * @deprecated
         */
        @Deprecated
        public okhttp3.Call executeAsync(final ApiCallback<FetchURLsResponse> _callback) throws ApiException {
            return fetchUrlsAsync(url, _callback);
        }
    }

    /**
     * Fetch Urls
     * Extracts all URLs from a webpage.   Args:     url (str): URL of the webpage  Returns:     FetchURLsResponse: A response object with a list of URLs extracted from the webpage and the webpage content.
     * @param url  (required)
     * @return FetchUrlsRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
     </table>
     * @deprecated
     */
    @Deprecated
    public UtilitiesApi.FetchUrlsRequestBuilder fetchUrls(String url) throws IllegalArgumentException {
        if (url == null) throw new IllegalArgumentException("\"url\" is required but got null");
            

        return ((UtilitiesApi) this).new FetchUrlsRequestBuilder(url);
    }
    private okhttp3.Call fetchWebpageCall(FetchURLsRequest fetchURLsRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = fetchURLsRequest;

        // create path and map variables
        String localVarPath = "/fetch_webpage";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "accessToken", "apiKey", "customerId" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call fetchWebpageValidateBeforeCall(FetchURLsRequest fetchURLsRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'fetchURLsRequest' is set
        if (fetchURLsRequest == null) {
            throw new ApiException("Missing the required parameter 'fetchURLsRequest' when calling fetchWebpage(Async)");
        }

        return fetchWebpageCall(fetchURLsRequest, _callback);

    }


    private ApiResponse<Object> fetchWebpageWithHttpInfo(FetchURLsRequest fetchURLsRequest) throws ApiException {
        okhttp3.Call localVarCall = fetchWebpageValidateBeforeCall(fetchURLsRequest, null);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call fetchWebpageAsync(FetchURLsRequest fetchURLsRequest, final ApiCallback<Object> _callback) throws ApiException {

        okhttp3.Call localVarCall = fetchWebpageValidateBeforeCall(fetchURLsRequest, _callback);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public abstract class FetchWebpageRequestBuilderGenerated {
        final String url;

        public FetchWebpageRequestBuilderGenerated(String url) {
            this.url = url;
        }

        /**
         * Build call for fetchWebpage
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            FetchURLsRequest fetchURLsRequest = buildBodyParams();
            return fetchWebpageCall(fetchURLsRequest, _callback);
        }

        private FetchURLsRequest buildBodyParams() {
            FetchURLsRequest fetchURLsRequest = new FetchURLsRequest();
            fetchURLsRequest.url(this.url);
            return fetchURLsRequest;
        }

        /**
         * Execute fetchWebpage request
         * @return Object
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public Object execute() throws ApiException {
            FetchURLsRequest fetchURLsRequest = buildBodyParams();
            ApiResponse<Object> localVarResp = fetchWebpageWithHttpInfo(fetchURLsRequest);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute fetchWebpage request with HTTP info returned
         * @return ApiResponse&lt;Object&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Object> executeWithHttpInfo() throws ApiException {
            FetchURLsRequest fetchURLsRequest = buildBodyParams();
            return fetchWebpageWithHttpInfo(fetchURLsRequest);
        }

        /**
         * Execute fetchWebpage request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Object> _callback) throws ApiException {
            FetchURLsRequest fetchURLsRequest = buildBodyParams();
            return fetchWebpageAsync(fetchURLsRequest, _callback);
        }
    }

    /**
     * Fetch Urls V2
     * 
     * @param fetchURLsRequest  (required)
     * @return FetchWebpageRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
     </table>
     */
    public UtilitiesApi.FetchWebpageRequestBuilder fetchWebpage(String url) throws IllegalArgumentException {
        if (url == null) throw new IllegalArgumentException("\"url\" is required but got null");
            

        return ((UtilitiesApi) this).new FetchWebpageRequestBuilder(url);
    }
    private okhttp3.Call fetchYoutubeTranscriptsCall(String id, Boolean raw, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/fetch_youtube_transcript";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (id != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("id", id));
        }

        if (raw != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("raw", raw));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "accessToken", "apiKey", "customerId" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call fetchYoutubeTranscriptsValidateBeforeCall(String id, Boolean raw, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling fetchYoutubeTranscripts(Async)");
        }

        return fetchYoutubeTranscriptsCall(id, raw, _callback);

    }


    private ApiResponse<YoutubeTranscriptResponse> fetchYoutubeTranscriptsWithHttpInfo(String id, Boolean raw) throws ApiException {
        okhttp3.Call localVarCall = fetchYoutubeTranscriptsValidateBeforeCall(id, raw, null);
        Type localVarReturnType = new TypeToken<YoutubeTranscriptResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call fetchYoutubeTranscriptsAsync(String id, Boolean raw, final ApiCallback<YoutubeTranscriptResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = fetchYoutubeTranscriptsValidateBeforeCall(id, raw, _callback);
        Type localVarReturnType = new TypeToken<YoutubeTranscriptResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public abstract class FetchYoutubeTranscriptsRequestBuilderGenerated {
        final String id;
        Boolean raw;

        public FetchYoutubeTranscriptsRequestBuilderGenerated(String id) {
            this.id = id;
        }

        /**
         * Set raw
         * @param raw  (optional, default to false)
         * @return UtilitiesApi.FetchYoutubeTranscriptsRequestBuilder
         */
        public UtilitiesApi.FetchYoutubeTranscriptsRequestBuilder raw(Boolean raw) {
            this.raw = raw;
            return (UtilitiesApi.FetchYoutubeTranscriptsRequestBuilder) this;
        }
        
        /**
         * Build call for fetchYoutubeTranscripts
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return fetchYoutubeTranscriptsCall(id, raw, _callback);
        }


        /**
         * Execute fetchYoutubeTranscripts request
         * @return YoutubeTranscriptResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public YoutubeTranscriptResponse execute() throws ApiException {
            ApiResponse<YoutubeTranscriptResponse> localVarResp = fetchYoutubeTranscriptsWithHttpInfo(id, raw);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute fetchYoutubeTranscripts request with HTTP info returned
         * @return ApiResponse&lt;YoutubeTranscriptResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<YoutubeTranscriptResponse> executeWithHttpInfo() throws ApiException {
            return fetchYoutubeTranscriptsWithHttpInfo(id, raw);
        }

        /**
         * Execute fetchYoutubeTranscripts request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<YoutubeTranscriptResponse> _callback) throws ApiException {
            return fetchYoutubeTranscriptsAsync(id, raw, _callback);
        }
    }

    /**
     * Fetch Youtube Transcripts
     * Fetches english transcripts from YouTube videos.  Args:     id (str): The ID of the YouTube video.      raw (bool): Whether to return the raw transcript or not. Defaults to False.  Returns:     dict: A dictionary with the transcript of the YouTube video.
     * @param id  (required)
     * @return FetchYoutubeTranscriptsRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
     </table>
     */
    public UtilitiesApi.FetchYoutubeTranscriptsRequestBuilder fetchYoutubeTranscripts(String id) throws IllegalArgumentException {
        if (id == null) throw new IllegalArgumentException("\"id\" is required but got null");
            

        return ((UtilitiesApi) this).new FetchYoutubeTranscriptsRequestBuilder(id);
    }
    private okhttp3.Call processSitemapCall(String url, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/process_sitemap";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (url != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("url", url));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "accessToken", "apiKey", "customerId" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call processSitemapValidateBeforeCall(String url, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'url' is set
        if (url == null) {
            throw new ApiException("Missing the required parameter 'url' when calling processSitemap(Async)");
        }

        return processSitemapCall(url, _callback);

    }


    private ApiResponse<Object> processSitemapWithHttpInfo(String url) throws ApiException {
        okhttp3.Call localVarCall = processSitemapValidateBeforeCall(url, null);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call processSitemapAsync(String url, final ApiCallback<Object> _callback) throws ApiException {

        okhttp3.Call localVarCall = processSitemapValidateBeforeCall(url, _callback);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public abstract class ProcessSitemapRequestBuilderGenerated {
        final String url;

        public ProcessSitemapRequestBuilderGenerated(String url) {
            this.url = url;
        }

        /**
         * Build call for processSitemap
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return processSitemapCall(url, _callback);
        }


        /**
         * Execute processSitemap request
         * @return Object
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public Object execute() throws ApiException {
            ApiResponse<Object> localVarResp = processSitemapWithHttpInfo(url);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute processSitemap request with HTTP info returned
         * @return ApiResponse&lt;Object&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Object> executeWithHttpInfo() throws ApiException {
            return processSitemapWithHttpInfo(url);
        }

        /**
         * Execute processSitemap request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Object> _callback) throws ApiException {
            return processSitemapAsync(url, _callback);
        }
    }

    /**
     * Sitemap
     * Retrieves all URLs from a sitemap, which can subsequently be utilized with our &#x60;web_scrape&#x60; endpoint.  &lt;!--Args:     url (str): URL of the sitemap  Returns:     dict: A dictionary with a list of URLs extracted from the sitemap.--&gt;
     * @param url  (required)
     * @return ProcessSitemapRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
     </table>
     */
    public UtilitiesApi.ProcessSitemapRequestBuilder processSitemap(String url) throws IllegalArgumentException {
        if (url == null) throw new IllegalArgumentException("\"url\" is required but got null");
            

        return ((UtilitiesApi) this).new ProcessSitemapRequestBuilder(url);
    }
    private okhttp3.Call scrapeSitemapCall(SitemapScrapeRequest sitemapScrapeRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = sitemapScrapeRequest;

        // create path and map variables
        String localVarPath = "/scrape_sitemap";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "accessToken", "apiKey", "customerId" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call scrapeSitemapValidateBeforeCall(SitemapScrapeRequest sitemapScrapeRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'sitemapScrapeRequest' is set
        if (sitemapScrapeRequest == null) {
            throw new ApiException("Missing the required parameter 'sitemapScrapeRequest' when calling scrapeSitemap(Async)");
        }

        return scrapeSitemapCall(sitemapScrapeRequest, _callback);

    }


    private ApiResponse<Object> scrapeSitemapWithHttpInfo(SitemapScrapeRequest sitemapScrapeRequest) throws ApiException {
        okhttp3.Call localVarCall = scrapeSitemapValidateBeforeCall(sitemapScrapeRequest, null);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call scrapeSitemapAsync(SitemapScrapeRequest sitemapScrapeRequest, final ApiCallback<Object> _callback) throws ApiException {

        okhttp3.Call localVarCall = scrapeSitemapValidateBeforeCall(sitemapScrapeRequest, _callback);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public abstract class ScrapeSitemapRequestBuilderGenerated {
        final String url;
        Map<String, Object> tags;
        Integer maxPagesToScrape;
        Integer chunkSize;
        Integer chunkOverlap;
        Boolean skipEmbeddingGeneration;
        Boolean enableAutoSync;
        Boolean generateSparseVectors;
        Boolean prependFilenameToChunks;
        List<String> htmlTagsToSkip;
        List<String> cssClassesToSkip;
        List<String> cssSelectorsToSkip;
        EmbeddingGenerators embeddingModel;
        List<String> urlPathsToInclude;
        List<String> urlPathsToExclude;
        List<String> urlsToScrape;
        Boolean downloadCssAndMedia;
        Boolean generateChunksOnly;

        public ScrapeSitemapRequestBuilderGenerated(String url) {
            this.url = url;
        }

        /**
         * Set tags
         * @param tags  (optional)
         * @return UtilitiesApi.ScrapeSitemapRequestBuilder
         */
        public UtilitiesApi.ScrapeSitemapRequestBuilder tags(Map<String, Object> tags) {
            this.tags = tags;
            return (UtilitiesApi.ScrapeSitemapRequestBuilder) this;
        }
        
        /**
         * Set maxPagesToScrape
         * @param maxPagesToScrape  (optional)
         * @return UtilitiesApi.ScrapeSitemapRequestBuilder
         */
        public UtilitiesApi.ScrapeSitemapRequestBuilder maxPagesToScrape(Integer maxPagesToScrape) {
            this.maxPagesToScrape = maxPagesToScrape;
            return (UtilitiesApi.ScrapeSitemapRequestBuilder) this;
        }
        
        /**
         * Set chunkSize
         * @param chunkSize  (optional, default to 1500)
         * @return UtilitiesApi.ScrapeSitemapRequestBuilder
         */
        public UtilitiesApi.ScrapeSitemapRequestBuilder chunkSize(Integer chunkSize) {
            this.chunkSize = chunkSize;
            return (UtilitiesApi.ScrapeSitemapRequestBuilder) this;
        }
        
        /**
         * Set chunkOverlap
         * @param chunkOverlap  (optional, default to 20)
         * @return UtilitiesApi.ScrapeSitemapRequestBuilder
         */
        public UtilitiesApi.ScrapeSitemapRequestBuilder chunkOverlap(Integer chunkOverlap) {
            this.chunkOverlap = chunkOverlap;
            return (UtilitiesApi.ScrapeSitemapRequestBuilder) this;
        }
        
        /**
         * Set skipEmbeddingGeneration
         * @param skipEmbeddingGeneration  (optional, default to false)
         * @return UtilitiesApi.ScrapeSitemapRequestBuilder
         */
        public UtilitiesApi.ScrapeSitemapRequestBuilder skipEmbeddingGeneration(Boolean skipEmbeddingGeneration) {
            this.skipEmbeddingGeneration = skipEmbeddingGeneration;
            return (UtilitiesApi.ScrapeSitemapRequestBuilder) this;
        }
        
        /**
         * Set enableAutoSync
         * @param enableAutoSync  (optional, default to false)
         * @return UtilitiesApi.ScrapeSitemapRequestBuilder
         */
        public UtilitiesApi.ScrapeSitemapRequestBuilder enableAutoSync(Boolean enableAutoSync) {
            this.enableAutoSync = enableAutoSync;
            return (UtilitiesApi.ScrapeSitemapRequestBuilder) this;
        }
        
        /**
         * Set generateSparseVectors
         * @param generateSparseVectors  (optional, default to false)
         * @return UtilitiesApi.ScrapeSitemapRequestBuilder
         */
        public UtilitiesApi.ScrapeSitemapRequestBuilder generateSparseVectors(Boolean generateSparseVectors) {
            this.generateSparseVectors = generateSparseVectors;
            return (UtilitiesApi.ScrapeSitemapRequestBuilder) this;
        }
        
        /**
         * Set prependFilenameToChunks
         * @param prependFilenameToChunks  (optional, default to false)
         * @return UtilitiesApi.ScrapeSitemapRequestBuilder
         */
        public UtilitiesApi.ScrapeSitemapRequestBuilder prependFilenameToChunks(Boolean prependFilenameToChunks) {
            this.prependFilenameToChunks = prependFilenameToChunks;
            return (UtilitiesApi.ScrapeSitemapRequestBuilder) this;
        }
        
        /**
         * Set htmlTagsToSkip
         * @param htmlTagsToSkip  (optional)
         * @return UtilitiesApi.ScrapeSitemapRequestBuilder
         */
        public UtilitiesApi.ScrapeSitemapRequestBuilder htmlTagsToSkip(List<String> htmlTagsToSkip) {
            this.htmlTagsToSkip = htmlTagsToSkip;
            return (UtilitiesApi.ScrapeSitemapRequestBuilder) this;
        }
        
        /**
         * Set cssClassesToSkip
         * @param cssClassesToSkip  (optional)
         * @return UtilitiesApi.ScrapeSitemapRequestBuilder
         */
        public UtilitiesApi.ScrapeSitemapRequestBuilder cssClassesToSkip(List<String> cssClassesToSkip) {
            this.cssClassesToSkip = cssClassesToSkip;
            return (UtilitiesApi.ScrapeSitemapRequestBuilder) this;
        }
        
        /**
         * Set cssSelectorsToSkip
         * @param cssSelectorsToSkip  (optional)
         * @return UtilitiesApi.ScrapeSitemapRequestBuilder
         */
        public UtilitiesApi.ScrapeSitemapRequestBuilder cssSelectorsToSkip(List<String> cssSelectorsToSkip) {
            this.cssSelectorsToSkip = cssSelectorsToSkip;
            return (UtilitiesApi.ScrapeSitemapRequestBuilder) this;
        }
        
        /**
         * Set embeddingModel
         * @param embeddingModel  (optional)
         * @return UtilitiesApi.ScrapeSitemapRequestBuilder
         */
        public UtilitiesApi.ScrapeSitemapRequestBuilder embeddingModel(EmbeddingGenerators embeddingModel) {
            this.embeddingModel = embeddingModel;
            return (UtilitiesApi.ScrapeSitemapRequestBuilder) this;
        }
        
        /**
         * Set urlPathsToInclude
         * @param urlPathsToInclude URL subpaths or directories that you want to include. For example if you want to only include         URLs that start with /questions in stackoverflow.com, you will add /questions/ in this input (optional)
         * @return UtilitiesApi.ScrapeSitemapRequestBuilder
         */
        public UtilitiesApi.ScrapeSitemapRequestBuilder urlPathsToInclude(List<String> urlPathsToInclude) {
            this.urlPathsToInclude = urlPathsToInclude;
            return (UtilitiesApi.ScrapeSitemapRequestBuilder) this;
        }
        
        /**
         * Set urlPathsToExclude
         * @param urlPathsToExclude URL subpaths or directories that you want to exclude. For example if you want to exclude         URLs that start with /questions in stackoverflow.com, you will add /questions/ in this input (optional)
         * @return UtilitiesApi.ScrapeSitemapRequestBuilder
         */
        public UtilitiesApi.ScrapeSitemapRequestBuilder urlPathsToExclude(List<String> urlPathsToExclude) {
            this.urlPathsToExclude = urlPathsToExclude;
            return (UtilitiesApi.ScrapeSitemapRequestBuilder) this;
        }
        
        /**
         * Set urlsToScrape
         * @param urlsToScrape You can submit a subset of URLs from the sitemap that should be scraped. To get the list of URLs,           you can check out /process_sitemap endpoint. If left empty, all URLs from the sitemap will be scraped. (optional)
         * @return UtilitiesApi.ScrapeSitemapRequestBuilder
         */
        public UtilitiesApi.ScrapeSitemapRequestBuilder urlsToScrape(List<String> urlsToScrape) {
            this.urlsToScrape = urlsToScrape;
            return (UtilitiesApi.ScrapeSitemapRequestBuilder) this;
        }
        
        /**
         * Set downloadCssAndMedia
         * @param downloadCssAndMedia Whether the scraper should download css and media from the page (images, fonts, etc). Scrapes          might take longer to finish with this flag enabled, but the success rate is improved. (optional, default to false)
         * @return UtilitiesApi.ScrapeSitemapRequestBuilder
         */
        public UtilitiesApi.ScrapeSitemapRequestBuilder downloadCssAndMedia(Boolean downloadCssAndMedia) {
            this.downloadCssAndMedia = downloadCssAndMedia;
            return (UtilitiesApi.ScrapeSitemapRequestBuilder) this;
        }
        
        /**
         * Set generateChunksOnly
         * @param generateChunksOnly If this flag is enabled, the file will be chunked and stored with Carbon,           but no embeddings will be generated. This overrides the skip_embedding_generation flag. (optional, default to false)
         * @return UtilitiesApi.ScrapeSitemapRequestBuilder
         */
        public UtilitiesApi.ScrapeSitemapRequestBuilder generateChunksOnly(Boolean generateChunksOnly) {
            this.generateChunksOnly = generateChunksOnly;
            return (UtilitiesApi.ScrapeSitemapRequestBuilder) this;
        }
        
        /**
         * Build call for scrapeSitemap
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            SitemapScrapeRequest sitemapScrapeRequest = buildBodyParams();
            return scrapeSitemapCall(sitemapScrapeRequest, _callback);
        }

        private SitemapScrapeRequest buildBodyParams() {
            SitemapScrapeRequest sitemapScrapeRequest = new SitemapScrapeRequest();
            sitemapScrapeRequest.tags(this.tags);
            sitemapScrapeRequest.url(this.url);
            sitemapScrapeRequest.maxPagesToScrape(this.maxPagesToScrape);
            sitemapScrapeRequest.chunkSize(this.chunkSize);
            sitemapScrapeRequest.chunkOverlap(this.chunkOverlap);
            sitemapScrapeRequest.skipEmbeddingGeneration(this.skipEmbeddingGeneration);
            sitemapScrapeRequest.enableAutoSync(this.enableAutoSync);
            sitemapScrapeRequest.generateSparseVectors(this.generateSparseVectors);
            sitemapScrapeRequest.prependFilenameToChunks(this.prependFilenameToChunks);
            sitemapScrapeRequest.htmlTagsToSkip(this.htmlTagsToSkip);
            sitemapScrapeRequest.cssClassesToSkip(this.cssClassesToSkip);
            sitemapScrapeRequest.cssSelectorsToSkip(this.cssSelectorsToSkip);
            sitemapScrapeRequest.embeddingModel(this.embeddingModel);
            sitemapScrapeRequest.urlPathsToInclude(this.urlPathsToInclude);
            sitemapScrapeRequest.urlPathsToExclude(this.urlPathsToExclude);
            sitemapScrapeRequest.urlsToScrape(this.urlsToScrape);
            sitemapScrapeRequest.downloadCssAndMedia(this.downloadCssAndMedia);
            sitemapScrapeRequest.generateChunksOnly(this.generateChunksOnly);
            return sitemapScrapeRequest;
        }

        /**
         * Execute scrapeSitemap request
         * @return Object
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public Object execute() throws ApiException {
            SitemapScrapeRequest sitemapScrapeRequest = buildBodyParams();
            ApiResponse<Object> localVarResp = scrapeSitemapWithHttpInfo(sitemapScrapeRequest);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute scrapeSitemap request with HTTP info returned
         * @return ApiResponse&lt;Object&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Object> executeWithHttpInfo() throws ApiException {
            SitemapScrapeRequest sitemapScrapeRequest = buildBodyParams();
            return scrapeSitemapWithHttpInfo(sitemapScrapeRequest);
        }

        /**
         * Execute scrapeSitemap request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Object> _callback) throws ApiException {
            SitemapScrapeRequest sitemapScrapeRequest = buildBodyParams();
            return scrapeSitemapAsync(sitemapScrapeRequest, _callback);
        }
    }

    /**
     * Scrape Sitemap
     * Extracts all URLs from a sitemap and performs a web scrape on each of them.  Args:     sitemap_url (str): URL of the sitemap  Returns:     dict: A response object with the status of the scraping job message.--&gt;
     * @param sitemapScrapeRequest  (required)
     * @return ScrapeSitemapRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
     </table>
     */
    public UtilitiesApi.ScrapeSitemapRequestBuilder scrapeSitemap(String url) throws IllegalArgumentException {
        if (url == null) throw new IllegalArgumentException("\"url\" is required but got null");
            

        return ((UtilitiesApi) this).new ScrapeSitemapRequestBuilder(url);
    }
    private okhttp3.Call scrapeWebCall(List<WebscrapeRequest> webscrapeRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = webscrapeRequest;

        // create path and map variables
        String localVarPath = "/web_scrape";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "accessToken", "apiKey", "customerId" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call scrapeWebValidateBeforeCall(List<WebscrapeRequest> webscrapeRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'webscrapeRequest' is set
        if (webscrapeRequest == null) {
            throw new ApiException("Missing the required parameter 'webscrapeRequest' when calling scrapeWeb(Async)");
        }

        return scrapeWebCall(webscrapeRequest, _callback);

    }


    private ApiResponse<Object> scrapeWebWithHttpInfo(List<WebscrapeRequest> webscrapeRequest) throws ApiException {
        okhttp3.Call localVarCall = scrapeWebValidateBeforeCall(webscrapeRequest, null);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call scrapeWebAsync(List<WebscrapeRequest> webscrapeRequest, final ApiCallback<Object> _callback) throws ApiException {

        okhttp3.Call localVarCall = scrapeWebValidateBeforeCall(webscrapeRequest, _callback);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public abstract class ScrapeWebRequestBuilderGenerated {
        List<WebscrapeRequest> webscrapeRequest;

        public ScrapeWebRequestBuilderGenerated() {
        }

        /**
         * Set webscrapeRequest
         * @param webscrapeRequest  (optional)
         * @return UtilitiesApi.ScrapeWebRequestBuilder
         */
        public UtilitiesApi.ScrapeWebRequestBuilder webscrapeRequest(List<WebscrapeRequest> webscrapeRequest) {
            this.webscrapeRequest = webscrapeRequest;
            return (UtilitiesApi.ScrapeWebRequestBuilder) this;
        }

        /**
         * Build call for scrapeWeb
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            List<WebscrapeRequest> webscrapeRequest = buildBodyParams();
            return scrapeWebCall(webscrapeRequest, _callback);
        }

        private List<WebscrapeRequest> buildBodyParams() {
            return this.webscrapeRequest;
        }

        /**
         * Execute scrapeWeb request
         * @return Object
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public Object execute() throws ApiException {
            List<WebscrapeRequest> webscrapeRequest = buildBodyParams();
            ApiResponse<Object> localVarResp = scrapeWebWithHttpInfo(webscrapeRequest);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute scrapeWeb request with HTTP info returned
         * @return ApiResponse&lt;Object&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Object> executeWithHttpInfo() throws ApiException {
            List<WebscrapeRequest> webscrapeRequest = buildBodyParams();
            return scrapeWebWithHttpInfo(webscrapeRequest);
        }

        /**
         * Execute scrapeWeb request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Object> _callback) throws ApiException {
            List<WebscrapeRequest> webscrapeRequest = buildBodyParams();
            return scrapeWebAsync(webscrapeRequest, _callback);
        }
    }

    /**
     * Web Scrape
     * Conduct a web scrape on a given webpage URL. Our web scraper is fully compatible with JavaScript and supports recursion depth, enabling you to efficiently extract all content from the target website.  &lt;!--Args:     scraping_requests (List[WebscrapeRequest]): A list of WebscrapeRequest objects.       Returns:     dict: A response object with the status of the scraping job message.--&gt;
     * @param webscrapeRequest  (required)
     * @return ScrapeWebRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
     </table>
     */
    public UtilitiesApi.ScrapeWebRequestBuilder scrapeWeb() throws IllegalArgumentException {
        return ((UtilitiesApi) this).new ScrapeWebRequestBuilder();
    }
    private okhttp3.Call searchUrlsCall(String query, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/search_urls";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (query != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("query", query));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "accessToken", "apiKey", "customerId" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call searchUrlsValidateBeforeCall(String query, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'query' is set
        if (query == null) {
            throw new ApiException("Missing the required parameter 'query' when calling searchUrls(Async)");
        }

        return searchUrlsCall(query, _callback);

    }


    private ApiResponse<FetchURLsResponse> searchUrlsWithHttpInfo(String query) throws ApiException {
        okhttp3.Call localVarCall = searchUrlsValidateBeforeCall(query, null);
        Type localVarReturnType = new TypeToken<FetchURLsResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call searchUrlsAsync(String query, final ApiCallback<FetchURLsResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = searchUrlsValidateBeforeCall(query, _callback);
        Type localVarReturnType = new TypeToken<FetchURLsResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public abstract class SearchUrlsRequestBuilderGenerated {
        final String query;

        public SearchUrlsRequestBuilderGenerated(String query) {
            this.query = query;
        }

        /**
         * Build call for searchUrls
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return searchUrlsCall(query, _callback);
        }


        /**
         * Execute searchUrls request
         * @return FetchURLsResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public FetchURLsResponse execute() throws ApiException {
            ApiResponse<FetchURLsResponse> localVarResp = searchUrlsWithHttpInfo(query);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute searchUrls request with HTTP info returned
         * @return ApiResponse&lt;FetchURLsResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<FetchURLsResponse> executeWithHttpInfo() throws ApiException {
            return searchUrlsWithHttpInfo(query);
        }

        /**
         * Execute searchUrls request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<FetchURLsResponse> _callback) throws ApiException {
            return searchUrlsAsync(query, _callback);
        }
    }

    /**
     * Search Urls
     * Perform a web search and obtain a list of relevant URLs.  As an illustration, when you perform a search for content related to MRNA, you will receive a list of links such as the following:      - https://tomrenz.substack.com/p/mrna-and-why-it-matters      - https://www.statnews.com/2020/11/10/the-story-of-mrna-how-a-once-dismissed-idea-became-a-leading-technology-in-the-covid-vaccine-race/      - https://www.statnews.com/2022/11/16/covid-19-vaccines-were-a-success-but-mrna-still-has-a-delivery-problem/          - https://joomi.substack.com/p/were-still-being-misled-about-how  Subsequently, you can submit these links to the web_scrape endpoint in order to retrieve the content of the respective web pages.  Args:     query (str): Query to search for  Returns:     FetchURLsResponse: A response object with a list of URLs for a given search query.
     * @param query  (required)
     * @return SearchUrlsRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
     </table>
     */
    public UtilitiesApi.SearchUrlsRequestBuilder searchUrls(String query) throws IllegalArgumentException {
        if (query == null) throw new IllegalArgumentException("\"query\" is required but got null");
            

        return ((UtilitiesApi) this).new SearchUrlsRequestBuilder(query);
    }
    private okhttp3.Call userWebpagesCall(UserWebPagesRequest userWebPagesRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = userWebPagesRequest;

        // create path and map variables
        String localVarPath = "/user_webpages";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "accessToken", "apiKey", "customerId" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call userWebpagesValidateBeforeCall(UserWebPagesRequest userWebPagesRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'userWebPagesRequest' is set
        if (userWebPagesRequest == null) {
            throw new ApiException("Missing the required parameter 'userWebPagesRequest' when calling userWebpages(Async)");
        }

        return userWebpagesCall(userWebPagesRequest, _callback);

    }


    private ApiResponse<Object> userWebpagesWithHttpInfo(UserWebPagesRequest userWebPagesRequest) throws ApiException {
        okhttp3.Call localVarCall = userWebpagesValidateBeforeCall(userWebPagesRequest, null);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call userWebpagesAsync(UserWebPagesRequest userWebPagesRequest, final ApiCallback<Object> _callback) throws ApiException {

        okhttp3.Call localVarCall = userWebpagesValidateBeforeCall(userWebPagesRequest, _callback);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public abstract class UserWebpagesRequestBuilderGenerated {
        UserWebPagesFilters filters;
        Pagination pagination;
        UserWebPageOrderByTypes orderBy;
        OrderDirV2 orderDir;

        public UserWebpagesRequestBuilderGenerated() {
        }

        /**
         * Set filters
         * @param filters  (optional)
         * @return UtilitiesApi.UserWebpagesRequestBuilder
         */
        public UtilitiesApi.UserWebpagesRequestBuilder filters(UserWebPagesFilters filters) {
            this.filters = filters;
            return (UtilitiesApi.UserWebpagesRequestBuilder) this;
        }
        
        /**
         * Set pagination
         * @param pagination  (optional)
         * @return UtilitiesApi.UserWebpagesRequestBuilder
         */
        public UtilitiesApi.UserWebpagesRequestBuilder pagination(Pagination pagination) {
            this.pagination = pagination;
            return (UtilitiesApi.UserWebpagesRequestBuilder) this;
        }
        
        /**
         * Set orderBy
         * @param orderBy  (optional)
         * @return UtilitiesApi.UserWebpagesRequestBuilder
         */
        public UtilitiesApi.UserWebpagesRequestBuilder orderBy(UserWebPageOrderByTypes orderBy) {
            this.orderBy = orderBy;
            return (UtilitiesApi.UserWebpagesRequestBuilder) this;
        }
        
        /**
         * Set orderDir
         * @param orderDir  (optional)
         * @return UtilitiesApi.UserWebpagesRequestBuilder
         */
        public UtilitiesApi.UserWebpagesRequestBuilder orderDir(OrderDirV2 orderDir) {
            this.orderDir = orderDir;
            return (UtilitiesApi.UserWebpagesRequestBuilder) this;
        }
        
        /**
         * Build call for userWebpages
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            UserWebPagesRequest userWebPagesRequest = buildBodyParams();
            return userWebpagesCall(userWebPagesRequest, _callback);
        }

        private UserWebPagesRequest buildBodyParams() {
            UserWebPagesRequest userWebPagesRequest = new UserWebPagesRequest();
            userWebPagesRequest.filters(this.filters);
            userWebPagesRequest.pagination(this.pagination);
            userWebPagesRequest.orderBy(this.orderBy);
            userWebPagesRequest.orderDir(this.orderDir);
            return userWebPagesRequest;
        }

        /**
         * Execute userWebpages request
         * @return Object
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public Object execute() throws ApiException {
            UserWebPagesRequest userWebPagesRequest = buildBodyParams();
            ApiResponse<Object> localVarResp = userWebpagesWithHttpInfo(userWebPagesRequest);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute userWebpages request with HTTP info returned
         * @return ApiResponse&lt;Object&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Object> executeWithHttpInfo() throws ApiException {
            UserWebPagesRequest userWebPagesRequest = buildBodyParams();
            return userWebpagesWithHttpInfo(userWebPagesRequest);
        }

        /**
         * Execute userWebpages request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Object> _callback) throws ApiException {
            UserWebPagesRequest userWebPagesRequest = buildBodyParams();
            return userWebpagesAsync(userWebPagesRequest, _callback);
        }
    }

    /**
     * User Web Pages
     * 
     * @param userWebPagesRequest  (required)
     * @return UserWebpagesRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
     </table>
     */
    public UtilitiesApi.UserWebpagesRequestBuilder userWebpages() throws IllegalArgumentException {
        return ((UtilitiesApi) this).new UserWebpagesRequestBuilder();
    }
}
