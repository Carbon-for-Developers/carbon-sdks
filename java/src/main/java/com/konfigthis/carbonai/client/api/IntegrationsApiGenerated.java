/*
 * Carbon
 * Connect external data to LLMs, no matter the source.
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by Konfig (https://konfigthis.com).
 * Do not edit the class manually.
 */


package com.konfigthis.carbonai.client.api;

import com.konfigthis.carbonai.client.ApiCallback;
import com.konfigthis.carbonai.client.ApiClient;
import com.konfigthis.carbonai.client.ApiException;
import com.konfigthis.carbonai.client.ApiResponse;
import com.konfigthis.carbonai.client.Configuration;
import com.konfigthis.carbonai.client.Pair;
import com.konfigthis.carbonai.client.ProgressRequestBody;
import com.konfigthis.carbonai.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import com.konfigthis.carbonai.client.model.ConnectDataSourceInput;
import com.konfigthis.carbonai.client.model.ConnectDataSourceResponse;
import com.konfigthis.carbonai.client.model.DataSourceType;
import com.konfigthis.carbonai.client.model.EmbeddingGenerators;
import com.konfigthis.carbonai.client.model.EmbeddingGeneratorsNullable;
import com.konfigthis.carbonai.client.model.ExternalSourceItemsOrderBy;
import com.konfigthis.carbonai.client.model.FileSyncConfigNullable;
import com.konfigthis.carbonai.client.model.FreshDeskConnectRequest;
import com.konfigthis.carbonai.client.model.GenericSuccessResponse;
import com.konfigthis.carbonai.client.model.GitbookConnectRequest;
import com.konfigthis.carbonai.client.model.GitbookSyncRequest;
import com.konfigthis.carbonai.client.model.GithubConnectRequest;
import com.konfigthis.carbonai.client.model.GithubFetchReposRequest;
import com.konfigthis.carbonai.client.model.GmailSyncInput;
import com.konfigthis.carbonai.client.model.ListDataSourceItemsRequest;
import com.konfigthis.carbonai.client.model.ListDataSourceItemsResponse;
import com.konfigthis.carbonai.client.model.ListItemsFiltersNullable;
import com.konfigthis.carbonai.client.model.ListRequest;
import com.konfigthis.carbonai.client.model.ListResponse;
import com.konfigthis.carbonai.client.model.OANSCZGF;
import com.konfigthis.carbonai.client.model.OAuthURLRequest;
import com.konfigthis.carbonai.client.model.OrderDirV2;
import com.konfigthis.carbonai.client.model.OrganizationUserDataSourceAPI;
import com.konfigthis.carbonai.client.model.OuthURLResponse;
import com.konfigthis.carbonai.client.model.OutlookSyncInput;
import com.konfigthis.carbonai.client.model.Pagination;
import com.konfigthis.carbonai.client.model.RSSFeedInput;
import com.konfigthis.carbonai.client.model.S3AuthRequest;
import com.konfigthis.carbonai.client.model.S3FileSyncInput;
import com.konfigthis.carbonai.client.model.S3GetFileInput;
import com.konfigthis.carbonai.client.model.SyncDirectoryRequest;
import com.konfigthis.carbonai.client.model.SyncFilesRequest;
import com.konfigthis.carbonai.client.model.SyncOptions;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.ws.rs.core.GenericType;

public class IntegrationsApiGenerated {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public IntegrationsApiGenerated() throws IllegalArgumentException {
        this(Configuration.getDefaultApiClient());
    }

    public IntegrationsApiGenerated(ApiClient apiClient) throws IllegalArgumentException {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    private okhttp3.Call connectDataSourceCall(ConnectDataSourceInput connectDataSourceInput, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = connectDataSourceInput;

        // create path and map variables
        String localVarPath = "/integrations/connect";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "accessToken", "apiKey", "customerId" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call connectDataSourceValidateBeforeCall(ConnectDataSourceInput connectDataSourceInput, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'connectDataSourceInput' is set
        if (connectDataSourceInput == null) {
            throw new ApiException("Missing the required parameter 'connectDataSourceInput' when calling connectDataSource(Async)");
        }

        return connectDataSourceCall(connectDataSourceInput, _callback);

    }


    private ApiResponse<ConnectDataSourceResponse> connectDataSourceWithHttpInfo(ConnectDataSourceInput connectDataSourceInput) throws ApiException {
        okhttp3.Call localVarCall = connectDataSourceValidateBeforeCall(connectDataSourceInput, null);
        Type localVarReturnType = new TypeToken<ConnectDataSourceResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call connectDataSourceAsync(ConnectDataSourceInput connectDataSourceInput, final ApiCallback<ConnectDataSourceResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = connectDataSourceValidateBeforeCall(connectDataSourceInput, _callback);
        Type localVarReturnType = new TypeToken<ConnectDataSourceResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class ConnectDataSourceRequestBuilder {
        private final OANSCZGF authentication;
        private SyncOptions syncOptions;

        private ConnectDataSourceRequestBuilder(OANSCZGF authentication) {
            this.authentication = authentication;
        }

        /**
         * Set syncOptions
         * @param syncOptions  (optional)
         * @return ConnectDataSourceRequestBuilder
         */
        public ConnectDataSourceRequestBuilder syncOptions(SyncOptions syncOptions) {
            this.syncOptions = syncOptions;
            return this;
        }
        
        /**
         * Build call for connectDataSource
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            ConnectDataSourceInput connectDataSourceInput = buildBodyParams();
            return connectDataSourceCall(connectDataSourceInput, _callback);
        }

        private ConnectDataSourceInput buildBodyParams() {
            ConnectDataSourceInput connectDataSourceInput = new ConnectDataSourceInput();
            connectDataSourceInput.authentication(this.authentication);
            connectDataSourceInput.syncOptions(this.syncOptions);
            return connectDataSourceInput;
        }

        /**
         * Execute connectDataSource request
         * @return ConnectDataSourceResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public ConnectDataSourceResponse execute() throws ApiException {
            ConnectDataSourceInput connectDataSourceInput = buildBodyParams();
            ApiResponse<ConnectDataSourceResponse> localVarResp = connectDataSourceWithHttpInfo(connectDataSourceInput);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute connectDataSource request with HTTP info returned
         * @return ApiResponse&lt;ConnectDataSourceResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<ConnectDataSourceResponse> executeWithHttpInfo() throws ApiException {
            ConnectDataSourceInput connectDataSourceInput = buildBodyParams();
            return connectDataSourceWithHttpInfo(connectDataSourceInput);
        }

        /**
         * Execute connectDataSource request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<ConnectDataSourceResponse> _callback) throws ApiException {
            ConnectDataSourceInput connectDataSourceInput = buildBodyParams();
            return connectDataSourceAsync(connectDataSourceInput, _callback);
        }
    }

    /**
     * Connect Data Source
     * 
     * @param connectDataSourceInput  (required)
     * @return ConnectDataSourceRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
     </table>
     */
    public ConnectDataSourceRequestBuilder connectDataSource(OANSCZGF authentication) throws IllegalArgumentException {
        if (authentication == null) throw new IllegalArgumentException("\"authentication\" is required but got null");
        return new ConnectDataSourceRequestBuilder(authentication);
    }
    private okhttp3.Call connectFreshdeskCall(FreshDeskConnectRequest freshDeskConnectRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = freshDeskConnectRequest;

        // create path and map variables
        String localVarPath = "/integrations/freshdesk";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "accessToken", "apiKey", "customerId" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call connectFreshdeskValidateBeforeCall(FreshDeskConnectRequest freshDeskConnectRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'freshDeskConnectRequest' is set
        if (freshDeskConnectRequest == null) {
            throw new ApiException("Missing the required parameter 'freshDeskConnectRequest' when calling connectFreshdesk(Async)");
        }

        return connectFreshdeskCall(freshDeskConnectRequest, _callback);

    }


    private ApiResponse<GenericSuccessResponse> connectFreshdeskWithHttpInfo(FreshDeskConnectRequest freshDeskConnectRequest) throws ApiException {
        okhttp3.Call localVarCall = connectFreshdeskValidateBeforeCall(freshDeskConnectRequest, null);
        Type localVarReturnType = new TypeToken<GenericSuccessResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call connectFreshdeskAsync(FreshDeskConnectRequest freshDeskConnectRequest, final ApiCallback<GenericSuccessResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = connectFreshdeskValidateBeforeCall(freshDeskConnectRequest, _callback);
        Type localVarReturnType = new TypeToken<GenericSuccessResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class ConnectFreshdeskRequestBuilder {
        private final String domain;
        private final String apiKey;
        private Object tags;
        private Integer chunkSize;
        private Integer chunkOverlap;
        private Boolean skipEmbeddingGeneration;
        private EmbeddingGeneratorsNullable embeddingModel;
        private Boolean generateSparseVectors;
        private Boolean prependFilenameToChunks;
        private Boolean syncFilesOnConnection;
        private String requestId;
        private Boolean syncSourceItems;
        private FileSyncConfigNullable fileSyncConfig;

        private ConnectFreshdeskRequestBuilder(String domain, String apiKey) {
            this.domain = domain;
            this.apiKey = apiKey;
        }

        /**
         * Set tags
         * @param tags  (optional)
         * @return ConnectFreshdeskRequestBuilder
         */
        public ConnectFreshdeskRequestBuilder tags(Object tags) {
            this.tags = tags;
            return this;
        }
        
        /**
         * Set chunkSize
         * @param chunkSize  (optional, default to 1500)
         * @return ConnectFreshdeskRequestBuilder
         */
        public ConnectFreshdeskRequestBuilder chunkSize(Integer chunkSize) {
            this.chunkSize = chunkSize;
            return this;
        }
        
        /**
         * Set chunkOverlap
         * @param chunkOverlap  (optional, default to 20)
         * @return ConnectFreshdeskRequestBuilder
         */
        public ConnectFreshdeskRequestBuilder chunkOverlap(Integer chunkOverlap) {
            this.chunkOverlap = chunkOverlap;
            return this;
        }
        
        /**
         * Set skipEmbeddingGeneration
         * @param skipEmbeddingGeneration  (optional, default to false)
         * @return ConnectFreshdeskRequestBuilder
         */
        public ConnectFreshdeskRequestBuilder skipEmbeddingGeneration(Boolean skipEmbeddingGeneration) {
            this.skipEmbeddingGeneration = skipEmbeddingGeneration;
            return this;
        }
        
        /**
         * Set embeddingModel
         * @param embeddingModel  (optional, default to OPENAI)
         * @return ConnectFreshdeskRequestBuilder
         */
        public ConnectFreshdeskRequestBuilder embeddingModel(EmbeddingGeneratorsNullable embeddingModel) {
            this.embeddingModel = embeddingModel;
            return this;
        }
        
        /**
         * Set generateSparseVectors
         * @param generateSparseVectors  (optional, default to false)
         * @return ConnectFreshdeskRequestBuilder
         */
        public ConnectFreshdeskRequestBuilder generateSparseVectors(Boolean generateSparseVectors) {
            this.generateSparseVectors = generateSparseVectors;
            return this;
        }
        
        /**
         * Set prependFilenameToChunks
         * @param prependFilenameToChunks  (optional, default to false)
         * @return ConnectFreshdeskRequestBuilder
         */
        public ConnectFreshdeskRequestBuilder prependFilenameToChunks(Boolean prependFilenameToChunks) {
            this.prependFilenameToChunks = prependFilenameToChunks;
            return this;
        }
        
        /**
         * Set syncFilesOnConnection
         * @param syncFilesOnConnection  (optional, default to true)
         * @return ConnectFreshdeskRequestBuilder
         */
        public ConnectFreshdeskRequestBuilder syncFilesOnConnection(Boolean syncFilesOnConnection) {
            this.syncFilesOnConnection = syncFilesOnConnection;
            return this;
        }
        
        /**
         * Set requestId
         * @param requestId  (optional)
         * @return ConnectFreshdeskRequestBuilder
         */
        public ConnectFreshdeskRequestBuilder requestId(String requestId) {
            this.requestId = requestId;
            return this;
        }
        
        /**
         * Set syncSourceItems
         * @param syncSourceItems Enabling this flag will fetch all available content from the source to be listed via list items endpoint (optional, default to true)
         * @return ConnectFreshdeskRequestBuilder
         */
        public ConnectFreshdeskRequestBuilder syncSourceItems(Boolean syncSourceItems) {
            this.syncSourceItems = syncSourceItems;
            return this;
        }
        
        /**
         * Set fileSyncConfig
         * @param fileSyncConfig  (optional)
         * @return ConnectFreshdeskRequestBuilder
         */
        public ConnectFreshdeskRequestBuilder fileSyncConfig(FileSyncConfigNullable fileSyncConfig) {
            this.fileSyncConfig = fileSyncConfig;
            return this;
        }
        
        /**
         * Build call for connectFreshdesk
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            FreshDeskConnectRequest freshDeskConnectRequest = buildBodyParams();
            return connectFreshdeskCall(freshDeskConnectRequest, _callback);
        }

        private FreshDeskConnectRequest buildBodyParams() {
            FreshDeskConnectRequest freshDeskConnectRequest = new FreshDeskConnectRequest();
            freshDeskConnectRequest.tags(this.tags);
            freshDeskConnectRequest.domain(this.domain);
            freshDeskConnectRequest.apiKey(this.apiKey);
            freshDeskConnectRequest.chunkSize(this.chunkSize);
            freshDeskConnectRequest.chunkOverlap(this.chunkOverlap);
            freshDeskConnectRequest.skipEmbeddingGeneration(this.skipEmbeddingGeneration);
            freshDeskConnectRequest.embeddingModel(this.embeddingModel);
            freshDeskConnectRequest.generateSparseVectors(this.generateSparseVectors);
            freshDeskConnectRequest.prependFilenameToChunks(this.prependFilenameToChunks);
            freshDeskConnectRequest.syncFilesOnConnection(this.syncFilesOnConnection);
            freshDeskConnectRequest.requestId(this.requestId);
            freshDeskConnectRequest.syncSourceItems(this.syncSourceItems);
            freshDeskConnectRequest.fileSyncConfig(this.fileSyncConfig);
            return freshDeskConnectRequest;
        }

        /**
         * Execute connectFreshdesk request
         * @return GenericSuccessResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public GenericSuccessResponse execute() throws ApiException {
            FreshDeskConnectRequest freshDeskConnectRequest = buildBodyParams();
            ApiResponse<GenericSuccessResponse> localVarResp = connectFreshdeskWithHttpInfo(freshDeskConnectRequest);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute connectFreshdesk request with HTTP info returned
         * @return ApiResponse&lt;GenericSuccessResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<GenericSuccessResponse> executeWithHttpInfo() throws ApiException {
            FreshDeskConnectRequest freshDeskConnectRequest = buildBodyParams();
            return connectFreshdeskWithHttpInfo(freshDeskConnectRequest);
        }

        /**
         * Execute connectFreshdesk request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<GenericSuccessResponse> _callback) throws ApiException {
            FreshDeskConnectRequest freshDeskConnectRequest = buildBodyParams();
            return connectFreshdeskAsync(freshDeskConnectRequest, _callback);
        }
    }

    /**
     * Freshdesk Connect
     * Refer this article to obtain an API key https://support.freshdesk.com/en/support/solutions/articles/215517. Make sure that your API key has the permission to read solutions from your account and you are on a &lt;b&gt;paid&lt;/b&gt; plan. Once you have an API key, you can make a request to this endpoint along with your freshdesk domain. This will  trigger an automatic sync of the articles in your \&quot;solutions\&quot; tab. Additional parameters below can be used to associate  data with the synced articles or modify the sync behavior.
     * @param freshDeskConnectRequest  (required)
     * @return ConnectFreshdeskRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
     </table>
     */
    public ConnectFreshdeskRequestBuilder connectFreshdesk(String domain, String apiKey) throws IllegalArgumentException {
        if (domain == null) throw new IllegalArgumentException("\"domain\" is required but got null");
            

        if (apiKey == null) throw new IllegalArgumentException("\"apiKey\" is required but got null");
            

        return new ConnectFreshdeskRequestBuilder(domain, apiKey);
    }
    private okhttp3.Call connectGitbookCall(GitbookConnectRequest gitbookConnectRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = gitbookConnectRequest;

        // create path and map variables
        String localVarPath = "/integrations/gitbook";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "accessToken", "apiKey", "customerId" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call connectGitbookValidateBeforeCall(GitbookConnectRequest gitbookConnectRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'gitbookConnectRequest' is set
        if (gitbookConnectRequest == null) {
            throw new ApiException("Missing the required parameter 'gitbookConnectRequest' when calling connectGitbook(Async)");
        }

        return connectGitbookCall(gitbookConnectRequest, _callback);

    }


    private ApiResponse<GenericSuccessResponse> connectGitbookWithHttpInfo(GitbookConnectRequest gitbookConnectRequest) throws ApiException {
        okhttp3.Call localVarCall = connectGitbookValidateBeforeCall(gitbookConnectRequest, null);
        Type localVarReturnType = new TypeToken<GenericSuccessResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call connectGitbookAsync(GitbookConnectRequest gitbookConnectRequest, final ApiCallback<GenericSuccessResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = connectGitbookValidateBeforeCall(gitbookConnectRequest, _callback);
        Type localVarReturnType = new TypeToken<GenericSuccessResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class ConnectGitbookRequestBuilder {
        private final String organization;
        private final String accessToken;
        private Object tags;
        private Integer chunkSize;
        private Integer chunkOverlap;
        private Boolean skipEmbeddingGeneration;
        private EmbeddingGenerators embeddingModel;
        private Boolean generateSparseVectors;
        private Boolean prependFilenameToChunks;
        private Boolean syncFilesOnConnection;
        private String requestId;
        private Boolean syncSourceItems;

        private ConnectGitbookRequestBuilder(String organization, String accessToken) {
            this.organization = organization;
            this.accessToken = accessToken;
        }

        /**
         * Set tags
         * @param tags  (optional)
         * @return ConnectGitbookRequestBuilder
         */
        public ConnectGitbookRequestBuilder tags(Object tags) {
            this.tags = tags;
            return this;
        }
        
        /**
         * Set chunkSize
         * @param chunkSize  (optional, default to 1500)
         * @return ConnectGitbookRequestBuilder
         */
        public ConnectGitbookRequestBuilder chunkSize(Integer chunkSize) {
            this.chunkSize = chunkSize;
            return this;
        }
        
        /**
         * Set chunkOverlap
         * @param chunkOverlap  (optional, default to 20)
         * @return ConnectGitbookRequestBuilder
         */
        public ConnectGitbookRequestBuilder chunkOverlap(Integer chunkOverlap) {
            this.chunkOverlap = chunkOverlap;
            return this;
        }
        
        /**
         * Set skipEmbeddingGeneration
         * @param skipEmbeddingGeneration  (optional, default to false)
         * @return ConnectGitbookRequestBuilder
         */
        public ConnectGitbookRequestBuilder skipEmbeddingGeneration(Boolean skipEmbeddingGeneration) {
            this.skipEmbeddingGeneration = skipEmbeddingGeneration;
            return this;
        }
        
        /**
         * Set embeddingModel
         * @param embeddingModel  (optional)
         * @return ConnectGitbookRequestBuilder
         */
        public ConnectGitbookRequestBuilder embeddingModel(EmbeddingGenerators embeddingModel) {
            this.embeddingModel = embeddingModel;
            return this;
        }
        
        /**
         * Set generateSparseVectors
         * @param generateSparseVectors  (optional, default to false)
         * @return ConnectGitbookRequestBuilder
         */
        public ConnectGitbookRequestBuilder generateSparseVectors(Boolean generateSparseVectors) {
            this.generateSparseVectors = generateSparseVectors;
            return this;
        }
        
        /**
         * Set prependFilenameToChunks
         * @param prependFilenameToChunks  (optional, default to false)
         * @return ConnectGitbookRequestBuilder
         */
        public ConnectGitbookRequestBuilder prependFilenameToChunks(Boolean prependFilenameToChunks) {
            this.prependFilenameToChunks = prependFilenameToChunks;
            return this;
        }
        
        /**
         * Set syncFilesOnConnection
         * @param syncFilesOnConnection  (optional, default to true)
         * @return ConnectGitbookRequestBuilder
         */
        public ConnectGitbookRequestBuilder syncFilesOnConnection(Boolean syncFilesOnConnection) {
            this.syncFilesOnConnection = syncFilesOnConnection;
            return this;
        }
        
        /**
         * Set requestId
         * @param requestId  (optional)
         * @return ConnectGitbookRequestBuilder
         */
        public ConnectGitbookRequestBuilder requestId(String requestId) {
            this.requestId = requestId;
            return this;
        }
        
        /**
         * Set syncSourceItems
         * @param syncSourceItems Enabling this flag will fetch all available content from the source to be listed via list items endpoint (optional, default to true)
         * @return ConnectGitbookRequestBuilder
         */
        public ConnectGitbookRequestBuilder syncSourceItems(Boolean syncSourceItems) {
            this.syncSourceItems = syncSourceItems;
            return this;
        }
        
        /**
         * Build call for connectGitbook
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            GitbookConnectRequest gitbookConnectRequest = buildBodyParams();
            return connectGitbookCall(gitbookConnectRequest, _callback);
        }

        private GitbookConnectRequest buildBodyParams() {
            GitbookConnectRequest gitbookConnectRequest = new GitbookConnectRequest();
            gitbookConnectRequest.tags(this.tags);
            gitbookConnectRequest.organization(this.organization);
            gitbookConnectRequest.accessToken(this.accessToken);
            gitbookConnectRequest.chunkSize(this.chunkSize);
            gitbookConnectRequest.chunkOverlap(this.chunkOverlap);
            gitbookConnectRequest.skipEmbeddingGeneration(this.skipEmbeddingGeneration);
            gitbookConnectRequest.embeddingModel(this.embeddingModel);
            gitbookConnectRequest.generateSparseVectors(this.generateSparseVectors);
            gitbookConnectRequest.prependFilenameToChunks(this.prependFilenameToChunks);
            gitbookConnectRequest.syncFilesOnConnection(this.syncFilesOnConnection);
            gitbookConnectRequest.requestId(this.requestId);
            gitbookConnectRequest.syncSourceItems(this.syncSourceItems);
            return gitbookConnectRequest;
        }

        /**
         * Execute connectGitbook request
         * @return GenericSuccessResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public GenericSuccessResponse execute() throws ApiException {
            GitbookConnectRequest gitbookConnectRequest = buildBodyParams();
            ApiResponse<GenericSuccessResponse> localVarResp = connectGitbookWithHttpInfo(gitbookConnectRequest);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute connectGitbook request with HTTP info returned
         * @return ApiResponse&lt;GenericSuccessResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<GenericSuccessResponse> executeWithHttpInfo() throws ApiException {
            GitbookConnectRequest gitbookConnectRequest = buildBodyParams();
            return connectGitbookWithHttpInfo(gitbookConnectRequest);
        }

        /**
         * Execute connectGitbook request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<GenericSuccessResponse> _callback) throws ApiException {
            GitbookConnectRequest gitbookConnectRequest = buildBodyParams();
            return connectGitbookAsync(gitbookConnectRequest, _callback);
        }
    }

    /**
     * Gitbook Connect
     * You will need an access token to connect your Gitbook account. Note that the permissions will be defined by the user  generating access token so make sure you have the permission to access spaces you will be syncing.  Refer this article for more details https://developer.gitbook.com/gitbook-api/authentication. Additionally, you need to specify the name of organization you will be syncing data from.
     * @param gitbookConnectRequest  (required)
     * @return ConnectGitbookRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
     </table>
     */
    public ConnectGitbookRequestBuilder connectGitbook(String organization, String accessToken) throws IllegalArgumentException {
        if (organization == null) throw new IllegalArgumentException("\"organization\" is required but got null");
            

        if (accessToken == null) throw new IllegalArgumentException("\"accessToken\" is required but got null");
            

        return new ConnectGitbookRequestBuilder(organization, accessToken);
    }
    private okhttp3.Call createAwsIamUserCall(S3AuthRequest s3AuthRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = s3AuthRequest;

        // create path and map variables
        String localVarPath = "/integrations/s3";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "accessToken", "apiKey", "customerId" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call createAwsIamUserValidateBeforeCall(S3AuthRequest s3AuthRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 's3AuthRequest' is set
        if (s3AuthRequest == null) {
            throw new ApiException("Missing the required parameter 's3AuthRequest' when calling createAwsIamUser(Async)");
        }

        return createAwsIamUserCall(s3AuthRequest, _callback);

    }


    private ApiResponse<OrganizationUserDataSourceAPI> createAwsIamUserWithHttpInfo(S3AuthRequest s3AuthRequest) throws ApiException {
        okhttp3.Call localVarCall = createAwsIamUserValidateBeforeCall(s3AuthRequest, null);
        Type localVarReturnType = new TypeToken<OrganizationUserDataSourceAPI>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call createAwsIamUserAsync(S3AuthRequest s3AuthRequest, final ApiCallback<OrganizationUserDataSourceAPI> _callback) throws ApiException {

        okhttp3.Call localVarCall = createAwsIamUserValidateBeforeCall(s3AuthRequest, _callback);
        Type localVarReturnType = new TypeToken<OrganizationUserDataSourceAPI>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class CreateAwsIamUserRequestBuilder {
        private final String accessKey;
        private final String accessKeySecret;
        private Boolean syncSourceItems;

        private CreateAwsIamUserRequestBuilder(String accessKey, String accessKeySecret) {
            this.accessKey = accessKey;
            this.accessKeySecret = accessKeySecret;
        }

        /**
         * Set syncSourceItems
         * @param syncSourceItems Enabling this flag will fetch all available content from the source to be listed via list items endpoint (optional, default to true)
         * @return CreateAwsIamUserRequestBuilder
         */
        public CreateAwsIamUserRequestBuilder syncSourceItems(Boolean syncSourceItems) {
            this.syncSourceItems = syncSourceItems;
            return this;
        }
        
        /**
         * Build call for createAwsIamUser
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            S3AuthRequest s3AuthRequest = buildBodyParams();
            return createAwsIamUserCall(s3AuthRequest, _callback);
        }

        private S3AuthRequest buildBodyParams() {
            S3AuthRequest s3AuthRequest = new S3AuthRequest();
            s3AuthRequest.accessKey(this.accessKey);
            s3AuthRequest.accessKeySecret(this.accessKeySecret);
            s3AuthRequest.syncSourceItems(this.syncSourceItems);
            return s3AuthRequest;
        }

        /**
         * Execute createAwsIamUser request
         * @return OrganizationUserDataSourceAPI
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public OrganizationUserDataSourceAPI execute() throws ApiException {
            S3AuthRequest s3AuthRequest = buildBodyParams();
            ApiResponse<OrganizationUserDataSourceAPI> localVarResp = createAwsIamUserWithHttpInfo(s3AuthRequest);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute createAwsIamUser request with HTTP info returned
         * @return ApiResponse&lt;OrganizationUserDataSourceAPI&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<OrganizationUserDataSourceAPI> executeWithHttpInfo() throws ApiException {
            S3AuthRequest s3AuthRequest = buildBodyParams();
            return createAwsIamUserWithHttpInfo(s3AuthRequest);
        }

        /**
         * Execute createAwsIamUser request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<OrganizationUserDataSourceAPI> _callback) throws ApiException {
            S3AuthRequest s3AuthRequest = buildBodyParams();
            return createAwsIamUserAsync(s3AuthRequest, _callback);
        }
    }

    /**
     * S3 Auth
     * Create a new IAM user with permissions to: &lt;ol&gt; &lt;li&gt;List all buckets.&lt;/li&gt; &lt;li&gt;Read from the specific buckets and objects to sync with Carbon. Ensure any future buckets or objects carry  the same permissions.&lt;/li&gt; &lt;/ol&gt; Once created, generate an access key for this user and share the credentials with us. We recommend testing this key beforehand.
     * @param s3AuthRequest  (required)
     * @return CreateAwsIamUserRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
     </table>
     */
    public CreateAwsIamUserRequestBuilder createAwsIamUser(String accessKey, String accessKeySecret) throws IllegalArgumentException {
        if (accessKey == null) throw new IllegalArgumentException("\"accessKey\" is required but got null");
            

        if (accessKeySecret == null) throw new IllegalArgumentException("\"accessKeySecret\" is required but got null");
            

        return new CreateAwsIamUserRequestBuilder(accessKey, accessKeySecret);
    }
    private okhttp3.Call getOauthUrlCall(OAuthURLRequest oauthURLRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = oauthURLRequest;

        // create path and map variables
        String localVarPath = "/integrations/oauth_url";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "accessToken", "apiKey", "customerId" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getOauthUrlValidateBeforeCall(OAuthURLRequest oauthURLRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'oauthURLRequest' is set
        if (oauthURLRequest == null) {
            throw new ApiException("Missing the required parameter 'oauthURLRequest' when calling getOauthUrl(Async)");
        }

        return getOauthUrlCall(oauthURLRequest, _callback);

    }


    private ApiResponse<OuthURLResponse> getOauthUrlWithHttpInfo(OAuthURLRequest oauthURLRequest) throws ApiException {
        okhttp3.Call localVarCall = getOauthUrlValidateBeforeCall(oauthURLRequest, null);
        Type localVarReturnType = new TypeToken<OuthURLResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getOauthUrlAsync(OAuthURLRequest oauthURLRequest, final ApiCallback<OuthURLResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getOauthUrlValidateBeforeCall(oauthURLRequest, _callback);
        Type localVarReturnType = new TypeToken<OuthURLResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class GetOauthUrlRequestBuilder {
        private final DataSourceType service;
        private Object tags;
        private String scope;
        private Integer chunkSize;
        private Integer chunkOverlap;
        private Boolean skipEmbeddingGeneration;
        private EmbeddingGeneratorsNullable embeddingModel;
        private String zendeskSubdomain;
        private String microsoftTenant;
        private String sharepointSiteName;
        private String confluenceSubdomain;
        private Boolean generateSparseVectors;
        private Boolean prependFilenameToChunks;
        private Integer maxItemsPerChunk;
        private String salesforceDomain;
        private Boolean syncFilesOnConnection;
        private Boolean setPageAsBoundary;
        private Integer dataSourceId;
        private Boolean connectingNewAccount;
        private String requestId;
        private Boolean useOcr;
        private Boolean parsePdfTablesWithOcr;
        private Boolean enableFilePicker;
        private Boolean syncSourceItems;
        private Boolean incrementalSync;
        private FileSyncConfigNullable fileSyncConfig;

        private GetOauthUrlRequestBuilder(DataSourceType service) {
            this.service = service;
        }

        /**
         * Set tags
         * @param tags  (optional)
         * @return GetOauthUrlRequestBuilder
         */
        public GetOauthUrlRequestBuilder tags(Object tags) {
            this.tags = tags;
            return this;
        }
        
        /**
         * Set scope
         * @param scope  (optional)
         * @return GetOauthUrlRequestBuilder
         */
        public GetOauthUrlRequestBuilder scope(String scope) {
            this.scope = scope;
            return this;
        }
        
        /**
         * Set chunkSize
         * @param chunkSize  (optional, default to 1500)
         * @return GetOauthUrlRequestBuilder
         */
        public GetOauthUrlRequestBuilder chunkSize(Integer chunkSize) {
            this.chunkSize = chunkSize;
            return this;
        }
        
        /**
         * Set chunkOverlap
         * @param chunkOverlap  (optional, default to 20)
         * @return GetOauthUrlRequestBuilder
         */
        public GetOauthUrlRequestBuilder chunkOverlap(Integer chunkOverlap) {
            this.chunkOverlap = chunkOverlap;
            return this;
        }
        
        /**
         * Set skipEmbeddingGeneration
         * @param skipEmbeddingGeneration  (optional, default to false)
         * @return GetOauthUrlRequestBuilder
         */
        public GetOauthUrlRequestBuilder skipEmbeddingGeneration(Boolean skipEmbeddingGeneration) {
            this.skipEmbeddingGeneration = skipEmbeddingGeneration;
            return this;
        }
        
        /**
         * Set embeddingModel
         * @param embeddingModel  (optional, default to OPENAI)
         * @return GetOauthUrlRequestBuilder
         */
        public GetOauthUrlRequestBuilder embeddingModel(EmbeddingGeneratorsNullable embeddingModel) {
            this.embeddingModel = embeddingModel;
            return this;
        }
        
        /**
         * Set zendeskSubdomain
         * @param zendeskSubdomain  (optional)
         * @return GetOauthUrlRequestBuilder
         */
        public GetOauthUrlRequestBuilder zendeskSubdomain(String zendeskSubdomain) {
            this.zendeskSubdomain = zendeskSubdomain;
            return this;
        }
        
        /**
         * Set microsoftTenant
         * @param microsoftTenant  (optional)
         * @return GetOauthUrlRequestBuilder
         */
        public GetOauthUrlRequestBuilder microsoftTenant(String microsoftTenant) {
            this.microsoftTenant = microsoftTenant;
            return this;
        }
        
        /**
         * Set sharepointSiteName
         * @param sharepointSiteName  (optional)
         * @return GetOauthUrlRequestBuilder
         */
        public GetOauthUrlRequestBuilder sharepointSiteName(String sharepointSiteName) {
            this.sharepointSiteName = sharepointSiteName;
            return this;
        }
        
        /**
         * Set confluenceSubdomain
         * @param confluenceSubdomain  (optional)
         * @return GetOauthUrlRequestBuilder
         */
        public GetOauthUrlRequestBuilder confluenceSubdomain(String confluenceSubdomain) {
            this.confluenceSubdomain = confluenceSubdomain;
            return this;
        }
        
        /**
         * Set generateSparseVectors
         * @param generateSparseVectors  (optional, default to false)
         * @return GetOauthUrlRequestBuilder
         */
        public GetOauthUrlRequestBuilder generateSparseVectors(Boolean generateSparseVectors) {
            this.generateSparseVectors = generateSparseVectors;
            return this;
        }
        
        /**
         * Set prependFilenameToChunks
         * @param prependFilenameToChunks  (optional, default to false)
         * @return GetOauthUrlRequestBuilder
         */
        public GetOauthUrlRequestBuilder prependFilenameToChunks(Boolean prependFilenameToChunks) {
            this.prependFilenameToChunks = prependFilenameToChunks;
            return this;
        }
        
        /**
         * Set maxItemsPerChunk
         * @param maxItemsPerChunk Number of objects per chunk. For csv, tsv, xlsx, and json files only. (optional)
         * @return GetOauthUrlRequestBuilder
         */
        public GetOauthUrlRequestBuilder maxItemsPerChunk(Integer maxItemsPerChunk) {
            this.maxItemsPerChunk = maxItemsPerChunk;
            return this;
        }
        
        /**
         * Set salesforceDomain
         * @param salesforceDomain  (optional)
         * @return GetOauthUrlRequestBuilder
         */
        public GetOauthUrlRequestBuilder salesforceDomain(String salesforceDomain) {
            this.salesforceDomain = salesforceDomain;
            return this;
        }
        
        /**
         * Set syncFilesOnConnection
         * @param syncFilesOnConnection Used to specify whether Carbon should attempt to sync all your files automatically when authorization         is complete. This is only supported for a subset of connectors and will be ignored for the rest. Supported         connectors: Intercom, Zendesk, Gitbook, Confluence, Salesforce, Freshdesk (optional, default to true)
         * @return GetOauthUrlRequestBuilder
         */
        public GetOauthUrlRequestBuilder syncFilesOnConnection(Boolean syncFilesOnConnection) {
            this.syncFilesOnConnection = syncFilesOnConnection;
            return this;
        }
        
        /**
         * Set setPageAsBoundary
         * @param setPageAsBoundary  (optional, default to false)
         * @return GetOauthUrlRequestBuilder
         */
        public GetOauthUrlRequestBuilder setPageAsBoundary(Boolean setPageAsBoundary) {
            this.setPageAsBoundary = setPageAsBoundary;
            return this;
        }
        
        /**
         * Set dataSourceId
         * @param dataSourceId Used to specify a data source to sync from if you have multiple connected. It can be skipped if          you only have one data source of that type connected or are connecting a new account. (optional)
         * @return GetOauthUrlRequestBuilder
         */
        public GetOauthUrlRequestBuilder dataSourceId(Integer dataSourceId) {
            this.dataSourceId = dataSourceId;
            return this;
        }
        
        /**
         * Set connectingNewAccount
         * @param connectingNewAccount Used to connect a new data source. If not specified, we will attempt to create a sync URL         for an existing data source based on type and ID. (optional, default to false)
         * @return GetOauthUrlRequestBuilder
         */
        public GetOauthUrlRequestBuilder connectingNewAccount(Boolean connectingNewAccount) {
            this.connectingNewAccount = connectingNewAccount;
            return this;
        }
        
        /**
         * Set requestId
         * @param requestId This request id will be added to all files that get synced using the generated OAuth URL (optional, default to ce1b1ec8-be64-491c-9159-c40f85fa0073)
         * @return GetOauthUrlRequestBuilder
         */
        public GetOauthUrlRequestBuilder requestId(String requestId) {
            this.requestId = requestId;
            return this;
        }
        
        /**
         * Set useOcr
         * @param useOcr Enable OCR for files that support it. Supported formats: pdf (optional, default to false)
         * @return GetOauthUrlRequestBuilder
         */
        public GetOauthUrlRequestBuilder useOcr(Boolean useOcr) {
            this.useOcr = useOcr;
            return this;
        }
        
        /**
         * Set parsePdfTablesWithOcr
         * @param parsePdfTablesWithOcr  (optional, default to false)
         * @return GetOauthUrlRequestBuilder
         */
        public GetOauthUrlRequestBuilder parsePdfTablesWithOcr(Boolean parsePdfTablesWithOcr) {
            this.parsePdfTablesWithOcr = parsePdfTablesWithOcr;
            return this;
        }
        
        /**
         * Set enableFilePicker
         * @param enableFilePicker Enable integration&#39;s file picker for sources that support it. Supported sources: DROPBOX, SHAREPOINT, ONEDRIVE, BOX, GOOGLE_DRIVE (optional, default to true)
         * @return GetOauthUrlRequestBuilder
         */
        public GetOauthUrlRequestBuilder enableFilePicker(Boolean enableFilePicker) {
            this.enableFilePicker = enableFilePicker;
            return this;
        }
        
        /**
         * Set syncSourceItems
         * @param syncSourceItems Enabling this flag will fetch all available content from the source to be listed via list items endpoint (optional, default to true)
         * @return GetOauthUrlRequestBuilder
         */
        public GetOauthUrlRequestBuilder syncSourceItems(Boolean syncSourceItems) {
            this.syncSourceItems = syncSourceItems;
            return this;
        }
        
        /**
         * Set incrementalSync
         * @param incrementalSync Only sync files if they have not already been synced or if the embedding properties have changed.         This flag is currently supported by ONEDRIVE, GOOGLE_DRIVE, BOX, DROPBOX. It will be ignored for other data sources. (optional, default to false)
         * @return GetOauthUrlRequestBuilder
         */
        public GetOauthUrlRequestBuilder incrementalSync(Boolean incrementalSync) {
            this.incrementalSync = incrementalSync;
            return this;
        }
        
        /**
         * Set fileSyncConfig
         * @param fileSyncConfig  (optional)
         * @return GetOauthUrlRequestBuilder
         */
        public GetOauthUrlRequestBuilder fileSyncConfig(FileSyncConfigNullable fileSyncConfig) {
            this.fileSyncConfig = fileSyncConfig;
            return this;
        }
        
        /**
         * Build call for getOauthUrl
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            OAuthURLRequest oauthURLRequest = buildBodyParams();
            return getOauthUrlCall(oauthURLRequest, _callback);
        }

        private OAuthURLRequest buildBodyParams() {
            OAuthURLRequest oauthURLRequest = new OAuthURLRequest();
            oauthURLRequest.tags(this.tags);
            oauthURLRequest.scope(this.scope);
            oauthURLRequest.service(this.service);
            oauthURLRequest.chunkSize(this.chunkSize);
            oauthURLRequest.chunkOverlap(this.chunkOverlap);
            oauthURLRequest.skipEmbeddingGeneration(this.skipEmbeddingGeneration);
            oauthURLRequest.embeddingModel(this.embeddingModel);
            oauthURLRequest.zendeskSubdomain(this.zendeskSubdomain);
            oauthURLRequest.microsoftTenant(this.microsoftTenant);
            oauthURLRequest.sharepointSiteName(this.sharepointSiteName);
            oauthURLRequest.confluenceSubdomain(this.confluenceSubdomain);
            oauthURLRequest.generateSparseVectors(this.generateSparseVectors);
            oauthURLRequest.prependFilenameToChunks(this.prependFilenameToChunks);
            oauthURLRequest.maxItemsPerChunk(this.maxItemsPerChunk);
            oauthURLRequest.salesforceDomain(this.salesforceDomain);
            oauthURLRequest.syncFilesOnConnection(this.syncFilesOnConnection);
            oauthURLRequest.setPageAsBoundary(this.setPageAsBoundary);
            oauthURLRequest.dataSourceId(this.dataSourceId);
            oauthURLRequest.connectingNewAccount(this.connectingNewAccount);
            oauthURLRequest.requestId(this.requestId);
            oauthURLRequest.useOcr(this.useOcr);
            oauthURLRequest.parsePdfTablesWithOcr(this.parsePdfTablesWithOcr);
            oauthURLRequest.enableFilePicker(this.enableFilePicker);
            oauthURLRequest.syncSourceItems(this.syncSourceItems);
            oauthURLRequest.incrementalSync(this.incrementalSync);
            oauthURLRequest.fileSyncConfig(this.fileSyncConfig);
            return oauthURLRequest;
        }

        /**
         * Execute getOauthUrl request
         * @return OuthURLResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public OuthURLResponse execute() throws ApiException {
            OAuthURLRequest oauthURLRequest = buildBodyParams();
            ApiResponse<OuthURLResponse> localVarResp = getOauthUrlWithHttpInfo(oauthURLRequest);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute getOauthUrl request with HTTP info returned
         * @return ApiResponse&lt;OuthURLResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<OuthURLResponse> executeWithHttpInfo() throws ApiException {
            OAuthURLRequest oauthURLRequest = buildBodyParams();
            return getOauthUrlWithHttpInfo(oauthURLRequest);
        }

        /**
         * Execute getOauthUrl request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<OuthURLResponse> _callback) throws ApiException {
            OAuthURLRequest oauthURLRequest = buildBodyParams();
            return getOauthUrlAsync(oauthURLRequest, _callback);
        }
    }

    /**
     * Get Oauth Url
     * This endpoint can be used to generate the following URLs - An OAuth URL for OAuth based connectors - A file syncing URL which skips the OAuth flow if the user already has a valid access token and takes them to the success state.
     * @param oauthURLRequest  (required)
     * @return GetOauthUrlRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
     </table>
     */
    public GetOauthUrlRequestBuilder getOauthUrl(DataSourceType service) throws IllegalArgumentException {
        if (service == null) throw new IllegalArgumentException("\"service\" is required but got null");
        return new GetOauthUrlRequestBuilder(service);
    }
    private okhttp3.Call listConfluencePagesCall(ListRequest listRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = listRequest;

        // create path and map variables
        String localVarPath = "/integrations/confluence/list";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "accessToken", "apiKey", "customerId" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call listConfluencePagesValidateBeforeCall(ListRequest listRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'listRequest' is set
        if (listRequest == null) {
            throw new ApiException("Missing the required parameter 'listRequest' when calling listConfluencePages(Async)");
        }

        return listConfluencePagesCall(listRequest, _callback);

    }


    private ApiResponse<ListResponse> listConfluencePagesWithHttpInfo(ListRequest listRequest) throws ApiException {
        okhttp3.Call localVarCall = listConfluencePagesValidateBeforeCall(listRequest, null);
        Type localVarReturnType = new TypeToken<ListResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call listConfluencePagesAsync(ListRequest listRequest, final ApiCallback<ListResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = listConfluencePagesValidateBeforeCall(listRequest, _callback);
        Type localVarReturnType = new TypeToken<ListResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class ListConfluencePagesRequestBuilder {
        private final Integer dataSourceId;
        private String parentId;

        private ListConfluencePagesRequestBuilder(Integer dataSourceId) {
            this.dataSourceId = dataSourceId;
        }

        /**
         * Set parentId
         * @param parentId  (optional)
         * @return ListConfluencePagesRequestBuilder
         */
        public ListConfluencePagesRequestBuilder parentId(String parentId) {
            this.parentId = parentId;
            return this;
        }
        
        /**
         * Build call for listConfluencePages
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            ListRequest listRequest = buildBodyParams();
            return listConfluencePagesCall(listRequest, _callback);
        }

        private ListRequest buildBodyParams() {
            ListRequest listRequest = new ListRequest();
            listRequest.dataSourceId(this.dataSourceId);
            listRequest.parentId(this.parentId);
            return listRequest;
        }

        /**
         * Execute listConfluencePages request
         * @return ListResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public ListResponse execute() throws ApiException {
            ListRequest listRequest = buildBodyParams();
            ApiResponse<ListResponse> localVarResp = listConfluencePagesWithHttpInfo(listRequest);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute listConfluencePages request with HTTP info returned
         * @return ApiResponse&lt;ListResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<ListResponse> executeWithHttpInfo() throws ApiException {
            ListRequest listRequest = buildBodyParams();
            return listConfluencePagesWithHttpInfo(listRequest);
        }

        /**
         * Execute listConfluencePages request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<ListResponse> _callback) throws ApiException {
            ListRequest listRequest = buildBodyParams();
            return listConfluencePagesAsync(listRequest, _callback);
        }
    }

    /**
     * Confluence List
     * To begin listing a user&#39;s Confluence pages, at least a &#x60;data_source_id&#x60; of a connected Confluence account must be specified. This base request returns a list of root pages for every space the user has access to in a Confluence instance. To traverse further down the user&#39;s page directory, additional requests to this endpoint can be made with the same &#x60;data_source_id&#x60; and with &#x60;parent_id&#x60; set to the id of page from a previous request. For convenience, the &#x60;has_children&#x60; property in each directory item in the response list will flag which pages will return non-empty lists of pages when set as the &#x60;parent_id&#x60;.
     * @param listRequest  (required)
     * @return ListConfluencePagesRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
     </table>
     */
    public ListConfluencePagesRequestBuilder listConfluencePages(Integer dataSourceId) throws IllegalArgumentException {
        if (dataSourceId == null) throw new IllegalArgumentException("\"dataSourceId\" is required but got null");
        return new ListConfluencePagesRequestBuilder(dataSourceId);
    }
    private okhttp3.Call listDataSourceItemsCall(ListDataSourceItemsRequest listDataSourceItemsRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = listDataSourceItemsRequest;

        // create path and map variables
        String localVarPath = "/integrations/items/list";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "accessToken", "apiKey", "customerId" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call listDataSourceItemsValidateBeforeCall(ListDataSourceItemsRequest listDataSourceItemsRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'listDataSourceItemsRequest' is set
        if (listDataSourceItemsRequest == null) {
            throw new ApiException("Missing the required parameter 'listDataSourceItemsRequest' when calling listDataSourceItems(Async)");
        }

        return listDataSourceItemsCall(listDataSourceItemsRequest, _callback);

    }


    private ApiResponse<ListDataSourceItemsResponse> listDataSourceItemsWithHttpInfo(ListDataSourceItemsRequest listDataSourceItemsRequest) throws ApiException {
        okhttp3.Call localVarCall = listDataSourceItemsValidateBeforeCall(listDataSourceItemsRequest, null);
        Type localVarReturnType = new TypeToken<ListDataSourceItemsResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call listDataSourceItemsAsync(ListDataSourceItemsRequest listDataSourceItemsRequest, final ApiCallback<ListDataSourceItemsResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = listDataSourceItemsValidateBeforeCall(listDataSourceItemsRequest, _callback);
        Type localVarReturnType = new TypeToken<ListDataSourceItemsResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class ListDataSourceItemsRequestBuilder {
        private final Integer dataSourceId;
        private String parentId;
        private ListItemsFiltersNullable filters;
        private Pagination pagination;
        private ExternalSourceItemsOrderBy orderBy;
        private OrderDirV2 orderDir;

        private ListDataSourceItemsRequestBuilder(Integer dataSourceId) {
            this.dataSourceId = dataSourceId;
        }

        /**
         * Set parentId
         * @param parentId  (optional)
         * @return ListDataSourceItemsRequestBuilder
         */
        public ListDataSourceItemsRequestBuilder parentId(String parentId) {
            this.parentId = parentId;
            return this;
        }
        
        /**
         * Set filters
         * @param filters  (optional)
         * @return ListDataSourceItemsRequestBuilder
         */
        public ListDataSourceItemsRequestBuilder filters(ListItemsFiltersNullable filters) {
            this.filters = filters;
            return this;
        }
        
        /**
         * Set pagination
         * @param pagination  (optional)
         * @return ListDataSourceItemsRequestBuilder
         */
        public ListDataSourceItemsRequestBuilder pagination(Pagination pagination) {
            this.pagination = pagination;
            return this;
        }
        
        /**
         * Set orderBy
         * @param orderBy  (optional)
         * @return ListDataSourceItemsRequestBuilder
         */
        public ListDataSourceItemsRequestBuilder orderBy(ExternalSourceItemsOrderBy orderBy) {
            this.orderBy = orderBy;
            return this;
        }
        
        /**
         * Set orderDir
         * @param orderDir  (optional)
         * @return ListDataSourceItemsRequestBuilder
         */
        public ListDataSourceItemsRequestBuilder orderDir(OrderDirV2 orderDir) {
            this.orderDir = orderDir;
            return this;
        }
        
        /**
         * Build call for listDataSourceItems
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            ListDataSourceItemsRequest listDataSourceItemsRequest = buildBodyParams();
            return listDataSourceItemsCall(listDataSourceItemsRequest, _callback);
        }

        private ListDataSourceItemsRequest buildBodyParams() {
            ListDataSourceItemsRequest listDataSourceItemsRequest = new ListDataSourceItemsRequest();
            listDataSourceItemsRequest.dataSourceId(this.dataSourceId);
            listDataSourceItemsRequest.parentId(this.parentId);
            listDataSourceItemsRequest.filters(this.filters);
            listDataSourceItemsRequest.pagination(this.pagination);
            listDataSourceItemsRequest.orderBy(this.orderBy);
            listDataSourceItemsRequest.orderDir(this.orderDir);
            return listDataSourceItemsRequest;
        }

        /**
         * Execute listDataSourceItems request
         * @return ListDataSourceItemsResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public ListDataSourceItemsResponse execute() throws ApiException {
            ListDataSourceItemsRequest listDataSourceItemsRequest = buildBodyParams();
            ApiResponse<ListDataSourceItemsResponse> localVarResp = listDataSourceItemsWithHttpInfo(listDataSourceItemsRequest);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute listDataSourceItems request with HTTP info returned
         * @return ApiResponse&lt;ListDataSourceItemsResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<ListDataSourceItemsResponse> executeWithHttpInfo() throws ApiException {
            ListDataSourceItemsRequest listDataSourceItemsRequest = buildBodyParams();
            return listDataSourceItemsWithHttpInfo(listDataSourceItemsRequest);
        }

        /**
         * Execute listDataSourceItems request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<ListDataSourceItemsResponse> _callback) throws ApiException {
            ListDataSourceItemsRequest listDataSourceItemsRequest = buildBodyParams();
            return listDataSourceItemsAsync(listDataSourceItemsRequest, _callback);
        }
    }

    /**
     * List Data Source Items
     * 
     * @param listDataSourceItemsRequest  (required)
     * @return ListDataSourceItemsRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
     </table>
     */
    public ListDataSourceItemsRequestBuilder listDataSourceItems(Integer dataSourceId) throws IllegalArgumentException {
        if (dataSourceId == null) throw new IllegalArgumentException("\"dataSourceId\" is required but got null");
        return new ListDataSourceItemsRequestBuilder(dataSourceId);
    }
    private okhttp3.Call listFoldersCall(Integer dataSourceId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/integrations/outlook/user_folders";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (dataSourceId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("data_source_id", dataSourceId));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "accessToken", "apiKey", "customerId" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call listFoldersValidateBeforeCall(Integer dataSourceId, final ApiCallback _callback) throws ApiException {
        return listFoldersCall(dataSourceId, _callback);

    }


    private ApiResponse<Object> listFoldersWithHttpInfo(Integer dataSourceId) throws ApiException {
        okhttp3.Call localVarCall = listFoldersValidateBeforeCall(dataSourceId, null);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call listFoldersAsync(Integer dataSourceId, final ApiCallback<Object> _callback) throws ApiException {

        okhttp3.Call localVarCall = listFoldersValidateBeforeCall(dataSourceId, _callback);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class ListFoldersRequestBuilder {
        private Integer dataSourceId;

        private ListFoldersRequestBuilder() {
        }

        /**
         * Set dataSourceId
         * @param dataSourceId  (optional)
         * @return ListFoldersRequestBuilder
         */
        public ListFoldersRequestBuilder dataSourceId(Integer dataSourceId) {
            this.dataSourceId = dataSourceId;
            return this;
        }
        
        /**
         * Build call for listFolders
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return listFoldersCall(dataSourceId, _callback);
        }


        /**
         * Execute listFolders request
         * @return Object
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public Object execute() throws ApiException {
            ApiResponse<Object> localVarResp = listFoldersWithHttpInfo(dataSourceId);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute listFolders request with HTTP info returned
         * @return ApiResponse&lt;Object&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Object> executeWithHttpInfo() throws ApiException {
            return listFoldersWithHttpInfo(dataSourceId);
        }

        /**
         * Execute listFolders request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Object> _callback) throws ApiException {
            return listFoldersAsync(dataSourceId, _callback);
        }
    }

    /**
     * Outlook Folders
     * After connecting your Outlook account, you can use this endpoint to list all of your folders on outlook. This includes  both system folders like \&quot;inbox\&quot; and user created folders.
     * @return ListFoldersRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
     </table>
     */
    public ListFoldersRequestBuilder listFolders() throws IllegalArgumentException {
        return new ListFoldersRequestBuilder();
    }
    private okhttp3.Call listGitbookSpacesCall(Integer dataSourceId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/integrations/gitbook/spaces";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (dataSourceId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("data_source_id", dataSourceId));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "accessToken", "apiKey", "customerId" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call listGitbookSpacesValidateBeforeCall(Integer dataSourceId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'dataSourceId' is set
        if (dataSourceId == null) {
            throw new ApiException("Missing the required parameter 'dataSourceId' when calling listGitbookSpaces(Async)");
        }

        return listGitbookSpacesCall(dataSourceId, _callback);

    }


    private ApiResponse<Object> listGitbookSpacesWithHttpInfo(Integer dataSourceId) throws ApiException {
        okhttp3.Call localVarCall = listGitbookSpacesValidateBeforeCall(dataSourceId, null);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call listGitbookSpacesAsync(Integer dataSourceId, final ApiCallback<Object> _callback) throws ApiException {

        okhttp3.Call localVarCall = listGitbookSpacesValidateBeforeCall(dataSourceId, _callback);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class ListGitbookSpacesRequestBuilder {
        private final Integer dataSourceId;

        private ListGitbookSpacesRequestBuilder(Integer dataSourceId) {
            this.dataSourceId = dataSourceId;
        }

        /**
         * Build call for listGitbookSpaces
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return listGitbookSpacesCall(dataSourceId, _callback);
        }


        /**
         * Execute listGitbookSpaces request
         * @return Object
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public Object execute() throws ApiException {
            ApiResponse<Object> localVarResp = listGitbookSpacesWithHttpInfo(dataSourceId);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute listGitbookSpaces request with HTTP info returned
         * @return ApiResponse&lt;Object&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Object> executeWithHttpInfo() throws ApiException {
            return listGitbookSpacesWithHttpInfo(dataSourceId);
        }

        /**
         * Execute listGitbookSpaces request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Object> _callback) throws ApiException {
            return listGitbookSpacesAsync(dataSourceId, _callback);
        }
    }

    /**
     * Gitbook Spaces
     * After connecting your Gitbook account, you can use this endpoint to list all of your spaces under current organization.
     * @param dataSourceId  (required)
     * @return ListGitbookSpacesRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
     </table>
     */
    public ListGitbookSpacesRequestBuilder listGitbookSpaces(Integer dataSourceId) throws IllegalArgumentException {
        if (dataSourceId == null) throw new IllegalArgumentException("\"dataSourceId\" is required but got null");
        return new ListGitbookSpacesRequestBuilder(dataSourceId);
    }
    private okhttp3.Call listLabelsCall(Integer dataSourceId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/integrations/gmail/user_labels";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (dataSourceId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("data_source_id", dataSourceId));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "accessToken", "apiKey", "customerId" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call listLabelsValidateBeforeCall(Integer dataSourceId, final ApiCallback _callback) throws ApiException {
        return listLabelsCall(dataSourceId, _callback);

    }


    private ApiResponse<Object> listLabelsWithHttpInfo(Integer dataSourceId) throws ApiException {
        okhttp3.Call localVarCall = listLabelsValidateBeforeCall(dataSourceId, null);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call listLabelsAsync(Integer dataSourceId, final ApiCallback<Object> _callback) throws ApiException {

        okhttp3.Call localVarCall = listLabelsValidateBeforeCall(dataSourceId, _callback);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class ListLabelsRequestBuilder {
        private Integer dataSourceId;

        private ListLabelsRequestBuilder() {
        }

        /**
         * Set dataSourceId
         * @param dataSourceId  (optional)
         * @return ListLabelsRequestBuilder
         */
        public ListLabelsRequestBuilder dataSourceId(Integer dataSourceId) {
            this.dataSourceId = dataSourceId;
            return this;
        }
        
        /**
         * Build call for listLabels
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return listLabelsCall(dataSourceId, _callback);
        }


        /**
         * Execute listLabels request
         * @return Object
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public Object execute() throws ApiException {
            ApiResponse<Object> localVarResp = listLabelsWithHttpInfo(dataSourceId);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute listLabels request with HTTP info returned
         * @return ApiResponse&lt;Object&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Object> executeWithHttpInfo() throws ApiException {
            return listLabelsWithHttpInfo(dataSourceId);
        }

        /**
         * Execute listLabels request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Object> _callback) throws ApiException {
            return listLabelsAsync(dataSourceId, _callback);
        }
    }

    /**
     * Gmail Labels
     * After connecting your Gmail account, you can use this endpoint to list all of your labels. User created labels will have the type \&quot;user\&quot; and Gmail&#39;s default labels will have the type \&quot;system\&quot;
     * @return ListLabelsRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
     </table>
     */
    public ListLabelsRequestBuilder listLabels() throws IllegalArgumentException {
        return new ListLabelsRequestBuilder();
    }
    private okhttp3.Call listOutlookCategoriesCall(Integer dataSourceId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/integrations/outlook/user_categories";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (dataSourceId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("data_source_id", dataSourceId));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "accessToken", "apiKey", "customerId" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call listOutlookCategoriesValidateBeforeCall(Integer dataSourceId, final ApiCallback _callback) throws ApiException {
        return listOutlookCategoriesCall(dataSourceId, _callback);

    }


    private ApiResponse<Object> listOutlookCategoriesWithHttpInfo(Integer dataSourceId) throws ApiException {
        okhttp3.Call localVarCall = listOutlookCategoriesValidateBeforeCall(dataSourceId, null);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call listOutlookCategoriesAsync(Integer dataSourceId, final ApiCallback<Object> _callback) throws ApiException {

        okhttp3.Call localVarCall = listOutlookCategoriesValidateBeforeCall(dataSourceId, _callback);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class ListOutlookCategoriesRequestBuilder {
        private Integer dataSourceId;

        private ListOutlookCategoriesRequestBuilder() {
        }

        /**
         * Set dataSourceId
         * @param dataSourceId  (optional)
         * @return ListOutlookCategoriesRequestBuilder
         */
        public ListOutlookCategoriesRequestBuilder dataSourceId(Integer dataSourceId) {
            this.dataSourceId = dataSourceId;
            return this;
        }
        
        /**
         * Build call for listOutlookCategories
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return listOutlookCategoriesCall(dataSourceId, _callback);
        }


        /**
         * Execute listOutlookCategories request
         * @return Object
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public Object execute() throws ApiException {
            ApiResponse<Object> localVarResp = listOutlookCategoriesWithHttpInfo(dataSourceId);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute listOutlookCategories request with HTTP info returned
         * @return ApiResponse&lt;Object&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Object> executeWithHttpInfo() throws ApiException {
            return listOutlookCategoriesWithHttpInfo(dataSourceId);
        }

        /**
         * Execute listOutlookCategories request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Object> _callback) throws ApiException {
            return listOutlookCategoriesAsync(dataSourceId, _callback);
        }
    }

    /**
     * Outlook Categories
     * After connecting your Outlook account, you can use this endpoint to list all of your categories on outlook. We currently support listing up to 250 categories.
     * @return ListOutlookCategoriesRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
     </table>
     */
    public ListOutlookCategoriesRequestBuilder listOutlookCategories() throws IllegalArgumentException {
        return new ListOutlookCategoriesRequestBuilder();
    }
    private okhttp3.Call listReposCall(Integer perPage, Integer page, Integer dataSourceId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/integrations/github/repos";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (perPage != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("per_page", perPage));
        }

        if (page != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page", page));
        }

        if (dataSourceId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("data_source_id", dataSourceId));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "accessToken", "apiKey", "customerId" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call listReposValidateBeforeCall(Integer perPage, Integer page, Integer dataSourceId, final ApiCallback _callback) throws ApiException {
        return listReposCall(perPage, page, dataSourceId, _callback);

    }


    private ApiResponse<Object> listReposWithHttpInfo(Integer perPage, Integer page, Integer dataSourceId) throws ApiException {
        okhttp3.Call localVarCall = listReposValidateBeforeCall(perPage, page, dataSourceId, null);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call listReposAsync(Integer perPage, Integer page, Integer dataSourceId, final ApiCallback<Object> _callback) throws ApiException {

        okhttp3.Call localVarCall = listReposValidateBeforeCall(perPage, page, dataSourceId, _callback);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class ListReposRequestBuilder {
        private Integer perPage;
        private Integer page;
        private Integer dataSourceId;

        private ListReposRequestBuilder() {
        }

        /**
         * Set perPage
         * @param perPage  (optional, default to 30)
         * @return ListReposRequestBuilder
         */
        public ListReposRequestBuilder perPage(Integer perPage) {
            this.perPage = perPage;
            return this;
        }
        
        /**
         * Set page
         * @param page  (optional, default to 1)
         * @return ListReposRequestBuilder
         */
        public ListReposRequestBuilder page(Integer page) {
            this.page = page;
            return this;
        }
        
        /**
         * Set dataSourceId
         * @param dataSourceId  (optional)
         * @return ListReposRequestBuilder
         */
        public ListReposRequestBuilder dataSourceId(Integer dataSourceId) {
            this.dataSourceId = dataSourceId;
            return this;
        }
        
        /**
         * Build call for listRepos
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return listReposCall(perPage, page, dataSourceId, _callback);
        }


        /**
         * Execute listRepos request
         * @return Object
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public Object execute() throws ApiException {
            ApiResponse<Object> localVarResp = listReposWithHttpInfo(perPage, page, dataSourceId);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute listRepos request with HTTP info returned
         * @return ApiResponse&lt;Object&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Object> executeWithHttpInfo() throws ApiException {
            return listReposWithHttpInfo(perPage, page, dataSourceId);
        }

        /**
         * Execute listRepos request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Object> _callback) throws ApiException {
            return listReposAsync(perPage, page, dataSourceId, _callback);
        }
    }

    /**
     * Github List Repos
     * Once you have connected your GitHub account, you can use this endpoint to list the      repositories your account has access to. You can use a data source ID or username to fetch from a specific account.
     * @return ListReposRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
     </table>
     */
    public ListReposRequestBuilder listRepos() throws IllegalArgumentException {
        return new ListReposRequestBuilder();
    }
    private okhttp3.Call syncConfluenceCall(SyncFilesRequest syncFilesRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = syncFilesRequest;

        // create path and map variables
        String localVarPath = "/integrations/confluence/sync";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "accessToken", "apiKey", "customerId" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call syncConfluenceValidateBeforeCall(SyncFilesRequest syncFilesRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'syncFilesRequest' is set
        if (syncFilesRequest == null) {
            throw new ApiException("Missing the required parameter 'syncFilesRequest' when calling syncConfluence(Async)");
        }

        return syncConfluenceCall(syncFilesRequest, _callback);

    }


    private ApiResponse<GenericSuccessResponse> syncConfluenceWithHttpInfo(SyncFilesRequest syncFilesRequest) throws ApiException {
        okhttp3.Call localVarCall = syncConfluenceValidateBeforeCall(syncFilesRequest, null);
        Type localVarReturnType = new TypeToken<GenericSuccessResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call syncConfluenceAsync(SyncFilesRequest syncFilesRequest, final ApiCallback<GenericSuccessResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = syncConfluenceValidateBeforeCall(syncFilesRequest, _callback);
        Type localVarReturnType = new TypeToken<GenericSuccessResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class SyncConfluenceRequestBuilder {
        private final Integer dataSourceId;
        private final List<Object> ids;
        private Object tags;
        private Integer chunkSize;
        private Integer chunkOverlap;
        private Boolean skipEmbeddingGeneration;
        private EmbeddingGeneratorsNullable embeddingModel;
        private Boolean generateSparseVectors;
        private Boolean prependFilenameToChunks;
        private Integer maxItemsPerChunk;
        private Boolean setPageAsBoundary;
        private String requestId;
        private Boolean useOcr;
        private Boolean parsePdfTablesWithOcr;
        private Boolean incrementalSync;
        private FileSyncConfigNullable fileSyncConfig;

        private SyncConfluenceRequestBuilder(Integer dataSourceId, List<Object> ids) {
            this.dataSourceId = dataSourceId;
            this.ids = ids;
        }

        /**
         * Set tags
         * @param tags  (optional)
         * @return SyncConfluenceRequestBuilder
         */
        public SyncConfluenceRequestBuilder tags(Object tags) {
            this.tags = tags;
            return this;
        }
        
        /**
         * Set chunkSize
         * @param chunkSize  (optional, default to 1500)
         * @return SyncConfluenceRequestBuilder
         */
        public SyncConfluenceRequestBuilder chunkSize(Integer chunkSize) {
            this.chunkSize = chunkSize;
            return this;
        }
        
        /**
         * Set chunkOverlap
         * @param chunkOverlap  (optional, default to 20)
         * @return SyncConfluenceRequestBuilder
         */
        public SyncConfluenceRequestBuilder chunkOverlap(Integer chunkOverlap) {
            this.chunkOverlap = chunkOverlap;
            return this;
        }
        
        /**
         * Set skipEmbeddingGeneration
         * @param skipEmbeddingGeneration  (optional, default to false)
         * @return SyncConfluenceRequestBuilder
         */
        public SyncConfluenceRequestBuilder skipEmbeddingGeneration(Boolean skipEmbeddingGeneration) {
            this.skipEmbeddingGeneration = skipEmbeddingGeneration;
            return this;
        }
        
        /**
         * Set embeddingModel
         * @param embeddingModel  (optional, default to OPENAI)
         * @return SyncConfluenceRequestBuilder
         */
        public SyncConfluenceRequestBuilder embeddingModel(EmbeddingGeneratorsNullable embeddingModel) {
            this.embeddingModel = embeddingModel;
            return this;
        }
        
        /**
         * Set generateSparseVectors
         * @param generateSparseVectors  (optional, default to false)
         * @return SyncConfluenceRequestBuilder
         */
        public SyncConfluenceRequestBuilder generateSparseVectors(Boolean generateSparseVectors) {
            this.generateSparseVectors = generateSparseVectors;
            return this;
        }
        
        /**
         * Set prependFilenameToChunks
         * @param prependFilenameToChunks  (optional, default to false)
         * @return SyncConfluenceRequestBuilder
         */
        public SyncConfluenceRequestBuilder prependFilenameToChunks(Boolean prependFilenameToChunks) {
            this.prependFilenameToChunks = prependFilenameToChunks;
            return this;
        }
        
        /**
         * Set maxItemsPerChunk
         * @param maxItemsPerChunk Number of objects per chunk. For csv, tsv, xlsx, and json files only. (optional)
         * @return SyncConfluenceRequestBuilder
         */
        public SyncConfluenceRequestBuilder maxItemsPerChunk(Integer maxItemsPerChunk) {
            this.maxItemsPerChunk = maxItemsPerChunk;
            return this;
        }
        
        /**
         * Set setPageAsBoundary
         * @param setPageAsBoundary  (optional, default to false)
         * @return SyncConfluenceRequestBuilder
         */
        public SyncConfluenceRequestBuilder setPageAsBoundary(Boolean setPageAsBoundary) {
            this.setPageAsBoundary = setPageAsBoundary;
            return this;
        }
        
        /**
         * Set requestId
         * @param requestId  (optional, default to 9fe9190e-384f-4baa-a416-d51ed93d1be7)
         * @return SyncConfluenceRequestBuilder
         */
        public SyncConfluenceRequestBuilder requestId(String requestId) {
            this.requestId = requestId;
            return this;
        }
        
        /**
         * Set useOcr
         * @param useOcr  (optional, default to false)
         * @return SyncConfluenceRequestBuilder
         */
        public SyncConfluenceRequestBuilder useOcr(Boolean useOcr) {
            this.useOcr = useOcr;
            return this;
        }
        
        /**
         * Set parsePdfTablesWithOcr
         * @param parsePdfTablesWithOcr  (optional, default to false)
         * @return SyncConfluenceRequestBuilder
         */
        public SyncConfluenceRequestBuilder parsePdfTablesWithOcr(Boolean parsePdfTablesWithOcr) {
            this.parsePdfTablesWithOcr = parsePdfTablesWithOcr;
            return this;
        }
        
        /**
         * Set incrementalSync
         * @param incrementalSync Only sync files if they have not already been synced or if the embedding properties have changed.         This flag is currently supported by ONEDRIVE, GOOGLE_DRIVE, BOX, DROPBOX. It will be ignored for other data sources. (optional, default to false)
         * @return SyncConfluenceRequestBuilder
         */
        public SyncConfluenceRequestBuilder incrementalSync(Boolean incrementalSync) {
            this.incrementalSync = incrementalSync;
            return this;
        }
        
        /**
         * Set fileSyncConfig
         * @param fileSyncConfig  (optional)
         * @return SyncConfluenceRequestBuilder
         */
        public SyncConfluenceRequestBuilder fileSyncConfig(FileSyncConfigNullable fileSyncConfig) {
            this.fileSyncConfig = fileSyncConfig;
            return this;
        }
        
        /**
         * Build call for syncConfluence
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            SyncFilesRequest syncFilesRequest = buildBodyParams();
            return syncConfluenceCall(syncFilesRequest, _callback);
        }

        private SyncFilesRequest buildBodyParams() {
            SyncFilesRequest syncFilesRequest = new SyncFilesRequest();
            syncFilesRequest.tags(this.tags);
            syncFilesRequest.dataSourceId(this.dataSourceId);
            syncFilesRequest.ids(this.ids);
            syncFilesRequest.chunkSize(this.chunkSize);
            syncFilesRequest.chunkOverlap(this.chunkOverlap);
            syncFilesRequest.skipEmbeddingGeneration(this.skipEmbeddingGeneration);
            syncFilesRequest.embeddingModel(this.embeddingModel);
            syncFilesRequest.generateSparseVectors(this.generateSparseVectors);
            syncFilesRequest.prependFilenameToChunks(this.prependFilenameToChunks);
            syncFilesRequest.maxItemsPerChunk(this.maxItemsPerChunk);
            syncFilesRequest.setPageAsBoundary(this.setPageAsBoundary);
            syncFilesRequest.requestId(this.requestId);
            syncFilesRequest.useOcr(this.useOcr);
            syncFilesRequest.parsePdfTablesWithOcr(this.parsePdfTablesWithOcr);
            syncFilesRequest.incrementalSync(this.incrementalSync);
            syncFilesRequest.fileSyncConfig(this.fileSyncConfig);
            return syncFilesRequest;
        }

        /**
         * Execute syncConfluence request
         * @return GenericSuccessResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public GenericSuccessResponse execute() throws ApiException {
            SyncFilesRequest syncFilesRequest = buildBodyParams();
            ApiResponse<GenericSuccessResponse> localVarResp = syncConfluenceWithHttpInfo(syncFilesRequest);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute syncConfluence request with HTTP info returned
         * @return ApiResponse&lt;GenericSuccessResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<GenericSuccessResponse> executeWithHttpInfo() throws ApiException {
            SyncFilesRequest syncFilesRequest = buildBodyParams();
            return syncConfluenceWithHttpInfo(syncFilesRequest);
        }

        /**
         * Execute syncConfluence request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<GenericSuccessResponse> _callback) throws ApiException {
            SyncFilesRequest syncFilesRequest = buildBodyParams();
            return syncConfluenceAsync(syncFilesRequest, _callback);
        }
    }

    /**
     * Confluence Sync
     * After listing pages in a user&#39;s Confluence account, the set of selected page &#x60;ids&#x60; and the connected account&#39;s &#x60;data_source_id&#x60; can be passed into this endpoint to sync them into Carbon. Additional parameters listed below can be used to associate data to the selected pages or alter the behavior of the sync.
     * @param syncFilesRequest  (required)
     * @return SyncConfluenceRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
     </table>
     */
    public SyncConfluenceRequestBuilder syncConfluence(Integer dataSourceId, List<Object> ids) throws IllegalArgumentException {
        if (dataSourceId == null) throw new IllegalArgumentException("\"dataSourceId\" is required but got null");
        if (ids == null) throw new IllegalArgumentException("\"ids\" is required but got null");
        return new SyncConfluenceRequestBuilder(dataSourceId, ids);
    }
    private okhttp3.Call syncDataSourceItemsCall(SyncDirectoryRequest syncDirectoryRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = syncDirectoryRequest;

        // create path and map variables
        String localVarPath = "/integrations/items/sync";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "accessToken", "apiKey", "customerId" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call syncDataSourceItemsValidateBeforeCall(SyncDirectoryRequest syncDirectoryRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'syncDirectoryRequest' is set
        if (syncDirectoryRequest == null) {
            throw new ApiException("Missing the required parameter 'syncDirectoryRequest' when calling syncDataSourceItems(Async)");
        }

        return syncDataSourceItemsCall(syncDirectoryRequest, _callback);

    }


    private ApiResponse<OrganizationUserDataSourceAPI> syncDataSourceItemsWithHttpInfo(SyncDirectoryRequest syncDirectoryRequest) throws ApiException {
        okhttp3.Call localVarCall = syncDataSourceItemsValidateBeforeCall(syncDirectoryRequest, null);
        Type localVarReturnType = new TypeToken<OrganizationUserDataSourceAPI>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call syncDataSourceItemsAsync(SyncDirectoryRequest syncDirectoryRequest, final ApiCallback<OrganizationUserDataSourceAPI> _callback) throws ApiException {

        okhttp3.Call localVarCall = syncDataSourceItemsValidateBeforeCall(syncDirectoryRequest, _callback);
        Type localVarReturnType = new TypeToken<OrganizationUserDataSourceAPI>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class SyncDataSourceItemsRequestBuilder {
        private final Integer dataSourceId;

        private SyncDataSourceItemsRequestBuilder(Integer dataSourceId) {
            this.dataSourceId = dataSourceId;
        }

        /**
         * Build call for syncDataSourceItems
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            SyncDirectoryRequest syncDirectoryRequest = buildBodyParams();
            return syncDataSourceItemsCall(syncDirectoryRequest, _callback);
        }

        private SyncDirectoryRequest buildBodyParams() {
            SyncDirectoryRequest syncDirectoryRequest = new SyncDirectoryRequest();
            syncDirectoryRequest.dataSourceId(this.dataSourceId);
            return syncDirectoryRequest;
        }

        /**
         * Execute syncDataSourceItems request
         * @return OrganizationUserDataSourceAPI
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public OrganizationUserDataSourceAPI execute() throws ApiException {
            SyncDirectoryRequest syncDirectoryRequest = buildBodyParams();
            ApiResponse<OrganizationUserDataSourceAPI> localVarResp = syncDataSourceItemsWithHttpInfo(syncDirectoryRequest);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute syncDataSourceItems request with HTTP info returned
         * @return ApiResponse&lt;OrganizationUserDataSourceAPI&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<OrganizationUserDataSourceAPI> executeWithHttpInfo() throws ApiException {
            SyncDirectoryRequest syncDirectoryRequest = buildBodyParams();
            return syncDataSourceItemsWithHttpInfo(syncDirectoryRequest);
        }

        /**
         * Execute syncDataSourceItems request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<OrganizationUserDataSourceAPI> _callback) throws ApiException {
            SyncDirectoryRequest syncDirectoryRequest = buildBodyParams();
            return syncDataSourceItemsAsync(syncDirectoryRequest, _callback);
        }
    }

    /**
     * Sync Data Source Items
     * 
     * @param syncDirectoryRequest  (required)
     * @return SyncDataSourceItemsRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
     </table>
     */
    public SyncDataSourceItemsRequestBuilder syncDataSourceItems(Integer dataSourceId) throws IllegalArgumentException {
        if (dataSourceId == null) throw new IllegalArgumentException("\"dataSourceId\" is required but got null");
        return new SyncDataSourceItemsRequestBuilder(dataSourceId);
    }
    private okhttp3.Call syncFilesCall(SyncFilesRequest syncFilesRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = syncFilesRequest;

        // create path and map variables
        String localVarPath = "/integrations/files/sync";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "accessToken", "apiKey", "customerId" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call syncFilesValidateBeforeCall(SyncFilesRequest syncFilesRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'syncFilesRequest' is set
        if (syncFilesRequest == null) {
            throw new ApiException("Missing the required parameter 'syncFilesRequest' when calling syncFiles(Async)");
        }

        return syncFilesCall(syncFilesRequest, _callback);

    }


    private ApiResponse<GenericSuccessResponse> syncFilesWithHttpInfo(SyncFilesRequest syncFilesRequest) throws ApiException {
        okhttp3.Call localVarCall = syncFilesValidateBeforeCall(syncFilesRequest, null);
        Type localVarReturnType = new TypeToken<GenericSuccessResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call syncFilesAsync(SyncFilesRequest syncFilesRequest, final ApiCallback<GenericSuccessResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = syncFilesValidateBeforeCall(syncFilesRequest, _callback);
        Type localVarReturnType = new TypeToken<GenericSuccessResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class SyncFilesRequestBuilder {
        private final Integer dataSourceId;
        private final List<Object> ids;
        private Object tags;
        private Integer chunkSize;
        private Integer chunkOverlap;
        private Boolean skipEmbeddingGeneration;
        private EmbeddingGeneratorsNullable embeddingModel;
        private Boolean generateSparseVectors;
        private Boolean prependFilenameToChunks;
        private Integer maxItemsPerChunk;
        private Boolean setPageAsBoundary;
        private String requestId;
        private Boolean useOcr;
        private Boolean parsePdfTablesWithOcr;
        private Boolean incrementalSync;
        private FileSyncConfigNullable fileSyncConfig;

        private SyncFilesRequestBuilder(Integer dataSourceId, List<Object> ids) {
            this.dataSourceId = dataSourceId;
            this.ids = ids;
        }

        /**
         * Set tags
         * @param tags  (optional)
         * @return SyncFilesRequestBuilder
         */
        public SyncFilesRequestBuilder tags(Object tags) {
            this.tags = tags;
            return this;
        }
        
        /**
         * Set chunkSize
         * @param chunkSize  (optional, default to 1500)
         * @return SyncFilesRequestBuilder
         */
        public SyncFilesRequestBuilder chunkSize(Integer chunkSize) {
            this.chunkSize = chunkSize;
            return this;
        }
        
        /**
         * Set chunkOverlap
         * @param chunkOverlap  (optional, default to 20)
         * @return SyncFilesRequestBuilder
         */
        public SyncFilesRequestBuilder chunkOverlap(Integer chunkOverlap) {
            this.chunkOverlap = chunkOverlap;
            return this;
        }
        
        /**
         * Set skipEmbeddingGeneration
         * @param skipEmbeddingGeneration  (optional, default to false)
         * @return SyncFilesRequestBuilder
         */
        public SyncFilesRequestBuilder skipEmbeddingGeneration(Boolean skipEmbeddingGeneration) {
            this.skipEmbeddingGeneration = skipEmbeddingGeneration;
            return this;
        }
        
        /**
         * Set embeddingModel
         * @param embeddingModel  (optional, default to OPENAI)
         * @return SyncFilesRequestBuilder
         */
        public SyncFilesRequestBuilder embeddingModel(EmbeddingGeneratorsNullable embeddingModel) {
            this.embeddingModel = embeddingModel;
            return this;
        }
        
        /**
         * Set generateSparseVectors
         * @param generateSparseVectors  (optional, default to false)
         * @return SyncFilesRequestBuilder
         */
        public SyncFilesRequestBuilder generateSparseVectors(Boolean generateSparseVectors) {
            this.generateSparseVectors = generateSparseVectors;
            return this;
        }
        
        /**
         * Set prependFilenameToChunks
         * @param prependFilenameToChunks  (optional, default to false)
         * @return SyncFilesRequestBuilder
         */
        public SyncFilesRequestBuilder prependFilenameToChunks(Boolean prependFilenameToChunks) {
            this.prependFilenameToChunks = prependFilenameToChunks;
            return this;
        }
        
        /**
         * Set maxItemsPerChunk
         * @param maxItemsPerChunk Number of objects per chunk. For csv, tsv, xlsx, and json files only. (optional)
         * @return SyncFilesRequestBuilder
         */
        public SyncFilesRequestBuilder maxItemsPerChunk(Integer maxItemsPerChunk) {
            this.maxItemsPerChunk = maxItemsPerChunk;
            return this;
        }
        
        /**
         * Set setPageAsBoundary
         * @param setPageAsBoundary  (optional, default to false)
         * @return SyncFilesRequestBuilder
         */
        public SyncFilesRequestBuilder setPageAsBoundary(Boolean setPageAsBoundary) {
            this.setPageAsBoundary = setPageAsBoundary;
            return this;
        }
        
        /**
         * Set requestId
         * @param requestId  (optional, default to 9fe9190e-384f-4baa-a416-d51ed93d1be7)
         * @return SyncFilesRequestBuilder
         */
        public SyncFilesRequestBuilder requestId(String requestId) {
            this.requestId = requestId;
            return this;
        }
        
        /**
         * Set useOcr
         * @param useOcr  (optional, default to false)
         * @return SyncFilesRequestBuilder
         */
        public SyncFilesRequestBuilder useOcr(Boolean useOcr) {
            this.useOcr = useOcr;
            return this;
        }
        
        /**
         * Set parsePdfTablesWithOcr
         * @param parsePdfTablesWithOcr  (optional, default to false)
         * @return SyncFilesRequestBuilder
         */
        public SyncFilesRequestBuilder parsePdfTablesWithOcr(Boolean parsePdfTablesWithOcr) {
            this.parsePdfTablesWithOcr = parsePdfTablesWithOcr;
            return this;
        }
        
        /**
         * Set incrementalSync
         * @param incrementalSync Only sync files if they have not already been synced or if the embedding properties have changed.         This flag is currently supported by ONEDRIVE, GOOGLE_DRIVE, BOX, DROPBOX. It will be ignored for other data sources. (optional, default to false)
         * @return SyncFilesRequestBuilder
         */
        public SyncFilesRequestBuilder incrementalSync(Boolean incrementalSync) {
            this.incrementalSync = incrementalSync;
            return this;
        }
        
        /**
         * Set fileSyncConfig
         * @param fileSyncConfig  (optional)
         * @return SyncFilesRequestBuilder
         */
        public SyncFilesRequestBuilder fileSyncConfig(FileSyncConfigNullable fileSyncConfig) {
            this.fileSyncConfig = fileSyncConfig;
            return this;
        }
        
        /**
         * Build call for syncFiles
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            SyncFilesRequest syncFilesRequest = buildBodyParams();
            return syncFilesCall(syncFilesRequest, _callback);
        }

        private SyncFilesRequest buildBodyParams() {
            SyncFilesRequest syncFilesRequest = new SyncFilesRequest();
            syncFilesRequest.tags(this.tags);
            syncFilesRequest.dataSourceId(this.dataSourceId);
            syncFilesRequest.ids(this.ids);
            syncFilesRequest.chunkSize(this.chunkSize);
            syncFilesRequest.chunkOverlap(this.chunkOverlap);
            syncFilesRequest.skipEmbeddingGeneration(this.skipEmbeddingGeneration);
            syncFilesRequest.embeddingModel(this.embeddingModel);
            syncFilesRequest.generateSparseVectors(this.generateSparseVectors);
            syncFilesRequest.prependFilenameToChunks(this.prependFilenameToChunks);
            syncFilesRequest.maxItemsPerChunk(this.maxItemsPerChunk);
            syncFilesRequest.setPageAsBoundary(this.setPageAsBoundary);
            syncFilesRequest.requestId(this.requestId);
            syncFilesRequest.useOcr(this.useOcr);
            syncFilesRequest.parsePdfTablesWithOcr(this.parsePdfTablesWithOcr);
            syncFilesRequest.incrementalSync(this.incrementalSync);
            syncFilesRequest.fileSyncConfig(this.fileSyncConfig);
            return syncFilesRequest;
        }

        /**
         * Execute syncFiles request
         * @return GenericSuccessResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public GenericSuccessResponse execute() throws ApiException {
            SyncFilesRequest syncFilesRequest = buildBodyParams();
            ApiResponse<GenericSuccessResponse> localVarResp = syncFilesWithHttpInfo(syncFilesRequest);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute syncFiles request with HTTP info returned
         * @return ApiResponse&lt;GenericSuccessResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<GenericSuccessResponse> executeWithHttpInfo() throws ApiException {
            SyncFilesRequest syncFilesRequest = buildBodyParams();
            return syncFilesWithHttpInfo(syncFilesRequest);
        }

        /**
         * Execute syncFiles request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<GenericSuccessResponse> _callback) throws ApiException {
            SyncFilesRequest syncFilesRequest = buildBodyParams();
            return syncFilesAsync(syncFilesRequest, _callback);
        }
    }

    /**
     * Sync Files
     * After listing files and folders via /integrations/items/sync and integrations/items/list, use the selected items&#39; external ids  as the ids in this endpoint to sync them into Carbon. Sharepoint items take an additional parameter root_id, which identifies the drive the file or folder is in and is stored in root_external_id. That additional paramter is optional and excluding it will tell the sync to assume the item is stored in the default Documents drive.
     * @param syncFilesRequest  (required)
     * @return SyncFilesRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
     </table>
     */
    public SyncFilesRequestBuilder syncFiles(Integer dataSourceId, List<Object> ids) throws IllegalArgumentException {
        if (dataSourceId == null) throw new IllegalArgumentException("\"dataSourceId\" is required but got null");
        if (ids == null) throw new IllegalArgumentException("\"ids\" is required but got null");
        return new SyncFilesRequestBuilder(dataSourceId, ids);
    }
    private okhttp3.Call syncGitHubCall(GithubConnectRequest githubConnectRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = githubConnectRequest;

        // create path and map variables
        String localVarPath = "/integrations/github";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "accessToken", "apiKey", "customerId" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call syncGitHubValidateBeforeCall(GithubConnectRequest githubConnectRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'githubConnectRequest' is set
        if (githubConnectRequest == null) {
            throw new ApiException("Missing the required parameter 'githubConnectRequest' when calling syncGitHub(Async)");
        }

        return syncGitHubCall(githubConnectRequest, _callback);

    }


    private ApiResponse<GenericSuccessResponse> syncGitHubWithHttpInfo(GithubConnectRequest githubConnectRequest) throws ApiException {
        okhttp3.Call localVarCall = syncGitHubValidateBeforeCall(githubConnectRequest, null);
        Type localVarReturnType = new TypeToken<GenericSuccessResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call syncGitHubAsync(GithubConnectRequest githubConnectRequest, final ApiCallback<GenericSuccessResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = syncGitHubValidateBeforeCall(githubConnectRequest, _callback);
        Type localVarReturnType = new TypeToken<GenericSuccessResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class SyncGitHubRequestBuilder {
        private final String username;
        private final String accessToken;
        private Boolean syncSourceItems;

        private SyncGitHubRequestBuilder(String username, String accessToken) {
            this.username = username;
            this.accessToken = accessToken;
        }

        /**
         * Set syncSourceItems
         * @param syncSourceItems Enabling this flag will fetch all available content from the source to be listed via list items endpoint (optional, default to false)
         * @return SyncGitHubRequestBuilder
         */
        public SyncGitHubRequestBuilder syncSourceItems(Boolean syncSourceItems) {
            this.syncSourceItems = syncSourceItems;
            return this;
        }
        
        /**
         * Build call for syncGitHub
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            GithubConnectRequest githubConnectRequest = buildBodyParams();
            return syncGitHubCall(githubConnectRequest, _callback);
        }

        private GithubConnectRequest buildBodyParams() {
            GithubConnectRequest githubConnectRequest = new GithubConnectRequest();
            githubConnectRequest.username(this.username);
            githubConnectRequest.accessToken(this.accessToken);
            githubConnectRequest.syncSourceItems(this.syncSourceItems);
            return githubConnectRequest;
        }

        /**
         * Execute syncGitHub request
         * @return GenericSuccessResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public GenericSuccessResponse execute() throws ApiException {
            GithubConnectRequest githubConnectRequest = buildBodyParams();
            ApiResponse<GenericSuccessResponse> localVarResp = syncGitHubWithHttpInfo(githubConnectRequest);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute syncGitHub request with HTTP info returned
         * @return ApiResponse&lt;GenericSuccessResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<GenericSuccessResponse> executeWithHttpInfo() throws ApiException {
            GithubConnectRequest githubConnectRequest = buildBodyParams();
            return syncGitHubWithHttpInfo(githubConnectRequest);
        }

        /**
         * Execute syncGitHub request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<GenericSuccessResponse> _callback) throws ApiException {
            GithubConnectRequest githubConnectRequest = buildBodyParams();
            return syncGitHubAsync(githubConnectRequest, _callback);
        }
    }

    /**
     * Github Connect
     * Refer this article to obtain an access token https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/managing-your-personal-access-tokens. Make sure that your access token has the permission to read content from your desired repos. Note that if your access token expires you will need to manually update it through this endpoint.
     * @param githubConnectRequest  (required)
     * @return SyncGitHubRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
     </table>
     */
    public SyncGitHubRequestBuilder syncGitHub(String username, String accessToken) throws IllegalArgumentException {
        if (username == null) throw new IllegalArgumentException("\"username\" is required but got null");
            

        if (accessToken == null) throw new IllegalArgumentException("\"accessToken\" is required but got null");
            

        return new SyncGitHubRequestBuilder(username, accessToken);
    }
    private okhttp3.Call syncGitbookCall(GitbookSyncRequest gitbookSyncRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = gitbookSyncRequest;

        // create path and map variables
        String localVarPath = "/integrations/gitbook/sync";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "accessToken", "apiKey", "customerId" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call syncGitbookValidateBeforeCall(GitbookSyncRequest gitbookSyncRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'gitbookSyncRequest' is set
        if (gitbookSyncRequest == null) {
            throw new ApiException("Missing the required parameter 'gitbookSyncRequest' when calling syncGitbook(Async)");
        }

        return syncGitbookCall(gitbookSyncRequest, _callback);

    }


    private ApiResponse<Object> syncGitbookWithHttpInfo(GitbookSyncRequest gitbookSyncRequest) throws ApiException {
        okhttp3.Call localVarCall = syncGitbookValidateBeforeCall(gitbookSyncRequest, null);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call syncGitbookAsync(GitbookSyncRequest gitbookSyncRequest, final ApiCallback<Object> _callback) throws ApiException {

        okhttp3.Call localVarCall = syncGitbookValidateBeforeCall(gitbookSyncRequest, _callback);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class SyncGitbookRequestBuilder {
        private final List<String> spaceIds;
        private final Integer dataSourceId;
        private Object tags;
        private Integer chunkSize;
        private Integer chunkOverlap;
        private Boolean skipEmbeddingGeneration;
        private EmbeddingGenerators embeddingModel;
        private Boolean generateSparseVectors;
        private Boolean prependFilenameToChunks;
        private String requestId;

        private SyncGitbookRequestBuilder(List<String> spaceIds, Integer dataSourceId) {
            this.spaceIds = spaceIds;
            this.dataSourceId = dataSourceId;
        }

        /**
         * Set tags
         * @param tags  (optional)
         * @return SyncGitbookRequestBuilder
         */
        public SyncGitbookRequestBuilder tags(Object tags) {
            this.tags = tags;
            return this;
        }
        
        /**
         * Set chunkSize
         * @param chunkSize  (optional, default to 1500)
         * @return SyncGitbookRequestBuilder
         */
        public SyncGitbookRequestBuilder chunkSize(Integer chunkSize) {
            this.chunkSize = chunkSize;
            return this;
        }
        
        /**
         * Set chunkOverlap
         * @param chunkOverlap  (optional, default to 20)
         * @return SyncGitbookRequestBuilder
         */
        public SyncGitbookRequestBuilder chunkOverlap(Integer chunkOverlap) {
            this.chunkOverlap = chunkOverlap;
            return this;
        }
        
        /**
         * Set skipEmbeddingGeneration
         * @param skipEmbeddingGeneration  (optional, default to false)
         * @return SyncGitbookRequestBuilder
         */
        public SyncGitbookRequestBuilder skipEmbeddingGeneration(Boolean skipEmbeddingGeneration) {
            this.skipEmbeddingGeneration = skipEmbeddingGeneration;
            return this;
        }
        
        /**
         * Set embeddingModel
         * @param embeddingModel  (optional)
         * @return SyncGitbookRequestBuilder
         */
        public SyncGitbookRequestBuilder embeddingModel(EmbeddingGenerators embeddingModel) {
            this.embeddingModel = embeddingModel;
            return this;
        }
        
        /**
         * Set generateSparseVectors
         * @param generateSparseVectors  (optional, default to false)
         * @return SyncGitbookRequestBuilder
         */
        public SyncGitbookRequestBuilder generateSparseVectors(Boolean generateSparseVectors) {
            this.generateSparseVectors = generateSparseVectors;
            return this;
        }
        
        /**
         * Set prependFilenameToChunks
         * @param prependFilenameToChunks  (optional, default to false)
         * @return SyncGitbookRequestBuilder
         */
        public SyncGitbookRequestBuilder prependFilenameToChunks(Boolean prependFilenameToChunks) {
            this.prependFilenameToChunks = prependFilenameToChunks;
            return this;
        }
        
        /**
         * Set requestId
         * @param requestId  (optional)
         * @return SyncGitbookRequestBuilder
         */
        public SyncGitbookRequestBuilder requestId(String requestId) {
            this.requestId = requestId;
            return this;
        }
        
        /**
         * Build call for syncGitbook
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            GitbookSyncRequest gitbookSyncRequest = buildBodyParams();
            return syncGitbookCall(gitbookSyncRequest, _callback);
        }

        private GitbookSyncRequest buildBodyParams() {
            GitbookSyncRequest gitbookSyncRequest = new GitbookSyncRequest();
            gitbookSyncRequest.tags(this.tags);
            gitbookSyncRequest.spaceIds(this.spaceIds);
            gitbookSyncRequest.dataSourceId(this.dataSourceId);
            gitbookSyncRequest.chunkSize(this.chunkSize);
            gitbookSyncRequest.chunkOverlap(this.chunkOverlap);
            gitbookSyncRequest.skipEmbeddingGeneration(this.skipEmbeddingGeneration);
            gitbookSyncRequest.embeddingModel(this.embeddingModel);
            gitbookSyncRequest.generateSparseVectors(this.generateSparseVectors);
            gitbookSyncRequest.prependFilenameToChunks(this.prependFilenameToChunks);
            gitbookSyncRequest.requestId(this.requestId);
            return gitbookSyncRequest;
        }

        /**
         * Execute syncGitbook request
         * @return Object
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public Object execute() throws ApiException {
            GitbookSyncRequest gitbookSyncRequest = buildBodyParams();
            ApiResponse<Object> localVarResp = syncGitbookWithHttpInfo(gitbookSyncRequest);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute syncGitbook request with HTTP info returned
         * @return ApiResponse&lt;Object&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Object> executeWithHttpInfo() throws ApiException {
            GitbookSyncRequest gitbookSyncRequest = buildBodyParams();
            return syncGitbookWithHttpInfo(gitbookSyncRequest);
        }

        /**
         * Execute syncGitbook request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Object> _callback) throws ApiException {
            GitbookSyncRequest gitbookSyncRequest = buildBodyParams();
            return syncGitbookAsync(gitbookSyncRequest, _callback);
        }
    }

    /**
     * Gitbook Sync
     * You can sync upto 20 Gitbook spaces at a time using this endpoint. Additional parameters below can be used to associate  data with the synced pages or modify the sync behavior.
     * @param gitbookSyncRequest  (required)
     * @return SyncGitbookRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
     </table>
     */
    public SyncGitbookRequestBuilder syncGitbook(List<String> spaceIds, Integer dataSourceId) throws IllegalArgumentException {
        if (spaceIds == null) throw new IllegalArgumentException("\"spaceIds\" is required but got null");
        if (dataSourceId == null) throw new IllegalArgumentException("\"dataSourceId\" is required but got null");
        return new SyncGitbookRequestBuilder(spaceIds, dataSourceId);
    }
    private okhttp3.Call syncGmailCall(GmailSyncInput gmailSyncInput, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = gmailSyncInput;

        // create path and map variables
        String localVarPath = "/integrations/gmail/sync";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "accessToken", "apiKey", "customerId" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call syncGmailValidateBeforeCall(GmailSyncInput gmailSyncInput, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'gmailSyncInput' is set
        if (gmailSyncInput == null) {
            throw new ApiException("Missing the required parameter 'gmailSyncInput' when calling syncGmail(Async)");
        }

        return syncGmailCall(gmailSyncInput, _callback);

    }


    private ApiResponse<GenericSuccessResponse> syncGmailWithHttpInfo(GmailSyncInput gmailSyncInput) throws ApiException {
        okhttp3.Call localVarCall = syncGmailValidateBeforeCall(gmailSyncInput, null);
        Type localVarReturnType = new TypeToken<GenericSuccessResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call syncGmailAsync(GmailSyncInput gmailSyncInput, final ApiCallback<GenericSuccessResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = syncGmailValidateBeforeCall(gmailSyncInput, _callback);
        Type localVarReturnType = new TypeToken<GenericSuccessResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class SyncGmailRequestBuilder {
        private final Object filters;
        private Object tags;
        private Integer chunkSize;
        private Integer chunkOverlap;
        private Boolean skipEmbeddingGeneration;
        private EmbeddingGenerators embeddingModel;
        private Boolean generateSparseVectors;
        private Boolean prependFilenameToChunks;
        private Integer dataSourceId;
        private String requestId;
        private Boolean syncAttachments;
        private FileSyncConfigNullable fileSyncConfig;
        private Boolean incrementalSync;

        private SyncGmailRequestBuilder(Object filters) {
            this.filters = filters;
        }

        /**
         * Set tags
         * @param tags  (optional)
         * @return SyncGmailRequestBuilder
         */
        public SyncGmailRequestBuilder tags(Object tags) {
            this.tags = tags;
            return this;
        }
        
        /**
         * Set chunkSize
         * @param chunkSize  (optional, default to 1500)
         * @return SyncGmailRequestBuilder
         */
        public SyncGmailRequestBuilder chunkSize(Integer chunkSize) {
            this.chunkSize = chunkSize;
            return this;
        }
        
        /**
         * Set chunkOverlap
         * @param chunkOverlap  (optional, default to 20)
         * @return SyncGmailRequestBuilder
         */
        public SyncGmailRequestBuilder chunkOverlap(Integer chunkOverlap) {
            this.chunkOverlap = chunkOverlap;
            return this;
        }
        
        /**
         * Set skipEmbeddingGeneration
         * @param skipEmbeddingGeneration  (optional, default to false)
         * @return SyncGmailRequestBuilder
         */
        public SyncGmailRequestBuilder skipEmbeddingGeneration(Boolean skipEmbeddingGeneration) {
            this.skipEmbeddingGeneration = skipEmbeddingGeneration;
            return this;
        }
        
        /**
         * Set embeddingModel
         * @param embeddingModel  (optional)
         * @return SyncGmailRequestBuilder
         */
        public SyncGmailRequestBuilder embeddingModel(EmbeddingGenerators embeddingModel) {
            this.embeddingModel = embeddingModel;
            return this;
        }
        
        /**
         * Set generateSparseVectors
         * @param generateSparseVectors  (optional, default to false)
         * @return SyncGmailRequestBuilder
         */
        public SyncGmailRequestBuilder generateSparseVectors(Boolean generateSparseVectors) {
            this.generateSparseVectors = generateSparseVectors;
            return this;
        }
        
        /**
         * Set prependFilenameToChunks
         * @param prependFilenameToChunks  (optional, default to false)
         * @return SyncGmailRequestBuilder
         */
        public SyncGmailRequestBuilder prependFilenameToChunks(Boolean prependFilenameToChunks) {
            this.prependFilenameToChunks = prependFilenameToChunks;
            return this;
        }
        
        /**
         * Set dataSourceId
         * @param dataSourceId  (optional)
         * @return SyncGmailRequestBuilder
         */
        public SyncGmailRequestBuilder dataSourceId(Integer dataSourceId) {
            this.dataSourceId = dataSourceId;
            return this;
        }
        
        /**
         * Set requestId
         * @param requestId  (optional)
         * @return SyncGmailRequestBuilder
         */
        public SyncGmailRequestBuilder requestId(String requestId) {
            this.requestId = requestId;
            return this;
        }
        
        /**
         * Set syncAttachments
         * @param syncAttachments  (optional, default to false)
         * @return SyncGmailRequestBuilder
         */
        public SyncGmailRequestBuilder syncAttachments(Boolean syncAttachments) {
            this.syncAttachments = syncAttachments;
            return this;
        }
        
        /**
         * Set fileSyncConfig
         * @param fileSyncConfig  (optional)
         * @return SyncGmailRequestBuilder
         */
        public SyncGmailRequestBuilder fileSyncConfig(FileSyncConfigNullable fileSyncConfig) {
            this.fileSyncConfig = fileSyncConfig;
            return this;
        }
        
        /**
         * Set incrementalSync
         * @param incrementalSync  (optional, default to false)
         * @return SyncGmailRequestBuilder
         */
        public SyncGmailRequestBuilder incrementalSync(Boolean incrementalSync) {
            this.incrementalSync = incrementalSync;
            return this;
        }
        
        /**
         * Build call for syncGmail
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            GmailSyncInput gmailSyncInput = buildBodyParams();
            return syncGmailCall(gmailSyncInput, _callback);
        }

        private GmailSyncInput buildBodyParams() {
            GmailSyncInput gmailSyncInput = new GmailSyncInput();
            gmailSyncInput.tags(this.tags);
            gmailSyncInput.filters(this.filters);
            gmailSyncInput.chunkSize(this.chunkSize);
            gmailSyncInput.chunkOverlap(this.chunkOverlap);
            gmailSyncInput.skipEmbeddingGeneration(this.skipEmbeddingGeneration);
            gmailSyncInput.embeddingModel(this.embeddingModel);
            gmailSyncInput.generateSparseVectors(this.generateSparseVectors);
            gmailSyncInput.prependFilenameToChunks(this.prependFilenameToChunks);
            gmailSyncInput.dataSourceId(this.dataSourceId);
            gmailSyncInput.requestId(this.requestId);
            gmailSyncInput.syncAttachments(this.syncAttachments);
            gmailSyncInput.fileSyncConfig(this.fileSyncConfig);
            gmailSyncInput.incrementalSync(this.incrementalSync);
            return gmailSyncInput;
        }

        /**
         * Execute syncGmail request
         * @return GenericSuccessResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public GenericSuccessResponse execute() throws ApiException {
            GmailSyncInput gmailSyncInput = buildBodyParams();
            ApiResponse<GenericSuccessResponse> localVarResp = syncGmailWithHttpInfo(gmailSyncInput);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute syncGmail request with HTTP info returned
         * @return ApiResponse&lt;GenericSuccessResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<GenericSuccessResponse> executeWithHttpInfo() throws ApiException {
            GmailSyncInput gmailSyncInput = buildBodyParams();
            return syncGmailWithHttpInfo(gmailSyncInput);
        }

        /**
         * Execute syncGmail request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<GenericSuccessResponse> _callback) throws ApiException {
            GmailSyncInput gmailSyncInput = buildBodyParams();
            return syncGmailAsync(gmailSyncInput, _callback);
        }
    }

    /**
     * Gmail Sync
     * Once you have successfully connected your gmail account, you can choose which emails to sync with us using the filters parameter. Filters is a JSON object with key value pairs. It also supports AND and OR operations. For now, we support a limited set of keys listed below.  &lt;b&gt;label&lt;/b&gt;: Inbuilt Gmail labels, for example \&quot;Important\&quot; or a custom label you created.   &lt;b&gt;after&lt;/b&gt; or &lt;b&gt;before&lt;/b&gt;: A date in YYYY/mm/dd format (example 2023/12/31). Gets emails after/before a certain date. You can also use them in combination to get emails from a certain period.   &lt;b&gt;is&lt;/b&gt;: Can have the following values - starred, important, snoozed, and unread    Using keys or values outside of the specified values can lead to unexpected behaviour.  An example of a basic query with filters can be &#x60;&#x60;&#x60;json {     \&quot;filters\&quot;: {             \&quot;key\&quot;: \&quot;label\&quot;,             \&quot;value\&quot;: \&quot;Test\&quot;         } } &#x60;&#x60;&#x60; Which will list all emails that have the label \&quot;Test\&quot;.  You can use AND and OR operation in the following way: &#x60;&#x60;&#x60;json {     \&quot;filters\&quot;: {         \&quot;AND\&quot;: [             {                 \&quot;key\&quot;: \&quot;after\&quot;,                 \&quot;value\&quot;: \&quot;2024/01/07\&quot;             },             {                 \&quot;OR\&quot;: [                     {                         \&quot;key\&quot;: \&quot;label\&quot;,                         \&quot;value\&quot;: \&quot;Personal\&quot;                     },                     {                         \&quot;key\&quot;: \&quot;is\&quot;,                         \&quot;value\&quot;: \&quot;starred\&quot;                     }                 ]             }         ]     } } &#x60;&#x60;&#x60; This will return emails after 7th of Jan that are either starred or have the label \&quot;Personal\&quot;.  Note that this is the highest level of nesting we support, i.e. you can&#39;t add more AND/OR filters within the OR filter in the above example.
     * @param gmailSyncInput  (required)
     * @return SyncGmailRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
     </table>
     */
    public SyncGmailRequestBuilder syncGmail(Object filters) throws IllegalArgumentException {
        if (filters == null) throw new IllegalArgumentException("\"filters\" is required but got null");
        return new SyncGmailRequestBuilder(filters);
    }
    private okhttp3.Call syncOutlookCall(OutlookSyncInput outlookSyncInput, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = outlookSyncInput;

        // create path and map variables
        String localVarPath = "/integrations/outlook/sync";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "accessToken", "apiKey", "customerId" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call syncOutlookValidateBeforeCall(OutlookSyncInput outlookSyncInput, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'outlookSyncInput' is set
        if (outlookSyncInput == null) {
            throw new ApiException("Missing the required parameter 'outlookSyncInput' when calling syncOutlook(Async)");
        }

        return syncOutlookCall(outlookSyncInput, _callback);

    }


    private ApiResponse<GenericSuccessResponse> syncOutlookWithHttpInfo(OutlookSyncInput outlookSyncInput) throws ApiException {
        okhttp3.Call localVarCall = syncOutlookValidateBeforeCall(outlookSyncInput, null);
        Type localVarReturnType = new TypeToken<GenericSuccessResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call syncOutlookAsync(OutlookSyncInput outlookSyncInput, final ApiCallback<GenericSuccessResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = syncOutlookValidateBeforeCall(outlookSyncInput, _callback);
        Type localVarReturnType = new TypeToken<GenericSuccessResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class SyncOutlookRequestBuilder {
        private final Object filters;
        private Object tags;
        private String folder;
        private Integer chunkSize;
        private Integer chunkOverlap;
        private Boolean skipEmbeddingGeneration;
        private EmbeddingGenerators embeddingModel;
        private Boolean generateSparseVectors;
        private Boolean prependFilenameToChunks;
        private Integer dataSourceId;
        private String requestId;
        private Boolean syncAttachments;
        private FileSyncConfigNullable fileSyncConfig;
        private Boolean incrementalSync;

        private SyncOutlookRequestBuilder(Object filters) {
            this.filters = filters;
        }

        /**
         * Set tags
         * @param tags  (optional)
         * @return SyncOutlookRequestBuilder
         */
        public SyncOutlookRequestBuilder tags(Object tags) {
            this.tags = tags;
            return this;
        }
        
        /**
         * Set folder
         * @param folder  (optional, default to Inbox)
         * @return SyncOutlookRequestBuilder
         */
        public SyncOutlookRequestBuilder folder(String folder) {
            this.folder = folder;
            return this;
        }
        
        /**
         * Set chunkSize
         * @param chunkSize  (optional, default to 1500)
         * @return SyncOutlookRequestBuilder
         */
        public SyncOutlookRequestBuilder chunkSize(Integer chunkSize) {
            this.chunkSize = chunkSize;
            return this;
        }
        
        /**
         * Set chunkOverlap
         * @param chunkOverlap  (optional, default to 20)
         * @return SyncOutlookRequestBuilder
         */
        public SyncOutlookRequestBuilder chunkOverlap(Integer chunkOverlap) {
            this.chunkOverlap = chunkOverlap;
            return this;
        }
        
        /**
         * Set skipEmbeddingGeneration
         * @param skipEmbeddingGeneration  (optional, default to false)
         * @return SyncOutlookRequestBuilder
         */
        public SyncOutlookRequestBuilder skipEmbeddingGeneration(Boolean skipEmbeddingGeneration) {
            this.skipEmbeddingGeneration = skipEmbeddingGeneration;
            return this;
        }
        
        /**
         * Set embeddingModel
         * @param embeddingModel  (optional)
         * @return SyncOutlookRequestBuilder
         */
        public SyncOutlookRequestBuilder embeddingModel(EmbeddingGenerators embeddingModel) {
            this.embeddingModel = embeddingModel;
            return this;
        }
        
        /**
         * Set generateSparseVectors
         * @param generateSparseVectors  (optional, default to false)
         * @return SyncOutlookRequestBuilder
         */
        public SyncOutlookRequestBuilder generateSparseVectors(Boolean generateSparseVectors) {
            this.generateSparseVectors = generateSparseVectors;
            return this;
        }
        
        /**
         * Set prependFilenameToChunks
         * @param prependFilenameToChunks  (optional, default to false)
         * @return SyncOutlookRequestBuilder
         */
        public SyncOutlookRequestBuilder prependFilenameToChunks(Boolean prependFilenameToChunks) {
            this.prependFilenameToChunks = prependFilenameToChunks;
            return this;
        }
        
        /**
         * Set dataSourceId
         * @param dataSourceId  (optional)
         * @return SyncOutlookRequestBuilder
         */
        public SyncOutlookRequestBuilder dataSourceId(Integer dataSourceId) {
            this.dataSourceId = dataSourceId;
            return this;
        }
        
        /**
         * Set requestId
         * @param requestId  (optional)
         * @return SyncOutlookRequestBuilder
         */
        public SyncOutlookRequestBuilder requestId(String requestId) {
            this.requestId = requestId;
            return this;
        }
        
        /**
         * Set syncAttachments
         * @param syncAttachments  (optional, default to false)
         * @return SyncOutlookRequestBuilder
         */
        public SyncOutlookRequestBuilder syncAttachments(Boolean syncAttachments) {
            this.syncAttachments = syncAttachments;
            return this;
        }
        
        /**
         * Set fileSyncConfig
         * @param fileSyncConfig  (optional)
         * @return SyncOutlookRequestBuilder
         */
        public SyncOutlookRequestBuilder fileSyncConfig(FileSyncConfigNullable fileSyncConfig) {
            this.fileSyncConfig = fileSyncConfig;
            return this;
        }
        
        /**
         * Set incrementalSync
         * @param incrementalSync  (optional, default to false)
         * @return SyncOutlookRequestBuilder
         */
        public SyncOutlookRequestBuilder incrementalSync(Boolean incrementalSync) {
            this.incrementalSync = incrementalSync;
            return this;
        }
        
        /**
         * Build call for syncOutlook
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            OutlookSyncInput outlookSyncInput = buildBodyParams();
            return syncOutlookCall(outlookSyncInput, _callback);
        }

        private OutlookSyncInput buildBodyParams() {
            OutlookSyncInput outlookSyncInput = new OutlookSyncInput();
            outlookSyncInput.tags(this.tags);
            outlookSyncInput.folder(this.folder);
            outlookSyncInput.filters(this.filters);
            outlookSyncInput.chunkSize(this.chunkSize);
            outlookSyncInput.chunkOverlap(this.chunkOverlap);
            outlookSyncInput.skipEmbeddingGeneration(this.skipEmbeddingGeneration);
            outlookSyncInput.embeddingModel(this.embeddingModel);
            outlookSyncInput.generateSparseVectors(this.generateSparseVectors);
            outlookSyncInput.prependFilenameToChunks(this.prependFilenameToChunks);
            outlookSyncInput.dataSourceId(this.dataSourceId);
            outlookSyncInput.requestId(this.requestId);
            outlookSyncInput.syncAttachments(this.syncAttachments);
            outlookSyncInput.fileSyncConfig(this.fileSyncConfig);
            outlookSyncInput.incrementalSync(this.incrementalSync);
            return outlookSyncInput;
        }

        /**
         * Execute syncOutlook request
         * @return GenericSuccessResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public GenericSuccessResponse execute() throws ApiException {
            OutlookSyncInput outlookSyncInput = buildBodyParams();
            ApiResponse<GenericSuccessResponse> localVarResp = syncOutlookWithHttpInfo(outlookSyncInput);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute syncOutlook request with HTTP info returned
         * @return ApiResponse&lt;GenericSuccessResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<GenericSuccessResponse> executeWithHttpInfo() throws ApiException {
            OutlookSyncInput outlookSyncInput = buildBodyParams();
            return syncOutlookWithHttpInfo(outlookSyncInput);
        }

        /**
         * Execute syncOutlook request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<GenericSuccessResponse> _callback) throws ApiException {
            OutlookSyncInput outlookSyncInput = buildBodyParams();
            return syncOutlookAsync(outlookSyncInput, _callback);
        }
    }

    /**
     * Outlook Sync
     * Once you have successfully connected your Outlook account, you can choose which emails to sync with us using the filters and folder parameter. \&quot;folder\&quot; should be the folder you want to sync from Outlook. By default we get messages from your inbox folder.   Filters is a JSON object with key value pairs. It also supports AND and OR operations. For now, we support a limited set of keys listed below.  &lt;b&gt;category&lt;/b&gt;: Custom categories that you created in Outlook.   &lt;b&gt;after&lt;/b&gt; or &lt;b&gt;before&lt;/b&gt;: A date in YYYY/mm/dd format (example 2023/12/31). Gets emails after/before a certain date. You can also use them in combination to get emails from a certain period.     &lt;b&gt;is&lt;/b&gt;: Can have the following values: flagged     An example of a basic query with filters can be &#x60;&#x60;&#x60;json {     \&quot;filters\&quot;: {             \&quot;key\&quot;: \&quot;category\&quot;,             \&quot;value\&quot;: \&quot;Test\&quot;         } } &#x60;&#x60;&#x60; Which will list all emails that have the category \&quot;Test\&quot;.    Specifying a custom folder in the same query &#x60;&#x60;&#x60;json {     \&quot;folder\&quot;: \&quot;Folder Name\&quot;,     \&quot;filters\&quot;: {             \&quot;key\&quot;: \&quot;category\&quot;,             \&quot;value\&quot;: \&quot;Test\&quot;         } } &#x60;&#x60;&#x60;  You can use AND and OR operation in the following way: &#x60;&#x60;&#x60;json {     \&quot;filters\&quot;: {         \&quot;AND\&quot;: [             {                 \&quot;key\&quot;: \&quot;after\&quot;,                 \&quot;value\&quot;: \&quot;2024/01/07\&quot;             },             {                 \&quot;OR\&quot;: [                     {                         \&quot;key\&quot;: \&quot;category\&quot;,                         \&quot;value\&quot;: \&quot;Personal\&quot;                     },                     {                         \&quot;key\&quot;: \&quot;category\&quot;,                         \&quot;value\&quot;: \&quot;Test\&quot;                     },                 ]             }         ]     } } &#x60;&#x60;&#x60; This will return emails after 7th of Jan that have either Personal or Test as category.  Note that this is the highest level of nesting we support, i.e. you can&#39;t add more AND/OR filters within the OR filter in the above example.
     * @param outlookSyncInput  (required)
     * @return SyncOutlookRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
     </table>
     */
    public SyncOutlookRequestBuilder syncOutlook(Object filters) throws IllegalArgumentException {
        if (filters == null) throw new IllegalArgumentException("\"filters\" is required but got null");
        return new SyncOutlookRequestBuilder(filters);
    }
    private okhttp3.Call syncReposCall(GithubFetchReposRequest githubFetchReposRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = githubFetchReposRequest;

        // create path and map variables
        String localVarPath = "/integrations/github/sync_repos";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "accessToken", "apiKey", "customerId" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call syncReposValidateBeforeCall(GithubFetchReposRequest githubFetchReposRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'githubFetchReposRequest' is set
        if (githubFetchReposRequest == null) {
            throw new ApiException("Missing the required parameter 'githubFetchReposRequest' when calling syncRepos(Async)");
        }

        return syncReposCall(githubFetchReposRequest, _callback);

    }


    private ApiResponse<Object> syncReposWithHttpInfo(GithubFetchReposRequest githubFetchReposRequest) throws ApiException {
        okhttp3.Call localVarCall = syncReposValidateBeforeCall(githubFetchReposRequest, null);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call syncReposAsync(GithubFetchReposRequest githubFetchReposRequest, final ApiCallback<Object> _callback) throws ApiException {

        okhttp3.Call localVarCall = syncReposValidateBeforeCall(githubFetchReposRequest, _callback);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class SyncReposRequestBuilder {
        private final List<String> repos;
        private Integer dataSourceId;

        private SyncReposRequestBuilder(List<String> repos) {
            this.repos = repos;
        }

        /**
         * Set dataSourceId
         * @param dataSourceId  (optional)
         * @return SyncReposRequestBuilder
         */
        public SyncReposRequestBuilder dataSourceId(Integer dataSourceId) {
            this.dataSourceId = dataSourceId;
            return this;
        }
        
        /**
         * Build call for syncRepos
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            GithubFetchReposRequest githubFetchReposRequest = buildBodyParams();
            return syncReposCall(githubFetchReposRequest, _callback);
        }

        private GithubFetchReposRequest buildBodyParams() {
            GithubFetchReposRequest githubFetchReposRequest = new GithubFetchReposRequest();
            githubFetchReposRequest.repos(this.repos);
            githubFetchReposRequest.dataSourceId(this.dataSourceId);
            return githubFetchReposRequest;
        }

        /**
         * Execute syncRepos request
         * @return Object
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public Object execute() throws ApiException {
            GithubFetchReposRequest githubFetchReposRequest = buildBodyParams();
            ApiResponse<Object> localVarResp = syncReposWithHttpInfo(githubFetchReposRequest);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute syncRepos request with HTTP info returned
         * @return ApiResponse&lt;Object&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Object> executeWithHttpInfo() throws ApiException {
            GithubFetchReposRequest githubFetchReposRequest = buildBodyParams();
            return syncReposWithHttpInfo(githubFetchReposRequest);
        }

        /**
         * Execute syncRepos request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Object> _callback) throws ApiException {
            GithubFetchReposRequest githubFetchReposRequest = buildBodyParams();
            return syncReposAsync(githubFetchReposRequest, _callback);
        }
    }

    /**
     * Github Sync Repos
     * You can retreive repos your token has access to using /integrations/github/repos and sync their content.  You can also pass full name of any public repository (username/repo-name). This will store the repo content with  carbon which can be accessed through /integrations/items/list endpoint. Maximum of 25 repositories are accepted per request.
     * @param githubFetchReposRequest  (required)
     * @return SyncReposRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
     </table>
     */
    public SyncReposRequestBuilder syncRepos(List<String> repos) throws IllegalArgumentException {
        if (repos == null) throw new IllegalArgumentException("\"repos\" is required but got null");
        return new SyncReposRequestBuilder(repos);
    }
    private okhttp3.Call syncRssFeedCall(RSSFeedInput rsSFeedInput, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = rsSFeedInput;

        // create path and map variables
        String localVarPath = "/integrations/rss_feed";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "accessToken", "apiKey", "customerId" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call syncRssFeedValidateBeforeCall(RSSFeedInput rsSFeedInput, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'rsSFeedInput' is set
        if (rsSFeedInput == null) {
            throw new ApiException("Missing the required parameter 'rsSFeedInput' when calling syncRssFeed(Async)");
        }

        return syncRssFeedCall(rsSFeedInput, _callback);

    }


    private ApiResponse<GenericSuccessResponse> syncRssFeedWithHttpInfo(RSSFeedInput rsSFeedInput) throws ApiException {
        okhttp3.Call localVarCall = syncRssFeedValidateBeforeCall(rsSFeedInput, null);
        Type localVarReturnType = new TypeToken<GenericSuccessResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call syncRssFeedAsync(RSSFeedInput rsSFeedInput, final ApiCallback<GenericSuccessResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = syncRssFeedValidateBeforeCall(rsSFeedInput, _callback);
        Type localVarReturnType = new TypeToken<GenericSuccessResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class SyncRssFeedRequestBuilder {
        private final String url;
        private Object tags;
        private Integer chunkSize;
        private Integer chunkOverlap;
        private Boolean skipEmbeddingGeneration;
        private EmbeddingGenerators embeddingModel;
        private Boolean generateSparseVectors;
        private Boolean prependFilenameToChunks;
        private String requestId;

        private SyncRssFeedRequestBuilder(String url) {
            this.url = url;
        }

        /**
         * Set tags
         * @param tags  (optional)
         * @return SyncRssFeedRequestBuilder
         */
        public SyncRssFeedRequestBuilder tags(Object tags) {
            this.tags = tags;
            return this;
        }
        
        /**
         * Set chunkSize
         * @param chunkSize  (optional, default to 1500)
         * @return SyncRssFeedRequestBuilder
         */
        public SyncRssFeedRequestBuilder chunkSize(Integer chunkSize) {
            this.chunkSize = chunkSize;
            return this;
        }
        
        /**
         * Set chunkOverlap
         * @param chunkOverlap  (optional, default to 20)
         * @return SyncRssFeedRequestBuilder
         */
        public SyncRssFeedRequestBuilder chunkOverlap(Integer chunkOverlap) {
            this.chunkOverlap = chunkOverlap;
            return this;
        }
        
        /**
         * Set skipEmbeddingGeneration
         * @param skipEmbeddingGeneration  (optional, default to false)
         * @return SyncRssFeedRequestBuilder
         */
        public SyncRssFeedRequestBuilder skipEmbeddingGeneration(Boolean skipEmbeddingGeneration) {
            this.skipEmbeddingGeneration = skipEmbeddingGeneration;
            return this;
        }
        
        /**
         * Set embeddingModel
         * @param embeddingModel  (optional)
         * @return SyncRssFeedRequestBuilder
         */
        public SyncRssFeedRequestBuilder embeddingModel(EmbeddingGenerators embeddingModel) {
            this.embeddingModel = embeddingModel;
            return this;
        }
        
        /**
         * Set generateSparseVectors
         * @param generateSparseVectors  (optional, default to false)
         * @return SyncRssFeedRequestBuilder
         */
        public SyncRssFeedRequestBuilder generateSparseVectors(Boolean generateSparseVectors) {
            this.generateSparseVectors = generateSparseVectors;
            return this;
        }
        
        /**
         * Set prependFilenameToChunks
         * @param prependFilenameToChunks  (optional, default to false)
         * @return SyncRssFeedRequestBuilder
         */
        public SyncRssFeedRequestBuilder prependFilenameToChunks(Boolean prependFilenameToChunks) {
            this.prependFilenameToChunks = prependFilenameToChunks;
            return this;
        }
        
        /**
         * Set requestId
         * @param requestId  (optional)
         * @return SyncRssFeedRequestBuilder
         */
        public SyncRssFeedRequestBuilder requestId(String requestId) {
            this.requestId = requestId;
            return this;
        }
        
        /**
         * Build call for syncRssFeed
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            RSSFeedInput rsSFeedInput = buildBodyParams();
            return syncRssFeedCall(rsSFeedInput, _callback);
        }

        private RSSFeedInput buildBodyParams() {
            RSSFeedInput rsSFeedInput = new RSSFeedInput();
            rsSFeedInput.tags(this.tags);
            rsSFeedInput.url(this.url);
            rsSFeedInput.chunkSize(this.chunkSize);
            rsSFeedInput.chunkOverlap(this.chunkOverlap);
            rsSFeedInput.skipEmbeddingGeneration(this.skipEmbeddingGeneration);
            rsSFeedInput.embeddingModel(this.embeddingModel);
            rsSFeedInput.generateSparseVectors(this.generateSparseVectors);
            rsSFeedInput.prependFilenameToChunks(this.prependFilenameToChunks);
            rsSFeedInput.requestId(this.requestId);
            return rsSFeedInput;
        }

        /**
         * Execute syncRssFeed request
         * @return GenericSuccessResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public GenericSuccessResponse execute() throws ApiException {
            RSSFeedInput rsSFeedInput = buildBodyParams();
            ApiResponse<GenericSuccessResponse> localVarResp = syncRssFeedWithHttpInfo(rsSFeedInput);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute syncRssFeed request with HTTP info returned
         * @return ApiResponse&lt;GenericSuccessResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<GenericSuccessResponse> executeWithHttpInfo() throws ApiException {
            RSSFeedInput rsSFeedInput = buildBodyParams();
            return syncRssFeedWithHttpInfo(rsSFeedInput);
        }

        /**
         * Execute syncRssFeed request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<GenericSuccessResponse> _callback) throws ApiException {
            RSSFeedInput rsSFeedInput = buildBodyParams();
            return syncRssFeedAsync(rsSFeedInput, _callback);
        }
    }

    /**
     * Rss Feed
     * 
     * @param rsSFeedInput  (required)
     * @return SyncRssFeedRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
     </table>
     */
    public SyncRssFeedRequestBuilder syncRssFeed(String url) throws IllegalArgumentException {
        if (url == null) throw new IllegalArgumentException("\"url\" is required but got null");
            

        return new SyncRssFeedRequestBuilder(url);
    }
    private okhttp3.Call syncS3FilesCall(S3FileSyncInput s3FileSyncInput, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = s3FileSyncInput;

        // create path and map variables
        String localVarPath = "/integrations/s3/files";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "accessToken", "apiKey", "customerId" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call syncS3FilesValidateBeforeCall(S3FileSyncInput s3FileSyncInput, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 's3FileSyncInput' is set
        if (s3FileSyncInput == null) {
            throw new ApiException("Missing the required parameter 's3FileSyncInput' when calling syncS3Files(Async)");
        }

        return syncS3FilesCall(s3FileSyncInput, _callback);

    }


    private ApiResponse<GenericSuccessResponse> syncS3FilesWithHttpInfo(S3FileSyncInput s3FileSyncInput) throws ApiException {
        okhttp3.Call localVarCall = syncS3FilesValidateBeforeCall(s3FileSyncInput, null);
        Type localVarReturnType = new TypeToken<GenericSuccessResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call syncS3FilesAsync(S3FileSyncInput s3FileSyncInput, final ApiCallback<GenericSuccessResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = syncS3FilesValidateBeforeCall(s3FileSyncInput, _callback);
        Type localVarReturnType = new TypeToken<GenericSuccessResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class SyncS3FilesRequestBuilder {
        private final List<S3GetFileInput> ids;
        private Object tags;
        private Integer chunkSize;
        private Integer chunkOverlap;
        private Boolean skipEmbeddingGeneration;
        private EmbeddingGenerators embeddingModel;
        private Boolean generateSparseVectors;
        private Boolean prependFilenameToChunks;
        private Integer maxItemsPerChunk;
        private Boolean setPageAsBoundary;
        private Integer dataSourceId;
        private String requestId;
        private Boolean useOcr;
        private Boolean parsePdfTablesWithOcr;
        private FileSyncConfigNullable fileSyncConfig;

        private SyncS3FilesRequestBuilder(List<S3GetFileInput> ids) {
            this.ids = ids;
        }

        /**
         * Set tags
         * @param tags  (optional)
         * @return SyncS3FilesRequestBuilder
         */
        public SyncS3FilesRequestBuilder tags(Object tags) {
            this.tags = tags;
            return this;
        }
        
        /**
         * Set chunkSize
         * @param chunkSize  (optional, default to 1500)
         * @return SyncS3FilesRequestBuilder
         */
        public SyncS3FilesRequestBuilder chunkSize(Integer chunkSize) {
            this.chunkSize = chunkSize;
            return this;
        }
        
        /**
         * Set chunkOverlap
         * @param chunkOverlap  (optional, default to 20)
         * @return SyncS3FilesRequestBuilder
         */
        public SyncS3FilesRequestBuilder chunkOverlap(Integer chunkOverlap) {
            this.chunkOverlap = chunkOverlap;
            return this;
        }
        
        /**
         * Set skipEmbeddingGeneration
         * @param skipEmbeddingGeneration  (optional, default to false)
         * @return SyncS3FilesRequestBuilder
         */
        public SyncS3FilesRequestBuilder skipEmbeddingGeneration(Boolean skipEmbeddingGeneration) {
            this.skipEmbeddingGeneration = skipEmbeddingGeneration;
            return this;
        }
        
        /**
         * Set embeddingModel
         * @param embeddingModel  (optional)
         * @return SyncS3FilesRequestBuilder
         */
        public SyncS3FilesRequestBuilder embeddingModel(EmbeddingGenerators embeddingModel) {
            this.embeddingModel = embeddingModel;
            return this;
        }
        
        /**
         * Set generateSparseVectors
         * @param generateSparseVectors  (optional, default to false)
         * @return SyncS3FilesRequestBuilder
         */
        public SyncS3FilesRequestBuilder generateSparseVectors(Boolean generateSparseVectors) {
            this.generateSparseVectors = generateSparseVectors;
            return this;
        }
        
        /**
         * Set prependFilenameToChunks
         * @param prependFilenameToChunks  (optional, default to false)
         * @return SyncS3FilesRequestBuilder
         */
        public SyncS3FilesRequestBuilder prependFilenameToChunks(Boolean prependFilenameToChunks) {
            this.prependFilenameToChunks = prependFilenameToChunks;
            return this;
        }
        
        /**
         * Set maxItemsPerChunk
         * @param maxItemsPerChunk Number of objects per chunk. For csv, tsv, xlsx, and json files only. (optional)
         * @return SyncS3FilesRequestBuilder
         */
        public SyncS3FilesRequestBuilder maxItemsPerChunk(Integer maxItemsPerChunk) {
            this.maxItemsPerChunk = maxItemsPerChunk;
            return this;
        }
        
        /**
         * Set setPageAsBoundary
         * @param setPageAsBoundary  (optional, default to false)
         * @return SyncS3FilesRequestBuilder
         */
        public SyncS3FilesRequestBuilder setPageAsBoundary(Boolean setPageAsBoundary) {
            this.setPageAsBoundary = setPageAsBoundary;
            return this;
        }
        
        /**
         * Set dataSourceId
         * @param dataSourceId  (optional)
         * @return SyncS3FilesRequestBuilder
         */
        public SyncS3FilesRequestBuilder dataSourceId(Integer dataSourceId) {
            this.dataSourceId = dataSourceId;
            return this;
        }
        
        /**
         * Set requestId
         * @param requestId  (optional)
         * @return SyncS3FilesRequestBuilder
         */
        public SyncS3FilesRequestBuilder requestId(String requestId) {
            this.requestId = requestId;
            return this;
        }
        
        /**
         * Set useOcr
         * @param useOcr  (optional, default to false)
         * @return SyncS3FilesRequestBuilder
         */
        public SyncS3FilesRequestBuilder useOcr(Boolean useOcr) {
            this.useOcr = useOcr;
            return this;
        }
        
        /**
         * Set parsePdfTablesWithOcr
         * @param parsePdfTablesWithOcr  (optional, default to false)
         * @return SyncS3FilesRequestBuilder
         */
        public SyncS3FilesRequestBuilder parsePdfTablesWithOcr(Boolean parsePdfTablesWithOcr) {
            this.parsePdfTablesWithOcr = parsePdfTablesWithOcr;
            return this;
        }
        
        /**
         * Set fileSyncConfig
         * @param fileSyncConfig  (optional)
         * @return SyncS3FilesRequestBuilder
         */
        public SyncS3FilesRequestBuilder fileSyncConfig(FileSyncConfigNullable fileSyncConfig) {
            this.fileSyncConfig = fileSyncConfig;
            return this;
        }
        
        /**
         * Build call for syncS3Files
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            S3FileSyncInput s3FileSyncInput = buildBodyParams();
            return syncS3FilesCall(s3FileSyncInput, _callback);
        }

        private S3FileSyncInput buildBodyParams() {
            S3FileSyncInput s3FileSyncInput = new S3FileSyncInput();
            s3FileSyncInput.tags(this.tags);
            s3FileSyncInput.ids(this.ids);
            s3FileSyncInput.chunkSize(this.chunkSize);
            s3FileSyncInput.chunkOverlap(this.chunkOverlap);
            s3FileSyncInput.skipEmbeddingGeneration(this.skipEmbeddingGeneration);
            s3FileSyncInput.embeddingModel(this.embeddingModel);
            s3FileSyncInput.generateSparseVectors(this.generateSparseVectors);
            s3FileSyncInput.prependFilenameToChunks(this.prependFilenameToChunks);
            s3FileSyncInput.maxItemsPerChunk(this.maxItemsPerChunk);
            s3FileSyncInput.setPageAsBoundary(this.setPageAsBoundary);
            s3FileSyncInput.dataSourceId(this.dataSourceId);
            s3FileSyncInput.requestId(this.requestId);
            s3FileSyncInput.useOcr(this.useOcr);
            s3FileSyncInput.parsePdfTablesWithOcr(this.parsePdfTablesWithOcr);
            s3FileSyncInput.fileSyncConfig(this.fileSyncConfig);
            return s3FileSyncInput;
        }

        /**
         * Execute syncS3Files request
         * @return GenericSuccessResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public GenericSuccessResponse execute() throws ApiException {
            S3FileSyncInput s3FileSyncInput = buildBodyParams();
            ApiResponse<GenericSuccessResponse> localVarResp = syncS3FilesWithHttpInfo(s3FileSyncInput);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute syncS3Files request with HTTP info returned
         * @return ApiResponse&lt;GenericSuccessResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<GenericSuccessResponse> executeWithHttpInfo() throws ApiException {
            S3FileSyncInput s3FileSyncInput = buildBodyParams();
            return syncS3FilesWithHttpInfo(s3FileSyncInput);
        }

        /**
         * Execute syncS3Files request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<GenericSuccessResponse> _callback) throws ApiException {
            S3FileSyncInput s3FileSyncInput = buildBodyParams();
            return syncS3FilesAsync(s3FileSyncInput, _callback);
        }
    }

    /**
     * S3 Files
     * After optionally loading the items via /integrations/items/sync and integrations/items/list, use the bucket name  and object key as the ID in this endpoint to sync them into Carbon. Additional parameters below can associate  data with the selected items or modify the sync behavior
     * @param s3FileSyncInput  (required)
     * @return SyncS3FilesRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
     </table>
     */
    public SyncS3FilesRequestBuilder syncS3Files(List<S3GetFileInput> ids) throws IllegalArgumentException {
        if (ids == null) throw new IllegalArgumentException("\"ids\" is required but got null");
        return new SyncS3FilesRequestBuilder(ids);
    }
}
