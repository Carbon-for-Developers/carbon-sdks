/*
 * Carbon
 * Connect external data to LLMs, no matter the source.
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by Konfig (https://konfigthis.com).
 * Do not edit the class manually.
 */


package com.konfigthis.carbonai.client.api;

import com.konfigthis.carbonai.client.ApiCallback;
import com.konfigthis.carbonai.client.ApiClient;
import com.konfigthis.carbonai.client.ApiException;
import com.konfigthis.carbonai.client.ApiResponse;
import com.konfigthis.carbonai.client.Configuration;
import com.konfigthis.carbonai.client.Pair;
import com.konfigthis.carbonai.client.ProgressRequestBody;
import com.konfigthis.carbonai.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import com.konfigthis.carbonai.client.model.ConnectDataSourceInput;
import com.konfigthis.carbonai.client.model.ConnectDataSourceResponse;
import com.konfigthis.carbonai.client.model.DataSourceType;
import com.konfigthis.carbonai.client.model.EmbeddingGenerators;
import com.konfigthis.carbonai.client.model.EmbeddingGeneratorsNullable;
import com.konfigthis.carbonai.client.model.ExternalSourceItemsOrderBy;
import com.konfigthis.carbonai.client.model.FileSyncConfigNullable;
import com.konfigthis.carbonai.client.model.FreshDeskConnectRequest;
import com.konfigthis.carbonai.client.model.GenericSuccessResponse;
import com.konfigthis.carbonai.client.model.GitbookConnectRequest;
import com.konfigthis.carbonai.client.model.GitbookSyncRequest;
import com.konfigthis.carbonai.client.model.GithubConnectRequest;
import com.konfigthis.carbonai.client.model.GithubFetchReposRequest;
import com.konfigthis.carbonai.client.model.GmailSyncInput;
import com.konfigthis.carbonai.client.model.ListDataSourceItemsRequest;
import com.konfigthis.carbonai.client.model.ListDataSourceItemsResponse;
import com.konfigthis.carbonai.client.model.ListItemsFiltersNullable;
import com.konfigthis.carbonai.client.model.ListRequest;
import com.konfigthis.carbonai.client.model.ListResponse;
import com.konfigthis.carbonai.client.model.OANSCZGF;
import com.konfigthis.carbonai.client.model.OAuthURLRequest;
import com.konfigthis.carbonai.client.model.OrderDirV2;
import com.konfigthis.carbonai.client.model.OrganizationUserDataSourceAPI;
import com.konfigthis.carbonai.client.model.OuthURLResponse;
import com.konfigthis.carbonai.client.model.OutlookSyncInput;
import com.konfigthis.carbonai.client.model.Pagination;
import com.konfigthis.carbonai.client.model.RSSFeedInput;
import com.konfigthis.carbonai.client.model.S3AuthRequest;
import com.konfigthis.carbonai.client.model.S3FileSyncInput;
import com.konfigthis.carbonai.client.model.S3GetFileInput;
import com.konfigthis.carbonai.client.model.SlackFilters;
import com.konfigthis.carbonai.client.model.SlackSyncRequest;
import com.konfigthis.carbonai.client.model.SyncDirectoryRequest;
import com.konfigthis.carbonai.client.model.SyncFilesRequest;
import com.konfigthis.carbonai.client.model.SyncOptions;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.ws.rs.core.GenericType;

public class IntegrationsApiGenerated {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public IntegrationsApiGenerated() throws IllegalArgumentException {
        this(Configuration.getDefaultApiClient());
    }

    public IntegrationsApiGenerated(ApiClient apiClient) throws IllegalArgumentException {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    private okhttp3.Call cancelCall(SyncDirectoryRequest syncDirectoryRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = syncDirectoryRequest;

        // create path and map variables
        String localVarPath = "/integrations/items/sync/cancel";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "accessToken", "apiKey", "customerId" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call cancelValidateBeforeCall(SyncDirectoryRequest syncDirectoryRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'syncDirectoryRequest' is set
        if (syncDirectoryRequest == null) {
            throw new ApiException("Missing the required parameter 'syncDirectoryRequest' when calling cancel(Async)");
        }

        return cancelCall(syncDirectoryRequest, _callback);

    }


    private ApiResponse<OrganizationUserDataSourceAPI> cancelWithHttpInfo(SyncDirectoryRequest syncDirectoryRequest) throws ApiException {
        okhttp3.Call localVarCall = cancelValidateBeforeCall(syncDirectoryRequest, null);
        Type localVarReturnType = new TypeToken<OrganizationUserDataSourceAPI>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call cancelAsync(SyncDirectoryRequest syncDirectoryRequest, final ApiCallback<OrganizationUserDataSourceAPI> _callback) throws ApiException {

        okhttp3.Call localVarCall = cancelValidateBeforeCall(syncDirectoryRequest, _callback);
        Type localVarReturnType = new TypeToken<OrganizationUserDataSourceAPI>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public abstract class CancelRequestBuilderGenerated {
        final Integer dataSourceId;

        public CancelRequestBuilderGenerated(Integer dataSourceId) {
            this.dataSourceId = dataSourceId;
        }

        /**
         * Build call for cancel
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            SyncDirectoryRequest syncDirectoryRequest = buildBodyParams();
            return cancelCall(syncDirectoryRequest, _callback);
        }

        private SyncDirectoryRequest buildBodyParams() {
            SyncDirectoryRequest syncDirectoryRequest = new SyncDirectoryRequest();
            syncDirectoryRequest.dataSourceId(this.dataSourceId);
            return syncDirectoryRequest;
        }

        /**
         * Execute cancel request
         * @return OrganizationUserDataSourceAPI
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public OrganizationUserDataSourceAPI execute() throws ApiException {
            SyncDirectoryRequest syncDirectoryRequest = buildBodyParams();
            ApiResponse<OrganizationUserDataSourceAPI> localVarResp = cancelWithHttpInfo(syncDirectoryRequest);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute cancel request with HTTP info returned
         * @return ApiResponse&lt;OrganizationUserDataSourceAPI&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<OrganizationUserDataSourceAPI> executeWithHttpInfo() throws ApiException {
            SyncDirectoryRequest syncDirectoryRequest = buildBodyParams();
            return cancelWithHttpInfo(syncDirectoryRequest);
        }

        /**
         * Execute cancel request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<OrganizationUserDataSourceAPI> _callback) throws ApiException {
            SyncDirectoryRequest syncDirectoryRequest = buildBodyParams();
            return cancelAsync(syncDirectoryRequest, _callback);
        }
    }

    /**
     * Cancel Data Source Items Sync
     * 
     * @param syncDirectoryRequest  (required)
     * @return CancelRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
     </table>
     */
    public IntegrationsApi.CancelRequestBuilder cancel(Integer dataSourceId) throws IllegalArgumentException {
        if (dataSourceId == null) throw new IllegalArgumentException("\"dataSourceId\" is required but got null");
        return ((IntegrationsApi) this).new CancelRequestBuilder(dataSourceId);
    }
    private okhttp3.Call connectDataSourceCall(ConnectDataSourceInput connectDataSourceInput, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = connectDataSourceInput;

        // create path and map variables
        String localVarPath = "/integrations/connect";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "accessToken", "apiKey", "customerId" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call connectDataSourceValidateBeforeCall(ConnectDataSourceInput connectDataSourceInput, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'connectDataSourceInput' is set
        if (connectDataSourceInput == null) {
            throw new ApiException("Missing the required parameter 'connectDataSourceInput' when calling connectDataSource(Async)");
        }

        return connectDataSourceCall(connectDataSourceInput, _callback);

    }


    private ApiResponse<ConnectDataSourceResponse> connectDataSourceWithHttpInfo(ConnectDataSourceInput connectDataSourceInput) throws ApiException {
        okhttp3.Call localVarCall = connectDataSourceValidateBeforeCall(connectDataSourceInput, null);
        Type localVarReturnType = new TypeToken<ConnectDataSourceResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call connectDataSourceAsync(ConnectDataSourceInput connectDataSourceInput, final ApiCallback<ConnectDataSourceResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = connectDataSourceValidateBeforeCall(connectDataSourceInput, _callback);
        Type localVarReturnType = new TypeToken<ConnectDataSourceResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public abstract class ConnectDataSourceRequestBuilderGenerated {
        final OANSCZGF authentication;
        SyncOptions syncOptions;

        public ConnectDataSourceRequestBuilderGenerated(OANSCZGF authentication) {
            this.authentication = authentication;
        }

        /**
         * Set syncOptions
         * @param syncOptions  (optional)
         * @return IntegrationsApi.ConnectDataSourceRequestBuilder
         */
        public IntegrationsApi.ConnectDataSourceRequestBuilder syncOptions(SyncOptions syncOptions) {
            this.syncOptions = syncOptions;
            return (IntegrationsApi.ConnectDataSourceRequestBuilder) this;
        }
        
        /**
         * Build call for connectDataSource
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            ConnectDataSourceInput connectDataSourceInput = buildBodyParams();
            return connectDataSourceCall(connectDataSourceInput, _callback);
        }

        private ConnectDataSourceInput buildBodyParams() {
            ConnectDataSourceInput connectDataSourceInput = new ConnectDataSourceInput();
            connectDataSourceInput.authentication(this.authentication);
            connectDataSourceInput.syncOptions(this.syncOptions);
            return connectDataSourceInput;
        }

        /**
         * Execute connectDataSource request
         * @return ConnectDataSourceResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public ConnectDataSourceResponse execute() throws ApiException {
            ConnectDataSourceInput connectDataSourceInput = buildBodyParams();
            ApiResponse<ConnectDataSourceResponse> localVarResp = connectDataSourceWithHttpInfo(connectDataSourceInput);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute connectDataSource request with HTTP info returned
         * @return ApiResponse&lt;ConnectDataSourceResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<ConnectDataSourceResponse> executeWithHttpInfo() throws ApiException {
            ConnectDataSourceInput connectDataSourceInput = buildBodyParams();
            return connectDataSourceWithHttpInfo(connectDataSourceInput);
        }

        /**
         * Execute connectDataSource request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<ConnectDataSourceResponse> _callback) throws ApiException {
            ConnectDataSourceInput connectDataSourceInput = buildBodyParams();
            return connectDataSourceAsync(connectDataSourceInput, _callback);
        }
    }

    /**
     * Connect Data Source
     * 
     * @param connectDataSourceInput  (required)
     * @return ConnectDataSourceRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
     </table>
     */
    public IntegrationsApi.ConnectDataSourceRequestBuilder connectDataSource(OANSCZGF authentication) throws IllegalArgumentException {
        if (authentication == null) throw new IllegalArgumentException("\"authentication\" is required but got null");
        return ((IntegrationsApi) this).new ConnectDataSourceRequestBuilder(authentication);
    }
    private okhttp3.Call connectFreshdeskCall(FreshDeskConnectRequest freshDeskConnectRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = freshDeskConnectRequest;

        // create path and map variables
        String localVarPath = "/integrations/freshdesk";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "accessToken", "apiKey", "customerId" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call connectFreshdeskValidateBeforeCall(FreshDeskConnectRequest freshDeskConnectRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'freshDeskConnectRequest' is set
        if (freshDeskConnectRequest == null) {
            throw new ApiException("Missing the required parameter 'freshDeskConnectRequest' when calling connectFreshdesk(Async)");
        }

        return connectFreshdeskCall(freshDeskConnectRequest, _callback);

    }


    private ApiResponse<GenericSuccessResponse> connectFreshdeskWithHttpInfo(FreshDeskConnectRequest freshDeskConnectRequest) throws ApiException {
        okhttp3.Call localVarCall = connectFreshdeskValidateBeforeCall(freshDeskConnectRequest, null);
        Type localVarReturnType = new TypeToken<GenericSuccessResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call connectFreshdeskAsync(FreshDeskConnectRequest freshDeskConnectRequest, final ApiCallback<GenericSuccessResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = connectFreshdeskValidateBeforeCall(freshDeskConnectRequest, _callback);
        Type localVarReturnType = new TypeToken<GenericSuccessResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public abstract class ConnectFreshdeskRequestBuilderGenerated {
        final String domain;
        final String apiKey;
        Object tags;
        Integer chunkSize;
        Integer chunkOverlap;
        Boolean skipEmbeddingGeneration;
        EmbeddingGeneratorsNullable embeddingModel;
        Boolean generateSparseVectors;
        Boolean prependFilenameToChunks;
        Boolean syncFilesOnConnection;
        String requestId;
        Boolean syncSourceItems;
        FileSyncConfigNullable fileSyncConfig;

        public ConnectFreshdeskRequestBuilderGenerated(String domain, String apiKey) {
            this.domain = domain;
            this.apiKey = apiKey;
        }

        /**
         * Set tags
         * @param tags  (optional)
         * @return IntegrationsApi.ConnectFreshdeskRequestBuilder
         */
        public IntegrationsApi.ConnectFreshdeskRequestBuilder tags(Object tags) {
            this.tags = tags;
            return (IntegrationsApi.ConnectFreshdeskRequestBuilder) this;
        }
        
        /**
         * Set chunkSize
         * @param chunkSize  (optional, default to 1500)
         * @return IntegrationsApi.ConnectFreshdeskRequestBuilder
         */
        public IntegrationsApi.ConnectFreshdeskRequestBuilder chunkSize(Integer chunkSize) {
            this.chunkSize = chunkSize;
            return (IntegrationsApi.ConnectFreshdeskRequestBuilder) this;
        }
        
        /**
         * Set chunkOverlap
         * @param chunkOverlap  (optional, default to 20)
         * @return IntegrationsApi.ConnectFreshdeskRequestBuilder
         */
        public IntegrationsApi.ConnectFreshdeskRequestBuilder chunkOverlap(Integer chunkOverlap) {
            this.chunkOverlap = chunkOverlap;
            return (IntegrationsApi.ConnectFreshdeskRequestBuilder) this;
        }
        
        /**
         * Set skipEmbeddingGeneration
         * @param skipEmbeddingGeneration  (optional, default to false)
         * @return IntegrationsApi.ConnectFreshdeskRequestBuilder
         */
        public IntegrationsApi.ConnectFreshdeskRequestBuilder skipEmbeddingGeneration(Boolean skipEmbeddingGeneration) {
            this.skipEmbeddingGeneration = skipEmbeddingGeneration;
            return (IntegrationsApi.ConnectFreshdeskRequestBuilder) this;
        }
        
        /**
         * Set embeddingModel
         * @param embeddingModel  (optional, default to OPENAI)
         * @return IntegrationsApi.ConnectFreshdeskRequestBuilder
         */
        public IntegrationsApi.ConnectFreshdeskRequestBuilder embeddingModel(EmbeddingGeneratorsNullable embeddingModel) {
            this.embeddingModel = embeddingModel;
            return (IntegrationsApi.ConnectFreshdeskRequestBuilder) this;
        }
        
        /**
         * Set generateSparseVectors
         * @param generateSparseVectors  (optional, default to false)
         * @return IntegrationsApi.ConnectFreshdeskRequestBuilder
         */
        public IntegrationsApi.ConnectFreshdeskRequestBuilder generateSparseVectors(Boolean generateSparseVectors) {
            this.generateSparseVectors = generateSparseVectors;
            return (IntegrationsApi.ConnectFreshdeskRequestBuilder) this;
        }
        
        /**
         * Set prependFilenameToChunks
         * @param prependFilenameToChunks  (optional, default to false)
         * @return IntegrationsApi.ConnectFreshdeskRequestBuilder
         */
        public IntegrationsApi.ConnectFreshdeskRequestBuilder prependFilenameToChunks(Boolean prependFilenameToChunks) {
            this.prependFilenameToChunks = prependFilenameToChunks;
            return (IntegrationsApi.ConnectFreshdeskRequestBuilder) this;
        }
        
        /**
         * Set syncFilesOnConnection
         * @param syncFilesOnConnection  (optional, default to true)
         * @return IntegrationsApi.ConnectFreshdeskRequestBuilder
         */
        public IntegrationsApi.ConnectFreshdeskRequestBuilder syncFilesOnConnection(Boolean syncFilesOnConnection) {
            this.syncFilesOnConnection = syncFilesOnConnection;
            return (IntegrationsApi.ConnectFreshdeskRequestBuilder) this;
        }
        
        /**
         * Set requestId
         * @param requestId  (optional)
         * @return IntegrationsApi.ConnectFreshdeskRequestBuilder
         */
        public IntegrationsApi.ConnectFreshdeskRequestBuilder requestId(String requestId) {
            this.requestId = requestId;
            return (IntegrationsApi.ConnectFreshdeskRequestBuilder) this;
        }
        
        /**
         * Set syncSourceItems
         * @param syncSourceItems Enabling this flag will fetch all available content from the source to be listed via list items endpoint (optional, default to true)
         * @return IntegrationsApi.ConnectFreshdeskRequestBuilder
         */
        public IntegrationsApi.ConnectFreshdeskRequestBuilder syncSourceItems(Boolean syncSourceItems) {
            this.syncSourceItems = syncSourceItems;
            return (IntegrationsApi.ConnectFreshdeskRequestBuilder) this;
        }
        
        /**
         * Set fileSyncConfig
         * @param fileSyncConfig  (optional)
         * @return IntegrationsApi.ConnectFreshdeskRequestBuilder
         */
        public IntegrationsApi.ConnectFreshdeskRequestBuilder fileSyncConfig(FileSyncConfigNullable fileSyncConfig) {
            this.fileSyncConfig = fileSyncConfig;
            return (IntegrationsApi.ConnectFreshdeskRequestBuilder) this;
        }
        
        /**
         * Build call for connectFreshdesk
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            FreshDeskConnectRequest freshDeskConnectRequest = buildBodyParams();
            return connectFreshdeskCall(freshDeskConnectRequest, _callback);
        }

        private FreshDeskConnectRequest buildBodyParams() {
            FreshDeskConnectRequest freshDeskConnectRequest = new FreshDeskConnectRequest();
            freshDeskConnectRequest.tags(this.tags);
            freshDeskConnectRequest.domain(this.domain);
            freshDeskConnectRequest.apiKey(this.apiKey);
            freshDeskConnectRequest.chunkSize(this.chunkSize);
            freshDeskConnectRequest.chunkOverlap(this.chunkOverlap);
            freshDeskConnectRequest.skipEmbeddingGeneration(this.skipEmbeddingGeneration);
            freshDeskConnectRequest.embeddingModel(this.embeddingModel);
            freshDeskConnectRequest.generateSparseVectors(this.generateSparseVectors);
            freshDeskConnectRequest.prependFilenameToChunks(this.prependFilenameToChunks);
            freshDeskConnectRequest.syncFilesOnConnection(this.syncFilesOnConnection);
            freshDeskConnectRequest.requestId(this.requestId);
            freshDeskConnectRequest.syncSourceItems(this.syncSourceItems);
            freshDeskConnectRequest.fileSyncConfig(this.fileSyncConfig);
            return freshDeskConnectRequest;
        }

        /**
         * Execute connectFreshdesk request
         * @return GenericSuccessResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public GenericSuccessResponse execute() throws ApiException {
            FreshDeskConnectRequest freshDeskConnectRequest = buildBodyParams();
            ApiResponse<GenericSuccessResponse> localVarResp = connectFreshdeskWithHttpInfo(freshDeskConnectRequest);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute connectFreshdesk request with HTTP info returned
         * @return ApiResponse&lt;GenericSuccessResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<GenericSuccessResponse> executeWithHttpInfo() throws ApiException {
            FreshDeskConnectRequest freshDeskConnectRequest = buildBodyParams();
            return connectFreshdeskWithHttpInfo(freshDeskConnectRequest);
        }

        /**
         * Execute connectFreshdesk request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<GenericSuccessResponse> _callback) throws ApiException {
            FreshDeskConnectRequest freshDeskConnectRequest = buildBodyParams();
            return connectFreshdeskAsync(freshDeskConnectRequest, _callback);
        }
    }

    /**
     * Freshdesk Connect
     * Refer this article to obtain an API key https://support.freshdesk.com/en/support/solutions/articles/215517. Make sure that your API key has the permission to read solutions from your account and you are on a &lt;b&gt;paid&lt;/b&gt; plan. Once you have an API key, you can make a request to this endpoint along with your freshdesk domain. This will  trigger an automatic sync of the articles in your \&quot;solutions\&quot; tab. Additional parameters below can be used to associate  data with the synced articles or modify the sync behavior.
     * @param freshDeskConnectRequest  (required)
     * @return ConnectFreshdeskRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
     </table>
     */
    public IntegrationsApi.ConnectFreshdeskRequestBuilder connectFreshdesk(String domain, String apiKey) throws IllegalArgumentException {
        if (domain == null) throw new IllegalArgumentException("\"domain\" is required but got null");
            

        if (apiKey == null) throw new IllegalArgumentException("\"apiKey\" is required but got null");
            

        return ((IntegrationsApi) this).new ConnectFreshdeskRequestBuilder(domain, apiKey);
    }
    private okhttp3.Call connectGitbookCall(GitbookConnectRequest gitbookConnectRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = gitbookConnectRequest;

        // create path and map variables
        String localVarPath = "/integrations/gitbook";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "accessToken", "apiKey", "customerId" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call connectGitbookValidateBeforeCall(GitbookConnectRequest gitbookConnectRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'gitbookConnectRequest' is set
        if (gitbookConnectRequest == null) {
            throw new ApiException("Missing the required parameter 'gitbookConnectRequest' when calling connectGitbook(Async)");
        }

        return connectGitbookCall(gitbookConnectRequest, _callback);

    }


    private ApiResponse<GenericSuccessResponse> connectGitbookWithHttpInfo(GitbookConnectRequest gitbookConnectRequest) throws ApiException {
        okhttp3.Call localVarCall = connectGitbookValidateBeforeCall(gitbookConnectRequest, null);
        Type localVarReturnType = new TypeToken<GenericSuccessResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call connectGitbookAsync(GitbookConnectRequest gitbookConnectRequest, final ApiCallback<GenericSuccessResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = connectGitbookValidateBeforeCall(gitbookConnectRequest, _callback);
        Type localVarReturnType = new TypeToken<GenericSuccessResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public abstract class ConnectGitbookRequestBuilderGenerated {
        final String organization;
        final String accessToken;
        Object tags;
        Integer chunkSize;
        Integer chunkOverlap;
        Boolean skipEmbeddingGeneration;
        EmbeddingGenerators embeddingModel;
        Boolean generateSparseVectors;
        Boolean prependFilenameToChunks;
        Boolean syncFilesOnConnection;
        String requestId;
        Boolean syncSourceItems;

        public ConnectGitbookRequestBuilderGenerated(String organization, String accessToken) {
            this.organization = organization;
            this.accessToken = accessToken;
        }

        /**
         * Set tags
         * @param tags  (optional)
         * @return IntegrationsApi.ConnectGitbookRequestBuilder
         */
        public IntegrationsApi.ConnectGitbookRequestBuilder tags(Object tags) {
            this.tags = tags;
            return (IntegrationsApi.ConnectGitbookRequestBuilder) this;
        }
        
        /**
         * Set chunkSize
         * @param chunkSize  (optional, default to 1500)
         * @return IntegrationsApi.ConnectGitbookRequestBuilder
         */
        public IntegrationsApi.ConnectGitbookRequestBuilder chunkSize(Integer chunkSize) {
            this.chunkSize = chunkSize;
            return (IntegrationsApi.ConnectGitbookRequestBuilder) this;
        }
        
        /**
         * Set chunkOverlap
         * @param chunkOverlap  (optional, default to 20)
         * @return IntegrationsApi.ConnectGitbookRequestBuilder
         */
        public IntegrationsApi.ConnectGitbookRequestBuilder chunkOverlap(Integer chunkOverlap) {
            this.chunkOverlap = chunkOverlap;
            return (IntegrationsApi.ConnectGitbookRequestBuilder) this;
        }
        
        /**
         * Set skipEmbeddingGeneration
         * @param skipEmbeddingGeneration  (optional, default to false)
         * @return IntegrationsApi.ConnectGitbookRequestBuilder
         */
        public IntegrationsApi.ConnectGitbookRequestBuilder skipEmbeddingGeneration(Boolean skipEmbeddingGeneration) {
            this.skipEmbeddingGeneration = skipEmbeddingGeneration;
            return (IntegrationsApi.ConnectGitbookRequestBuilder) this;
        }
        
        /**
         * Set embeddingModel
         * @param embeddingModel  (optional)
         * @return IntegrationsApi.ConnectGitbookRequestBuilder
         */
        public IntegrationsApi.ConnectGitbookRequestBuilder embeddingModel(EmbeddingGenerators embeddingModel) {
            this.embeddingModel = embeddingModel;
            return (IntegrationsApi.ConnectGitbookRequestBuilder) this;
        }
        
        /**
         * Set generateSparseVectors
         * @param generateSparseVectors  (optional, default to false)
         * @return IntegrationsApi.ConnectGitbookRequestBuilder
         */
        public IntegrationsApi.ConnectGitbookRequestBuilder generateSparseVectors(Boolean generateSparseVectors) {
            this.generateSparseVectors = generateSparseVectors;
            return (IntegrationsApi.ConnectGitbookRequestBuilder) this;
        }
        
        /**
         * Set prependFilenameToChunks
         * @param prependFilenameToChunks  (optional, default to false)
         * @return IntegrationsApi.ConnectGitbookRequestBuilder
         */
        public IntegrationsApi.ConnectGitbookRequestBuilder prependFilenameToChunks(Boolean prependFilenameToChunks) {
            this.prependFilenameToChunks = prependFilenameToChunks;
            return (IntegrationsApi.ConnectGitbookRequestBuilder) this;
        }
        
        /**
         * Set syncFilesOnConnection
         * @param syncFilesOnConnection  (optional, default to true)
         * @return IntegrationsApi.ConnectGitbookRequestBuilder
         */
        public IntegrationsApi.ConnectGitbookRequestBuilder syncFilesOnConnection(Boolean syncFilesOnConnection) {
            this.syncFilesOnConnection = syncFilesOnConnection;
            return (IntegrationsApi.ConnectGitbookRequestBuilder) this;
        }
        
        /**
         * Set requestId
         * @param requestId  (optional)
         * @return IntegrationsApi.ConnectGitbookRequestBuilder
         */
        public IntegrationsApi.ConnectGitbookRequestBuilder requestId(String requestId) {
            this.requestId = requestId;
            return (IntegrationsApi.ConnectGitbookRequestBuilder) this;
        }
        
        /**
         * Set syncSourceItems
         * @param syncSourceItems Enabling this flag will fetch all available content from the source to be listed via list items endpoint (optional, default to true)
         * @return IntegrationsApi.ConnectGitbookRequestBuilder
         */
        public IntegrationsApi.ConnectGitbookRequestBuilder syncSourceItems(Boolean syncSourceItems) {
            this.syncSourceItems = syncSourceItems;
            return (IntegrationsApi.ConnectGitbookRequestBuilder) this;
        }
        
        /**
         * Build call for connectGitbook
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            GitbookConnectRequest gitbookConnectRequest = buildBodyParams();
            return connectGitbookCall(gitbookConnectRequest, _callback);
        }

        private GitbookConnectRequest buildBodyParams() {
            GitbookConnectRequest gitbookConnectRequest = new GitbookConnectRequest();
            gitbookConnectRequest.tags(this.tags);
            gitbookConnectRequest.organization(this.organization);
            gitbookConnectRequest.accessToken(this.accessToken);
            gitbookConnectRequest.chunkSize(this.chunkSize);
            gitbookConnectRequest.chunkOverlap(this.chunkOverlap);
            gitbookConnectRequest.skipEmbeddingGeneration(this.skipEmbeddingGeneration);
            gitbookConnectRequest.embeddingModel(this.embeddingModel);
            gitbookConnectRequest.generateSparseVectors(this.generateSparseVectors);
            gitbookConnectRequest.prependFilenameToChunks(this.prependFilenameToChunks);
            gitbookConnectRequest.syncFilesOnConnection(this.syncFilesOnConnection);
            gitbookConnectRequest.requestId(this.requestId);
            gitbookConnectRequest.syncSourceItems(this.syncSourceItems);
            return gitbookConnectRequest;
        }

        /**
         * Execute connectGitbook request
         * @return GenericSuccessResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public GenericSuccessResponse execute() throws ApiException {
            GitbookConnectRequest gitbookConnectRequest = buildBodyParams();
            ApiResponse<GenericSuccessResponse> localVarResp = connectGitbookWithHttpInfo(gitbookConnectRequest);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute connectGitbook request with HTTP info returned
         * @return ApiResponse&lt;GenericSuccessResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<GenericSuccessResponse> executeWithHttpInfo() throws ApiException {
            GitbookConnectRequest gitbookConnectRequest = buildBodyParams();
            return connectGitbookWithHttpInfo(gitbookConnectRequest);
        }

        /**
         * Execute connectGitbook request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<GenericSuccessResponse> _callback) throws ApiException {
            GitbookConnectRequest gitbookConnectRequest = buildBodyParams();
            return connectGitbookAsync(gitbookConnectRequest, _callback);
        }
    }

    /**
     * Gitbook Connect
     * You will need an access token to connect your Gitbook account. Note that the permissions will be defined by the user  generating access token so make sure you have the permission to access spaces you will be syncing.  Refer this article for more details https://developer.gitbook.com/gitbook-api/authentication. Additionally, you need to specify the name of organization you will be syncing data from.
     * @param gitbookConnectRequest  (required)
     * @return ConnectGitbookRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
     </table>
     */
    public IntegrationsApi.ConnectGitbookRequestBuilder connectGitbook(String organization, String accessToken) throws IllegalArgumentException {
        if (organization == null) throw new IllegalArgumentException("\"organization\" is required but got null");
            

        if (accessToken == null) throw new IllegalArgumentException("\"accessToken\" is required but got null");
            

        return ((IntegrationsApi) this).new ConnectGitbookRequestBuilder(organization, accessToken);
    }
    private okhttp3.Call createAwsIamUserCall(S3AuthRequest s3AuthRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = s3AuthRequest;

        // create path and map variables
        String localVarPath = "/integrations/s3";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "accessToken", "apiKey", "customerId" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call createAwsIamUserValidateBeforeCall(S3AuthRequest s3AuthRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 's3AuthRequest' is set
        if (s3AuthRequest == null) {
            throw new ApiException("Missing the required parameter 's3AuthRequest' when calling createAwsIamUser(Async)");
        }

        return createAwsIamUserCall(s3AuthRequest, _callback);

    }


    private ApiResponse<OrganizationUserDataSourceAPI> createAwsIamUserWithHttpInfo(S3AuthRequest s3AuthRequest) throws ApiException {
        okhttp3.Call localVarCall = createAwsIamUserValidateBeforeCall(s3AuthRequest, null);
        Type localVarReturnType = new TypeToken<OrganizationUserDataSourceAPI>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call createAwsIamUserAsync(S3AuthRequest s3AuthRequest, final ApiCallback<OrganizationUserDataSourceAPI> _callback) throws ApiException {

        okhttp3.Call localVarCall = createAwsIamUserValidateBeforeCall(s3AuthRequest, _callback);
        Type localVarReturnType = new TypeToken<OrganizationUserDataSourceAPI>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public abstract class CreateAwsIamUserRequestBuilderGenerated {
        final String accessKey;
        final String accessKeySecret;
        Boolean syncSourceItems;

        public CreateAwsIamUserRequestBuilderGenerated(String accessKey, String accessKeySecret) {
            this.accessKey = accessKey;
            this.accessKeySecret = accessKeySecret;
        }

        /**
         * Set syncSourceItems
         * @param syncSourceItems Enabling this flag will fetch all available content from the source to be listed via list items endpoint (optional, default to true)
         * @return IntegrationsApi.CreateAwsIamUserRequestBuilder
         */
        public IntegrationsApi.CreateAwsIamUserRequestBuilder syncSourceItems(Boolean syncSourceItems) {
            this.syncSourceItems = syncSourceItems;
            return (IntegrationsApi.CreateAwsIamUserRequestBuilder) this;
        }
        
        /**
         * Build call for createAwsIamUser
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            S3AuthRequest s3AuthRequest = buildBodyParams();
            return createAwsIamUserCall(s3AuthRequest, _callback);
        }

        private S3AuthRequest buildBodyParams() {
            S3AuthRequest s3AuthRequest = new S3AuthRequest();
            s3AuthRequest.accessKey(this.accessKey);
            s3AuthRequest.accessKeySecret(this.accessKeySecret);
            s3AuthRequest.syncSourceItems(this.syncSourceItems);
            return s3AuthRequest;
        }

        /**
         * Execute createAwsIamUser request
         * @return OrganizationUserDataSourceAPI
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public OrganizationUserDataSourceAPI execute() throws ApiException {
            S3AuthRequest s3AuthRequest = buildBodyParams();
            ApiResponse<OrganizationUserDataSourceAPI> localVarResp = createAwsIamUserWithHttpInfo(s3AuthRequest);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute createAwsIamUser request with HTTP info returned
         * @return ApiResponse&lt;OrganizationUserDataSourceAPI&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<OrganizationUserDataSourceAPI> executeWithHttpInfo() throws ApiException {
            S3AuthRequest s3AuthRequest = buildBodyParams();
            return createAwsIamUserWithHttpInfo(s3AuthRequest);
        }

        /**
         * Execute createAwsIamUser request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<OrganizationUserDataSourceAPI> _callback) throws ApiException {
            S3AuthRequest s3AuthRequest = buildBodyParams();
            return createAwsIamUserAsync(s3AuthRequest, _callback);
        }
    }

    /**
     * S3 Auth
     * Create a new IAM user with permissions to: &lt;ol&gt; &lt;li&gt;List all buckets.&lt;/li&gt; &lt;li&gt;Read from the specific buckets and objects to sync with Carbon. Ensure any future buckets or objects carry  the same permissions.&lt;/li&gt; &lt;/ol&gt; Once created, generate an access key for this user and share the credentials with us. We recommend testing this key beforehand.
     * @param s3AuthRequest  (required)
     * @return CreateAwsIamUserRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
     </table>
     */
    public IntegrationsApi.CreateAwsIamUserRequestBuilder createAwsIamUser(String accessKey, String accessKeySecret) throws IllegalArgumentException {
        if (accessKey == null) throw new IllegalArgumentException("\"accessKey\" is required but got null");
            

        if (accessKeySecret == null) throw new IllegalArgumentException("\"accessKeySecret\" is required but got null");
            

        return ((IntegrationsApi) this).new CreateAwsIamUserRequestBuilder(accessKey, accessKeySecret);
    }
    private okhttp3.Call getOauthUrlCall(OAuthURLRequest oauthURLRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = oauthURLRequest;

        // create path and map variables
        String localVarPath = "/integrations/oauth_url";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "accessToken", "apiKey", "customerId" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getOauthUrlValidateBeforeCall(OAuthURLRequest oauthURLRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'oauthURLRequest' is set
        if (oauthURLRequest == null) {
            throw new ApiException("Missing the required parameter 'oauthURLRequest' when calling getOauthUrl(Async)");
        }

        return getOauthUrlCall(oauthURLRequest, _callback);

    }


    private ApiResponse<OuthURLResponse> getOauthUrlWithHttpInfo(OAuthURLRequest oauthURLRequest) throws ApiException {
        okhttp3.Call localVarCall = getOauthUrlValidateBeforeCall(oauthURLRequest, null);
        Type localVarReturnType = new TypeToken<OuthURLResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getOauthUrlAsync(OAuthURLRequest oauthURLRequest, final ApiCallback<OuthURLResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getOauthUrlValidateBeforeCall(oauthURLRequest, _callback);
        Type localVarReturnType = new TypeToken<OuthURLResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public abstract class GetOauthUrlRequestBuilderGenerated {
        final DataSourceType service;
        Object tags;
        String scope;
        Integer chunkSize;
        Integer chunkOverlap;
        Boolean skipEmbeddingGeneration;
        EmbeddingGeneratorsNullable embeddingModel;
        String zendeskSubdomain;
        String microsoftTenant;
        String sharepointSiteName;
        String confluenceSubdomain;
        Boolean generateSparseVectors;
        Boolean prependFilenameToChunks;
        Integer maxItemsPerChunk;
        String salesforceDomain;
        Boolean syncFilesOnConnection;
        Boolean setPageAsBoundary;
        Integer dataSourceId;
        Boolean connectingNewAccount;
        String requestId;
        Boolean useOcr;
        Boolean parsePdfTablesWithOcr;
        Boolean enableFilePicker;
        Boolean syncSourceItems;
        Boolean incrementalSync;
        FileSyncConfigNullable fileSyncConfig;

        public GetOauthUrlRequestBuilderGenerated(DataSourceType service) {
            this.service = service;
        }

        /**
         * Set tags
         * @param tags  (optional)
         * @return IntegrationsApi.GetOauthUrlRequestBuilder
         */
        public IntegrationsApi.GetOauthUrlRequestBuilder tags(Object tags) {
            this.tags = tags;
            return (IntegrationsApi.GetOauthUrlRequestBuilder) this;
        }
        
        /**
         * Set scope
         * @param scope  (optional)
         * @return IntegrationsApi.GetOauthUrlRequestBuilder
         */
        public IntegrationsApi.GetOauthUrlRequestBuilder scope(String scope) {
            this.scope = scope;
            return (IntegrationsApi.GetOauthUrlRequestBuilder) this;
        }
        
        /**
         * Set chunkSize
         * @param chunkSize  (optional, default to 1500)
         * @return IntegrationsApi.GetOauthUrlRequestBuilder
         */
        public IntegrationsApi.GetOauthUrlRequestBuilder chunkSize(Integer chunkSize) {
            this.chunkSize = chunkSize;
            return (IntegrationsApi.GetOauthUrlRequestBuilder) this;
        }
        
        /**
         * Set chunkOverlap
         * @param chunkOverlap  (optional, default to 20)
         * @return IntegrationsApi.GetOauthUrlRequestBuilder
         */
        public IntegrationsApi.GetOauthUrlRequestBuilder chunkOverlap(Integer chunkOverlap) {
            this.chunkOverlap = chunkOverlap;
            return (IntegrationsApi.GetOauthUrlRequestBuilder) this;
        }
        
        /**
         * Set skipEmbeddingGeneration
         * @param skipEmbeddingGeneration  (optional, default to false)
         * @return IntegrationsApi.GetOauthUrlRequestBuilder
         */
        public IntegrationsApi.GetOauthUrlRequestBuilder skipEmbeddingGeneration(Boolean skipEmbeddingGeneration) {
            this.skipEmbeddingGeneration = skipEmbeddingGeneration;
            return (IntegrationsApi.GetOauthUrlRequestBuilder) this;
        }
        
        /**
         * Set embeddingModel
         * @param embeddingModel  (optional, default to OPENAI)
         * @return IntegrationsApi.GetOauthUrlRequestBuilder
         */
        public IntegrationsApi.GetOauthUrlRequestBuilder embeddingModel(EmbeddingGeneratorsNullable embeddingModel) {
            this.embeddingModel = embeddingModel;
            return (IntegrationsApi.GetOauthUrlRequestBuilder) this;
        }
        
        /**
         * Set zendeskSubdomain
         * @param zendeskSubdomain  (optional)
         * @return IntegrationsApi.GetOauthUrlRequestBuilder
         */
        public IntegrationsApi.GetOauthUrlRequestBuilder zendeskSubdomain(String zendeskSubdomain) {
            this.zendeskSubdomain = zendeskSubdomain;
            return (IntegrationsApi.GetOauthUrlRequestBuilder) this;
        }
        
        /**
         * Set microsoftTenant
         * @param microsoftTenant  (optional)
         * @return IntegrationsApi.GetOauthUrlRequestBuilder
         */
        public IntegrationsApi.GetOauthUrlRequestBuilder microsoftTenant(String microsoftTenant) {
            this.microsoftTenant = microsoftTenant;
            return (IntegrationsApi.GetOauthUrlRequestBuilder) this;
        }
        
        /**
         * Set sharepointSiteName
         * @param sharepointSiteName  (optional)
         * @return IntegrationsApi.GetOauthUrlRequestBuilder
         */
        public IntegrationsApi.GetOauthUrlRequestBuilder sharepointSiteName(String sharepointSiteName) {
            this.sharepointSiteName = sharepointSiteName;
            return (IntegrationsApi.GetOauthUrlRequestBuilder) this;
        }
        
        /**
         * Set confluenceSubdomain
         * @param confluenceSubdomain  (optional)
         * @return IntegrationsApi.GetOauthUrlRequestBuilder
         */
        public IntegrationsApi.GetOauthUrlRequestBuilder confluenceSubdomain(String confluenceSubdomain) {
            this.confluenceSubdomain = confluenceSubdomain;
            return (IntegrationsApi.GetOauthUrlRequestBuilder) this;
        }
        
        /**
         * Set generateSparseVectors
         * @param generateSparseVectors  (optional, default to false)
         * @return IntegrationsApi.GetOauthUrlRequestBuilder
         */
        public IntegrationsApi.GetOauthUrlRequestBuilder generateSparseVectors(Boolean generateSparseVectors) {
            this.generateSparseVectors = generateSparseVectors;
            return (IntegrationsApi.GetOauthUrlRequestBuilder) this;
        }
        
        /**
         * Set prependFilenameToChunks
         * @param prependFilenameToChunks  (optional, default to false)
         * @return IntegrationsApi.GetOauthUrlRequestBuilder
         */
        public IntegrationsApi.GetOauthUrlRequestBuilder prependFilenameToChunks(Boolean prependFilenameToChunks) {
            this.prependFilenameToChunks = prependFilenameToChunks;
            return (IntegrationsApi.GetOauthUrlRequestBuilder) this;
        }
        
        /**
         * Set maxItemsPerChunk
         * @param maxItemsPerChunk Number of objects per chunk. For csv, tsv, xlsx, and json files only. (optional)
         * @return IntegrationsApi.GetOauthUrlRequestBuilder
         */
        public IntegrationsApi.GetOauthUrlRequestBuilder maxItemsPerChunk(Integer maxItemsPerChunk) {
            this.maxItemsPerChunk = maxItemsPerChunk;
            return (IntegrationsApi.GetOauthUrlRequestBuilder) this;
        }
        
        /**
         * Set salesforceDomain
         * @param salesforceDomain  (optional)
         * @return IntegrationsApi.GetOauthUrlRequestBuilder
         */
        public IntegrationsApi.GetOauthUrlRequestBuilder salesforceDomain(String salesforceDomain) {
            this.salesforceDomain = salesforceDomain;
            return (IntegrationsApi.GetOauthUrlRequestBuilder) this;
        }
        
        /**
         * Set syncFilesOnConnection
         * @param syncFilesOnConnection Used to specify whether Carbon should attempt to sync all your files automatically when authorization         is complete. This is only supported for a subset of connectors and will be ignored for the rest. Supported         connectors: Intercom, Zendesk, Gitbook, Confluence, Salesforce, Freshdesk (optional, default to true)
         * @return IntegrationsApi.GetOauthUrlRequestBuilder
         */
        public IntegrationsApi.GetOauthUrlRequestBuilder syncFilesOnConnection(Boolean syncFilesOnConnection) {
            this.syncFilesOnConnection = syncFilesOnConnection;
            return (IntegrationsApi.GetOauthUrlRequestBuilder) this;
        }
        
        /**
         * Set setPageAsBoundary
         * @param setPageAsBoundary  (optional, default to false)
         * @return IntegrationsApi.GetOauthUrlRequestBuilder
         */
        public IntegrationsApi.GetOauthUrlRequestBuilder setPageAsBoundary(Boolean setPageAsBoundary) {
            this.setPageAsBoundary = setPageAsBoundary;
            return (IntegrationsApi.GetOauthUrlRequestBuilder) this;
        }
        
        /**
         * Set dataSourceId
         * @param dataSourceId Used to specify a data source to sync from if you have multiple connected. It can be skipped if          you only have one data source of that type connected or are connecting a new account. (optional)
         * @return IntegrationsApi.GetOauthUrlRequestBuilder
         */
        public IntegrationsApi.GetOauthUrlRequestBuilder dataSourceId(Integer dataSourceId) {
            this.dataSourceId = dataSourceId;
            return (IntegrationsApi.GetOauthUrlRequestBuilder) this;
        }
        
        /**
         * Set connectingNewAccount
         * @param connectingNewAccount Used to connect a new data source. If not specified, we will attempt to create a sync URL         for an existing data source based on type and ID. (optional, default to false)
         * @return IntegrationsApi.GetOauthUrlRequestBuilder
         */
        public IntegrationsApi.GetOauthUrlRequestBuilder connectingNewAccount(Boolean connectingNewAccount) {
            this.connectingNewAccount = connectingNewAccount;
            return (IntegrationsApi.GetOauthUrlRequestBuilder) this;
        }
        
        /**
         * Set requestId
         * @param requestId This request id will be added to all files that get synced using the generated OAuth URL (optional, default to 77c4d6f4-3ef2-43d4-8481-476a74fd5178)
         * @return IntegrationsApi.GetOauthUrlRequestBuilder
         */
        public IntegrationsApi.GetOauthUrlRequestBuilder requestId(String requestId) {
            this.requestId = requestId;
            return (IntegrationsApi.GetOauthUrlRequestBuilder) this;
        }
        
        /**
         * Set useOcr
         * @param useOcr Enable OCR for files that support it. Supported formats: pdf (optional, default to false)
         * @return IntegrationsApi.GetOauthUrlRequestBuilder
         */
        public IntegrationsApi.GetOauthUrlRequestBuilder useOcr(Boolean useOcr) {
            this.useOcr = useOcr;
            return (IntegrationsApi.GetOauthUrlRequestBuilder) this;
        }
        
        /**
         * Set parsePdfTablesWithOcr
         * @param parsePdfTablesWithOcr  (optional, default to false)
         * @return IntegrationsApi.GetOauthUrlRequestBuilder
         */
        public IntegrationsApi.GetOauthUrlRequestBuilder parsePdfTablesWithOcr(Boolean parsePdfTablesWithOcr) {
            this.parsePdfTablesWithOcr = parsePdfTablesWithOcr;
            return (IntegrationsApi.GetOauthUrlRequestBuilder) this;
        }
        
        /**
         * Set enableFilePicker
         * @param enableFilePicker Enable integration&#39;s file picker for sources that support it. Supported sources: BOX, DROPBOX, GOOGLE_DRIVE, ONEDRIVE, SHAREPOINT (optional, default to true)
         * @return IntegrationsApi.GetOauthUrlRequestBuilder
         */
        public IntegrationsApi.GetOauthUrlRequestBuilder enableFilePicker(Boolean enableFilePicker) {
            this.enableFilePicker = enableFilePicker;
            return (IntegrationsApi.GetOauthUrlRequestBuilder) this;
        }
        
        /**
         * Set syncSourceItems
         * @param syncSourceItems Enabling this flag will fetch all available content from the source to be listed via list items endpoint (optional, default to true)
         * @return IntegrationsApi.GetOauthUrlRequestBuilder
         */
        public IntegrationsApi.GetOauthUrlRequestBuilder syncSourceItems(Boolean syncSourceItems) {
            this.syncSourceItems = syncSourceItems;
            return (IntegrationsApi.GetOauthUrlRequestBuilder) this;
        }
        
        /**
         * Set incrementalSync
         * @param incrementalSync Only sync files if they have not already been synced or if the embedding properties have changed.         This flag is currently supported by ONEDRIVE, GOOGLE_DRIVE, BOX, DROPBOX, INTERCOM, GMAIL, OUTLOOK. It will be ignored for other data sources. (optional, default to false)
         * @return IntegrationsApi.GetOauthUrlRequestBuilder
         */
        public IntegrationsApi.GetOauthUrlRequestBuilder incrementalSync(Boolean incrementalSync) {
            this.incrementalSync = incrementalSync;
            return (IntegrationsApi.GetOauthUrlRequestBuilder) this;
        }
        
        /**
         * Set fileSyncConfig
         * @param fileSyncConfig  (optional)
         * @return IntegrationsApi.GetOauthUrlRequestBuilder
         */
        public IntegrationsApi.GetOauthUrlRequestBuilder fileSyncConfig(FileSyncConfigNullable fileSyncConfig) {
            this.fileSyncConfig = fileSyncConfig;
            return (IntegrationsApi.GetOauthUrlRequestBuilder) this;
        }
        
        /**
         * Build call for getOauthUrl
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            OAuthURLRequest oauthURLRequest = buildBodyParams();
            return getOauthUrlCall(oauthURLRequest, _callback);
        }

        private OAuthURLRequest buildBodyParams() {
            OAuthURLRequest oauthURLRequest = new OAuthURLRequest();
            oauthURLRequest.tags(this.tags);
            oauthURLRequest.scope(this.scope);
            oauthURLRequest.service(this.service);
            oauthURLRequest.chunkSize(this.chunkSize);
            oauthURLRequest.chunkOverlap(this.chunkOverlap);
            oauthURLRequest.skipEmbeddingGeneration(this.skipEmbeddingGeneration);
            oauthURLRequest.embeddingModel(this.embeddingModel);
            oauthURLRequest.zendeskSubdomain(this.zendeskSubdomain);
            oauthURLRequest.microsoftTenant(this.microsoftTenant);
            oauthURLRequest.sharepointSiteName(this.sharepointSiteName);
            oauthURLRequest.confluenceSubdomain(this.confluenceSubdomain);
            oauthURLRequest.generateSparseVectors(this.generateSparseVectors);
            oauthURLRequest.prependFilenameToChunks(this.prependFilenameToChunks);
            oauthURLRequest.maxItemsPerChunk(this.maxItemsPerChunk);
            oauthURLRequest.salesforceDomain(this.salesforceDomain);
            oauthURLRequest.syncFilesOnConnection(this.syncFilesOnConnection);
            oauthURLRequest.setPageAsBoundary(this.setPageAsBoundary);
            oauthURLRequest.dataSourceId(this.dataSourceId);
            oauthURLRequest.connectingNewAccount(this.connectingNewAccount);
            oauthURLRequest.requestId(this.requestId);
            oauthURLRequest.useOcr(this.useOcr);
            oauthURLRequest.parsePdfTablesWithOcr(this.parsePdfTablesWithOcr);
            oauthURLRequest.enableFilePicker(this.enableFilePicker);
            oauthURLRequest.syncSourceItems(this.syncSourceItems);
            oauthURLRequest.incrementalSync(this.incrementalSync);
            oauthURLRequest.fileSyncConfig(this.fileSyncConfig);
            return oauthURLRequest;
        }

        /**
         * Execute getOauthUrl request
         * @return OuthURLResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public OuthURLResponse execute() throws ApiException {
            OAuthURLRequest oauthURLRequest = buildBodyParams();
            ApiResponse<OuthURLResponse> localVarResp = getOauthUrlWithHttpInfo(oauthURLRequest);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute getOauthUrl request with HTTP info returned
         * @return ApiResponse&lt;OuthURLResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<OuthURLResponse> executeWithHttpInfo() throws ApiException {
            OAuthURLRequest oauthURLRequest = buildBodyParams();
            return getOauthUrlWithHttpInfo(oauthURLRequest);
        }

        /**
         * Execute getOauthUrl request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<OuthURLResponse> _callback) throws ApiException {
            OAuthURLRequest oauthURLRequest = buildBodyParams();
            return getOauthUrlAsync(oauthURLRequest, _callback);
        }
    }

    /**
     * Get Oauth Url
     * This endpoint can be used to generate the following URLs - An OAuth URL for OAuth based connectors - A file syncing URL which skips the OAuth flow if the user already has a valid access token and takes them to the success state.
     * @param oauthURLRequest  (required)
     * @return GetOauthUrlRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
     </table>
     */
    public IntegrationsApi.GetOauthUrlRequestBuilder getOauthUrl(DataSourceType service) throws IllegalArgumentException {
        if (service == null) throw new IllegalArgumentException("\"service\" is required but got null");
        return ((IntegrationsApi) this).new GetOauthUrlRequestBuilder(service);
    }
    private okhttp3.Call listConfluencePagesCall(ListRequest listRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = listRequest;

        // create path and map variables
        String localVarPath = "/integrations/confluence/list";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "accessToken", "apiKey", "customerId" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @Deprecated
    @SuppressWarnings("rawtypes")
    private okhttp3.Call listConfluencePagesValidateBeforeCall(ListRequest listRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'listRequest' is set
        if (listRequest == null) {
            throw new ApiException("Missing the required parameter 'listRequest' when calling listConfluencePages(Async)");
        }

        return listConfluencePagesCall(listRequest, _callback);

    }


    private ApiResponse<ListResponse> listConfluencePagesWithHttpInfo(ListRequest listRequest) throws ApiException {
        okhttp3.Call localVarCall = listConfluencePagesValidateBeforeCall(listRequest, null);
        Type localVarReturnType = new TypeToken<ListResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call listConfluencePagesAsync(ListRequest listRequest, final ApiCallback<ListResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = listConfluencePagesValidateBeforeCall(listRequest, _callback);
        Type localVarReturnType = new TypeToken<ListResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public abstract class ListConfluencePagesRequestBuilderGenerated {
        final Integer dataSourceId;
        String parentId;

        public ListConfluencePagesRequestBuilderGenerated(Integer dataSourceId) {
            this.dataSourceId = dataSourceId;
        }

        /**
         * Set parentId
         * @param parentId  (optional)
         * @return IntegrationsApi.ListConfluencePagesRequestBuilder
         */
        public IntegrationsApi.ListConfluencePagesRequestBuilder parentId(String parentId) {
            this.parentId = parentId;
            return (IntegrationsApi.ListConfluencePagesRequestBuilder) this;
        }
        
        /**
         * Build call for listConfluencePages
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         * @deprecated
         */
        @Deprecated
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            ListRequest listRequest = buildBodyParams();
            return listConfluencePagesCall(listRequest, _callback);
        }

        private ListRequest buildBodyParams() {
            ListRequest listRequest = new ListRequest();
            listRequest.dataSourceId(this.dataSourceId);
            listRequest.parentId(this.parentId);
            return listRequest;
        }

        /**
         * Execute listConfluencePages request
         * @return ListResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         * @deprecated
         */
        @Deprecated
        public ListResponse execute() throws ApiException {
            ListRequest listRequest = buildBodyParams();
            ApiResponse<ListResponse> localVarResp = listConfluencePagesWithHttpInfo(listRequest);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute listConfluencePages request with HTTP info returned
         * @return ApiResponse&lt;ListResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         * @deprecated
         */
        @Deprecated
        public ApiResponse<ListResponse> executeWithHttpInfo() throws ApiException {
            ListRequest listRequest = buildBodyParams();
            return listConfluencePagesWithHttpInfo(listRequest);
        }

        /**
         * Execute listConfluencePages request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         * @deprecated
         */
        @Deprecated
        public okhttp3.Call executeAsync(final ApiCallback<ListResponse> _callback) throws ApiException {
            ListRequest listRequest = buildBodyParams();
            return listConfluencePagesAsync(listRequest, _callback);
        }
    }

    /**
     * Confluence List
     * This endpoint has been deprecated. Use /integrations/items/list instead.  To begin listing a user&#39;s Confluence pages, at least a &#x60;data_source_id&#x60; of a connected Confluence account must be specified. This base request returns a list of root pages for every space the user has access to in a Confluence instance. To traverse further down the user&#39;s page directory, additional requests to this endpoint can be made with the same &#x60;data_source_id&#x60; and with &#x60;parent_id&#x60; set to the id of page from a previous request. For convenience, the &#x60;has_children&#x60; property in each directory item in the response list will flag which pages will return non-empty lists of pages when set as the &#x60;parent_id&#x60;.
     * @param listRequest  (required)
     * @return ListConfluencePagesRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
     </table>
     * @deprecated
     */
    @Deprecated
    public IntegrationsApi.ListConfluencePagesRequestBuilder listConfluencePages(Integer dataSourceId) throws IllegalArgumentException {
        if (dataSourceId == null) throw new IllegalArgumentException("\"dataSourceId\" is required but got null");
        return ((IntegrationsApi) this).new ListConfluencePagesRequestBuilder(dataSourceId);
    }
    private okhttp3.Call listConversationsCall(String types, String cursor, Integer dataSourceId, Boolean excludeArchived, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/integrations/slack/conversations";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (types != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("types", types));
        }

        if (cursor != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("cursor", cursor));
        }

        if (dataSourceId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("data_source_id", dataSourceId));
        }

        if (excludeArchived != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("exclude_archived", excludeArchived));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "accessToken", "apiKey", "customerId" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call listConversationsValidateBeforeCall(String types, String cursor, Integer dataSourceId, Boolean excludeArchived, final ApiCallback _callback) throws ApiException {
        return listConversationsCall(types, cursor, dataSourceId, excludeArchived, _callback);

    }


    private ApiResponse<Object> listConversationsWithHttpInfo(String types, String cursor, Integer dataSourceId, Boolean excludeArchived) throws ApiException {
        okhttp3.Call localVarCall = listConversationsValidateBeforeCall(types, cursor, dataSourceId, excludeArchived, null);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call listConversationsAsync(String types, String cursor, Integer dataSourceId, Boolean excludeArchived, final ApiCallback<Object> _callback) throws ApiException {

        okhttp3.Call localVarCall = listConversationsValidateBeforeCall(types, cursor, dataSourceId, excludeArchived, _callback);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public abstract class ListConversationsRequestBuilderGenerated {
        String types;
        String cursor;
        Integer dataSourceId;
        Boolean excludeArchived;

        public ListConversationsRequestBuilderGenerated() {
        }

        /**
         * Set types
         * @param types  (optional, default to public_channel)
         * @return IntegrationsApi.ListConversationsRequestBuilder
         */
        public IntegrationsApi.ListConversationsRequestBuilder types(String types) {
            this.types = types;
            return (IntegrationsApi.ListConversationsRequestBuilder) this;
        }
        
        /**
         * Set cursor
         * @param cursor  (optional)
         * @return IntegrationsApi.ListConversationsRequestBuilder
         */
        public IntegrationsApi.ListConversationsRequestBuilder cursor(String cursor) {
            this.cursor = cursor;
            return (IntegrationsApi.ListConversationsRequestBuilder) this;
        }
        
        /**
         * Set dataSourceId
         * @param dataSourceId  (optional)
         * @return IntegrationsApi.ListConversationsRequestBuilder
         */
        public IntegrationsApi.ListConversationsRequestBuilder dataSourceId(Integer dataSourceId) {
            this.dataSourceId = dataSourceId;
            return (IntegrationsApi.ListConversationsRequestBuilder) this;
        }
        
        /**
         * Set excludeArchived
         * @param excludeArchived  (optional, default to true)
         * @return IntegrationsApi.ListConversationsRequestBuilder
         */
        public IntegrationsApi.ListConversationsRequestBuilder excludeArchived(Boolean excludeArchived) {
            this.excludeArchived = excludeArchived;
            return (IntegrationsApi.ListConversationsRequestBuilder) this;
        }
        
        /**
         * Build call for listConversations
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return listConversationsCall(types, cursor, dataSourceId, excludeArchived, _callback);
        }


        /**
         * Execute listConversations request
         * @return Object
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public Object execute() throws ApiException {
            ApiResponse<Object> localVarResp = listConversationsWithHttpInfo(types, cursor, dataSourceId, excludeArchived);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute listConversations request with HTTP info returned
         * @return ApiResponse&lt;Object&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Object> executeWithHttpInfo() throws ApiException {
            return listConversationsWithHttpInfo(types, cursor, dataSourceId, excludeArchived);
        }

        /**
         * Execute listConversations request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Object> _callback) throws ApiException {
            return listConversationsAsync(types, cursor, dataSourceId, excludeArchived, _callback);
        }
    }

    /**
     * Slack List Conversations
     * List all of your public and private channels, DMs, and Group DMs. The ID from response  can be used as a filter to sync messages to Carbon    types: Comma separated list of types. Available types are im (DMs), mpim (group DMs), public_channel, and private_channel. Defaults to public_channel.     cursor: Used for pagination. If next_cursor is returned in response, you need to pass it as the cursor in the next request     data_source_id: Data source needs to be specified if you have linked multiple slack accounts   exclude_archived: Should archived conversations be excluded, defaults to true
     * @return ListConversationsRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
     </table>
     */
    public IntegrationsApi.ListConversationsRequestBuilder listConversations() throws IllegalArgumentException {
        return ((IntegrationsApi) this).new ListConversationsRequestBuilder();
    }
    private okhttp3.Call listDataSourceItemsCall(ListDataSourceItemsRequest listDataSourceItemsRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = listDataSourceItemsRequest;

        // create path and map variables
        String localVarPath = "/integrations/items/list";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "accessToken", "apiKey", "customerId" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call listDataSourceItemsValidateBeforeCall(ListDataSourceItemsRequest listDataSourceItemsRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'listDataSourceItemsRequest' is set
        if (listDataSourceItemsRequest == null) {
            throw new ApiException("Missing the required parameter 'listDataSourceItemsRequest' when calling listDataSourceItems(Async)");
        }

        return listDataSourceItemsCall(listDataSourceItemsRequest, _callback);

    }


    private ApiResponse<ListDataSourceItemsResponse> listDataSourceItemsWithHttpInfo(ListDataSourceItemsRequest listDataSourceItemsRequest) throws ApiException {
        okhttp3.Call localVarCall = listDataSourceItemsValidateBeforeCall(listDataSourceItemsRequest, null);
        Type localVarReturnType = new TypeToken<ListDataSourceItemsResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call listDataSourceItemsAsync(ListDataSourceItemsRequest listDataSourceItemsRequest, final ApiCallback<ListDataSourceItemsResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = listDataSourceItemsValidateBeforeCall(listDataSourceItemsRequest, _callback);
        Type localVarReturnType = new TypeToken<ListDataSourceItemsResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public abstract class ListDataSourceItemsRequestBuilderGenerated {
        final Integer dataSourceId;
        String parentId;
        ListItemsFiltersNullable filters;
        Pagination pagination;
        ExternalSourceItemsOrderBy orderBy;
        OrderDirV2 orderDir;

        public ListDataSourceItemsRequestBuilderGenerated(Integer dataSourceId) {
            this.dataSourceId = dataSourceId;
        }

        /**
         * Set parentId
         * @param parentId  (optional)
         * @return IntegrationsApi.ListDataSourceItemsRequestBuilder
         */
        public IntegrationsApi.ListDataSourceItemsRequestBuilder parentId(String parentId) {
            this.parentId = parentId;
            return (IntegrationsApi.ListDataSourceItemsRequestBuilder) this;
        }
        
        /**
         * Set filters
         * @param filters  (optional)
         * @return IntegrationsApi.ListDataSourceItemsRequestBuilder
         */
        public IntegrationsApi.ListDataSourceItemsRequestBuilder filters(ListItemsFiltersNullable filters) {
            this.filters = filters;
            return (IntegrationsApi.ListDataSourceItemsRequestBuilder) this;
        }
        
        /**
         * Set pagination
         * @param pagination  (optional)
         * @return IntegrationsApi.ListDataSourceItemsRequestBuilder
         */
        public IntegrationsApi.ListDataSourceItemsRequestBuilder pagination(Pagination pagination) {
            this.pagination = pagination;
            return (IntegrationsApi.ListDataSourceItemsRequestBuilder) this;
        }
        
        /**
         * Set orderBy
         * @param orderBy  (optional)
         * @return IntegrationsApi.ListDataSourceItemsRequestBuilder
         */
        public IntegrationsApi.ListDataSourceItemsRequestBuilder orderBy(ExternalSourceItemsOrderBy orderBy) {
            this.orderBy = orderBy;
            return (IntegrationsApi.ListDataSourceItemsRequestBuilder) this;
        }
        
        /**
         * Set orderDir
         * @param orderDir  (optional)
         * @return IntegrationsApi.ListDataSourceItemsRequestBuilder
         */
        public IntegrationsApi.ListDataSourceItemsRequestBuilder orderDir(OrderDirV2 orderDir) {
            this.orderDir = orderDir;
            return (IntegrationsApi.ListDataSourceItemsRequestBuilder) this;
        }
        
        /**
         * Build call for listDataSourceItems
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            ListDataSourceItemsRequest listDataSourceItemsRequest = buildBodyParams();
            return listDataSourceItemsCall(listDataSourceItemsRequest, _callback);
        }

        private ListDataSourceItemsRequest buildBodyParams() {
            ListDataSourceItemsRequest listDataSourceItemsRequest = new ListDataSourceItemsRequest();
            listDataSourceItemsRequest.dataSourceId(this.dataSourceId);
            listDataSourceItemsRequest.parentId(this.parentId);
            listDataSourceItemsRequest.filters(this.filters);
            listDataSourceItemsRequest.pagination(this.pagination);
            listDataSourceItemsRequest.orderBy(this.orderBy);
            listDataSourceItemsRequest.orderDir(this.orderDir);
            return listDataSourceItemsRequest;
        }

        /**
         * Execute listDataSourceItems request
         * @return ListDataSourceItemsResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public ListDataSourceItemsResponse execute() throws ApiException {
            ListDataSourceItemsRequest listDataSourceItemsRequest = buildBodyParams();
            ApiResponse<ListDataSourceItemsResponse> localVarResp = listDataSourceItemsWithHttpInfo(listDataSourceItemsRequest);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute listDataSourceItems request with HTTP info returned
         * @return ApiResponse&lt;ListDataSourceItemsResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<ListDataSourceItemsResponse> executeWithHttpInfo() throws ApiException {
            ListDataSourceItemsRequest listDataSourceItemsRequest = buildBodyParams();
            return listDataSourceItemsWithHttpInfo(listDataSourceItemsRequest);
        }

        /**
         * Execute listDataSourceItems request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<ListDataSourceItemsResponse> _callback) throws ApiException {
            ListDataSourceItemsRequest listDataSourceItemsRequest = buildBodyParams();
            return listDataSourceItemsAsync(listDataSourceItemsRequest, _callback);
        }
    }

    /**
     * List Data Source Items
     * 
     * @param listDataSourceItemsRequest  (required)
     * @return ListDataSourceItemsRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
     </table>
     */
    public IntegrationsApi.ListDataSourceItemsRequestBuilder listDataSourceItems(Integer dataSourceId) throws IllegalArgumentException {
        if (dataSourceId == null) throw new IllegalArgumentException("\"dataSourceId\" is required but got null");
        return ((IntegrationsApi) this).new ListDataSourceItemsRequestBuilder(dataSourceId);
    }
    private okhttp3.Call listFoldersCall(Integer dataSourceId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/integrations/outlook/user_folders";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (dataSourceId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("data_source_id", dataSourceId));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "accessToken", "apiKey", "customerId" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call listFoldersValidateBeforeCall(Integer dataSourceId, final ApiCallback _callback) throws ApiException {
        return listFoldersCall(dataSourceId, _callback);

    }


    private ApiResponse<Object> listFoldersWithHttpInfo(Integer dataSourceId) throws ApiException {
        okhttp3.Call localVarCall = listFoldersValidateBeforeCall(dataSourceId, null);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call listFoldersAsync(Integer dataSourceId, final ApiCallback<Object> _callback) throws ApiException {

        okhttp3.Call localVarCall = listFoldersValidateBeforeCall(dataSourceId, _callback);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public abstract class ListFoldersRequestBuilderGenerated {
        Integer dataSourceId;

        public ListFoldersRequestBuilderGenerated() {
        }

        /**
         * Set dataSourceId
         * @param dataSourceId  (optional)
         * @return IntegrationsApi.ListFoldersRequestBuilder
         */
        public IntegrationsApi.ListFoldersRequestBuilder dataSourceId(Integer dataSourceId) {
            this.dataSourceId = dataSourceId;
            return (IntegrationsApi.ListFoldersRequestBuilder) this;
        }
        
        /**
         * Build call for listFolders
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return listFoldersCall(dataSourceId, _callback);
        }


        /**
         * Execute listFolders request
         * @return Object
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public Object execute() throws ApiException {
            ApiResponse<Object> localVarResp = listFoldersWithHttpInfo(dataSourceId);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute listFolders request with HTTP info returned
         * @return ApiResponse&lt;Object&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Object> executeWithHttpInfo() throws ApiException {
            return listFoldersWithHttpInfo(dataSourceId);
        }

        /**
         * Execute listFolders request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Object> _callback) throws ApiException {
            return listFoldersAsync(dataSourceId, _callback);
        }
    }

    /**
     * Outlook Folders
     * After connecting your Outlook account, you can use this endpoint to list all of your folders on outlook. This includes  both system folders like \&quot;inbox\&quot; and user created folders.
     * @return ListFoldersRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
     </table>
     */
    public IntegrationsApi.ListFoldersRequestBuilder listFolders() throws IllegalArgumentException {
        return ((IntegrationsApi) this).new ListFoldersRequestBuilder();
    }
    private okhttp3.Call listGitbookSpacesCall(Integer dataSourceId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/integrations/gitbook/spaces";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (dataSourceId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("data_source_id", dataSourceId));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "accessToken", "apiKey", "customerId" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call listGitbookSpacesValidateBeforeCall(Integer dataSourceId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'dataSourceId' is set
        if (dataSourceId == null) {
            throw new ApiException("Missing the required parameter 'dataSourceId' when calling listGitbookSpaces(Async)");
        }

        return listGitbookSpacesCall(dataSourceId, _callback);

    }


    private ApiResponse<Object> listGitbookSpacesWithHttpInfo(Integer dataSourceId) throws ApiException {
        okhttp3.Call localVarCall = listGitbookSpacesValidateBeforeCall(dataSourceId, null);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call listGitbookSpacesAsync(Integer dataSourceId, final ApiCallback<Object> _callback) throws ApiException {

        okhttp3.Call localVarCall = listGitbookSpacesValidateBeforeCall(dataSourceId, _callback);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public abstract class ListGitbookSpacesRequestBuilderGenerated {
        final Integer dataSourceId;

        public ListGitbookSpacesRequestBuilderGenerated(Integer dataSourceId) {
            this.dataSourceId = dataSourceId;
        }

        /**
         * Build call for listGitbookSpaces
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return listGitbookSpacesCall(dataSourceId, _callback);
        }


        /**
         * Execute listGitbookSpaces request
         * @return Object
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public Object execute() throws ApiException {
            ApiResponse<Object> localVarResp = listGitbookSpacesWithHttpInfo(dataSourceId);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute listGitbookSpaces request with HTTP info returned
         * @return ApiResponse&lt;Object&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Object> executeWithHttpInfo() throws ApiException {
            return listGitbookSpacesWithHttpInfo(dataSourceId);
        }

        /**
         * Execute listGitbookSpaces request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Object> _callback) throws ApiException {
            return listGitbookSpacesAsync(dataSourceId, _callback);
        }
    }

    /**
     * Gitbook Spaces
     * After connecting your Gitbook account, you can use this endpoint to list all of your spaces under current organization.
     * @param dataSourceId  (required)
     * @return ListGitbookSpacesRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
     </table>
     */
    public IntegrationsApi.ListGitbookSpacesRequestBuilder listGitbookSpaces(Integer dataSourceId) throws IllegalArgumentException {
        if (dataSourceId == null) throw new IllegalArgumentException("\"dataSourceId\" is required but got null");
        return ((IntegrationsApi) this).new ListGitbookSpacesRequestBuilder(dataSourceId);
    }
    private okhttp3.Call listLabelsCall(Integer dataSourceId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/integrations/gmail/user_labels";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (dataSourceId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("data_source_id", dataSourceId));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "accessToken", "apiKey", "customerId" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call listLabelsValidateBeforeCall(Integer dataSourceId, final ApiCallback _callback) throws ApiException {
        return listLabelsCall(dataSourceId, _callback);

    }


    private ApiResponse<Object> listLabelsWithHttpInfo(Integer dataSourceId) throws ApiException {
        okhttp3.Call localVarCall = listLabelsValidateBeforeCall(dataSourceId, null);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call listLabelsAsync(Integer dataSourceId, final ApiCallback<Object> _callback) throws ApiException {

        okhttp3.Call localVarCall = listLabelsValidateBeforeCall(dataSourceId, _callback);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public abstract class ListLabelsRequestBuilderGenerated {
        Integer dataSourceId;

        public ListLabelsRequestBuilderGenerated() {
        }

        /**
         * Set dataSourceId
         * @param dataSourceId  (optional)
         * @return IntegrationsApi.ListLabelsRequestBuilder
         */
        public IntegrationsApi.ListLabelsRequestBuilder dataSourceId(Integer dataSourceId) {
            this.dataSourceId = dataSourceId;
            return (IntegrationsApi.ListLabelsRequestBuilder) this;
        }
        
        /**
         * Build call for listLabels
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return listLabelsCall(dataSourceId, _callback);
        }


        /**
         * Execute listLabels request
         * @return Object
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public Object execute() throws ApiException {
            ApiResponse<Object> localVarResp = listLabelsWithHttpInfo(dataSourceId);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute listLabels request with HTTP info returned
         * @return ApiResponse&lt;Object&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Object> executeWithHttpInfo() throws ApiException {
            return listLabelsWithHttpInfo(dataSourceId);
        }

        /**
         * Execute listLabels request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Object> _callback) throws ApiException {
            return listLabelsAsync(dataSourceId, _callback);
        }
    }

    /**
     * Gmail Labels
     * After connecting your Gmail account, you can use this endpoint to list all of your labels. User created labels will have the type \&quot;user\&quot; and Gmail&#39;s default labels will have the type \&quot;system\&quot;
     * @return ListLabelsRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
     </table>
     */
    public IntegrationsApi.ListLabelsRequestBuilder listLabels() throws IllegalArgumentException {
        return ((IntegrationsApi) this).new ListLabelsRequestBuilder();
    }
    private okhttp3.Call listOutlookCategoriesCall(Integer dataSourceId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/integrations/outlook/user_categories";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (dataSourceId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("data_source_id", dataSourceId));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "accessToken", "apiKey", "customerId" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call listOutlookCategoriesValidateBeforeCall(Integer dataSourceId, final ApiCallback _callback) throws ApiException {
        return listOutlookCategoriesCall(dataSourceId, _callback);

    }


    private ApiResponse<Object> listOutlookCategoriesWithHttpInfo(Integer dataSourceId) throws ApiException {
        okhttp3.Call localVarCall = listOutlookCategoriesValidateBeforeCall(dataSourceId, null);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call listOutlookCategoriesAsync(Integer dataSourceId, final ApiCallback<Object> _callback) throws ApiException {

        okhttp3.Call localVarCall = listOutlookCategoriesValidateBeforeCall(dataSourceId, _callback);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public abstract class ListOutlookCategoriesRequestBuilderGenerated {
        Integer dataSourceId;

        public ListOutlookCategoriesRequestBuilderGenerated() {
        }

        /**
         * Set dataSourceId
         * @param dataSourceId  (optional)
         * @return IntegrationsApi.ListOutlookCategoriesRequestBuilder
         */
        public IntegrationsApi.ListOutlookCategoriesRequestBuilder dataSourceId(Integer dataSourceId) {
            this.dataSourceId = dataSourceId;
            return (IntegrationsApi.ListOutlookCategoriesRequestBuilder) this;
        }
        
        /**
         * Build call for listOutlookCategories
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return listOutlookCategoriesCall(dataSourceId, _callback);
        }


        /**
         * Execute listOutlookCategories request
         * @return Object
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public Object execute() throws ApiException {
            ApiResponse<Object> localVarResp = listOutlookCategoriesWithHttpInfo(dataSourceId);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute listOutlookCategories request with HTTP info returned
         * @return ApiResponse&lt;Object&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Object> executeWithHttpInfo() throws ApiException {
            return listOutlookCategoriesWithHttpInfo(dataSourceId);
        }

        /**
         * Execute listOutlookCategories request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Object> _callback) throws ApiException {
            return listOutlookCategoriesAsync(dataSourceId, _callback);
        }
    }

    /**
     * Outlook Categories
     * After connecting your Outlook account, you can use this endpoint to list all of your categories on outlook. We currently support listing up to 250 categories.
     * @return ListOutlookCategoriesRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
     </table>
     */
    public IntegrationsApi.ListOutlookCategoriesRequestBuilder listOutlookCategories() throws IllegalArgumentException {
        return ((IntegrationsApi) this).new ListOutlookCategoriesRequestBuilder();
    }
    private okhttp3.Call listReposCall(Integer perPage, Integer page, Integer dataSourceId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/integrations/github/repos";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (perPage != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("per_page", perPage));
        }

        if (page != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page", page));
        }

        if (dataSourceId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("data_source_id", dataSourceId));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "accessToken", "apiKey", "customerId" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call listReposValidateBeforeCall(Integer perPage, Integer page, Integer dataSourceId, final ApiCallback _callback) throws ApiException {
        return listReposCall(perPage, page, dataSourceId, _callback);

    }


    private ApiResponse<Object> listReposWithHttpInfo(Integer perPage, Integer page, Integer dataSourceId) throws ApiException {
        okhttp3.Call localVarCall = listReposValidateBeforeCall(perPage, page, dataSourceId, null);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call listReposAsync(Integer perPage, Integer page, Integer dataSourceId, final ApiCallback<Object> _callback) throws ApiException {

        okhttp3.Call localVarCall = listReposValidateBeforeCall(perPage, page, dataSourceId, _callback);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public abstract class ListReposRequestBuilderGenerated {
        Integer perPage;
        Integer page;
        Integer dataSourceId;

        public ListReposRequestBuilderGenerated() {
        }

        /**
         * Set perPage
         * @param perPage  (optional, default to 30)
         * @return IntegrationsApi.ListReposRequestBuilder
         */
        public IntegrationsApi.ListReposRequestBuilder perPage(Integer perPage) {
            this.perPage = perPage;
            return (IntegrationsApi.ListReposRequestBuilder) this;
        }
        
        /**
         * Set page
         * @param page  (optional, default to 1)
         * @return IntegrationsApi.ListReposRequestBuilder
         */
        public IntegrationsApi.ListReposRequestBuilder page(Integer page) {
            this.page = page;
            return (IntegrationsApi.ListReposRequestBuilder) this;
        }
        
        /**
         * Set dataSourceId
         * @param dataSourceId  (optional)
         * @return IntegrationsApi.ListReposRequestBuilder
         */
        public IntegrationsApi.ListReposRequestBuilder dataSourceId(Integer dataSourceId) {
            this.dataSourceId = dataSourceId;
            return (IntegrationsApi.ListReposRequestBuilder) this;
        }
        
        /**
         * Build call for listRepos
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return listReposCall(perPage, page, dataSourceId, _callback);
        }


        /**
         * Execute listRepos request
         * @return Object
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public Object execute() throws ApiException {
            ApiResponse<Object> localVarResp = listReposWithHttpInfo(perPage, page, dataSourceId);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute listRepos request with HTTP info returned
         * @return ApiResponse&lt;Object&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Object> executeWithHttpInfo() throws ApiException {
            return listReposWithHttpInfo(perPage, page, dataSourceId);
        }

        /**
         * Execute listRepos request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Object> _callback) throws ApiException {
            return listReposAsync(perPage, page, dataSourceId, _callback);
        }
    }

    /**
     * Github List Repos
     * Once you have connected your GitHub account, you can use this endpoint to list the      repositories your account has access to. You can use a data source ID or username to fetch from a specific account.
     * @return ListReposRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
     </table>
     */
    public IntegrationsApi.ListReposRequestBuilder listRepos() throws IllegalArgumentException {
        return ((IntegrationsApi) this).new ListReposRequestBuilder();
    }
    private okhttp3.Call syncConfluenceCall(SyncFilesRequest syncFilesRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = syncFilesRequest;

        // create path and map variables
        String localVarPath = "/integrations/confluence/sync";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "accessToken", "apiKey", "customerId" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @Deprecated
    @SuppressWarnings("rawtypes")
    private okhttp3.Call syncConfluenceValidateBeforeCall(SyncFilesRequest syncFilesRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'syncFilesRequest' is set
        if (syncFilesRequest == null) {
            throw new ApiException("Missing the required parameter 'syncFilesRequest' when calling syncConfluence(Async)");
        }

        return syncConfluenceCall(syncFilesRequest, _callback);

    }


    private ApiResponse<GenericSuccessResponse> syncConfluenceWithHttpInfo(SyncFilesRequest syncFilesRequest) throws ApiException {
        okhttp3.Call localVarCall = syncConfluenceValidateBeforeCall(syncFilesRequest, null);
        Type localVarReturnType = new TypeToken<GenericSuccessResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call syncConfluenceAsync(SyncFilesRequest syncFilesRequest, final ApiCallback<GenericSuccessResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = syncConfluenceValidateBeforeCall(syncFilesRequest, _callback);
        Type localVarReturnType = new TypeToken<GenericSuccessResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public abstract class SyncConfluenceRequestBuilderGenerated {
        final Integer dataSourceId;
        final List<Object> ids;
        Object tags;
        Integer chunkSize;
        Integer chunkOverlap;
        Boolean skipEmbeddingGeneration;
        EmbeddingGeneratorsNullable embeddingModel;
        Boolean generateSparseVectors;
        Boolean prependFilenameToChunks;
        Integer maxItemsPerChunk;
        Boolean setPageAsBoundary;
        String requestId;
        Boolean useOcr;
        Boolean parsePdfTablesWithOcr;
        Boolean incrementalSync;
        FileSyncConfigNullable fileSyncConfig;

        public SyncConfluenceRequestBuilderGenerated(Integer dataSourceId, List<Object> ids) {
            this.dataSourceId = dataSourceId;
            this.ids = ids;
        }

        /**
         * Set tags
         * @param tags  (optional)
         * @return IntegrationsApi.SyncConfluenceRequestBuilder
         */
        public IntegrationsApi.SyncConfluenceRequestBuilder tags(Object tags) {
            this.tags = tags;
            return (IntegrationsApi.SyncConfluenceRequestBuilder) this;
        }
        
        /**
         * Set chunkSize
         * @param chunkSize  (optional, default to 1500)
         * @return IntegrationsApi.SyncConfluenceRequestBuilder
         */
        public IntegrationsApi.SyncConfluenceRequestBuilder chunkSize(Integer chunkSize) {
            this.chunkSize = chunkSize;
            return (IntegrationsApi.SyncConfluenceRequestBuilder) this;
        }
        
        /**
         * Set chunkOverlap
         * @param chunkOverlap  (optional, default to 20)
         * @return IntegrationsApi.SyncConfluenceRequestBuilder
         */
        public IntegrationsApi.SyncConfluenceRequestBuilder chunkOverlap(Integer chunkOverlap) {
            this.chunkOverlap = chunkOverlap;
            return (IntegrationsApi.SyncConfluenceRequestBuilder) this;
        }
        
        /**
         * Set skipEmbeddingGeneration
         * @param skipEmbeddingGeneration  (optional, default to false)
         * @return IntegrationsApi.SyncConfluenceRequestBuilder
         */
        public IntegrationsApi.SyncConfluenceRequestBuilder skipEmbeddingGeneration(Boolean skipEmbeddingGeneration) {
            this.skipEmbeddingGeneration = skipEmbeddingGeneration;
            return (IntegrationsApi.SyncConfluenceRequestBuilder) this;
        }
        
        /**
         * Set embeddingModel
         * @param embeddingModel  (optional, default to OPENAI)
         * @return IntegrationsApi.SyncConfluenceRequestBuilder
         */
        public IntegrationsApi.SyncConfluenceRequestBuilder embeddingModel(EmbeddingGeneratorsNullable embeddingModel) {
            this.embeddingModel = embeddingModel;
            return (IntegrationsApi.SyncConfluenceRequestBuilder) this;
        }
        
        /**
         * Set generateSparseVectors
         * @param generateSparseVectors  (optional, default to false)
         * @return IntegrationsApi.SyncConfluenceRequestBuilder
         */
        public IntegrationsApi.SyncConfluenceRequestBuilder generateSparseVectors(Boolean generateSparseVectors) {
            this.generateSparseVectors = generateSparseVectors;
            return (IntegrationsApi.SyncConfluenceRequestBuilder) this;
        }
        
        /**
         * Set prependFilenameToChunks
         * @param prependFilenameToChunks  (optional, default to false)
         * @return IntegrationsApi.SyncConfluenceRequestBuilder
         */
        public IntegrationsApi.SyncConfluenceRequestBuilder prependFilenameToChunks(Boolean prependFilenameToChunks) {
            this.prependFilenameToChunks = prependFilenameToChunks;
            return (IntegrationsApi.SyncConfluenceRequestBuilder) this;
        }
        
        /**
         * Set maxItemsPerChunk
         * @param maxItemsPerChunk Number of objects per chunk. For csv, tsv, xlsx, and json files only. (optional)
         * @return IntegrationsApi.SyncConfluenceRequestBuilder
         */
        public IntegrationsApi.SyncConfluenceRequestBuilder maxItemsPerChunk(Integer maxItemsPerChunk) {
            this.maxItemsPerChunk = maxItemsPerChunk;
            return (IntegrationsApi.SyncConfluenceRequestBuilder) this;
        }
        
        /**
         * Set setPageAsBoundary
         * @param setPageAsBoundary  (optional, default to false)
         * @return IntegrationsApi.SyncConfluenceRequestBuilder
         */
        public IntegrationsApi.SyncConfluenceRequestBuilder setPageAsBoundary(Boolean setPageAsBoundary) {
            this.setPageAsBoundary = setPageAsBoundary;
            return (IntegrationsApi.SyncConfluenceRequestBuilder) this;
        }
        
        /**
         * Set requestId
         * @param requestId  (optional, default to 0a2f743b-fe89-4193-86c3-87ca6d2ffc43)
         * @return IntegrationsApi.SyncConfluenceRequestBuilder
         */
        public IntegrationsApi.SyncConfluenceRequestBuilder requestId(String requestId) {
            this.requestId = requestId;
            return (IntegrationsApi.SyncConfluenceRequestBuilder) this;
        }
        
        /**
         * Set useOcr
         * @param useOcr  (optional, default to false)
         * @return IntegrationsApi.SyncConfluenceRequestBuilder
         */
        public IntegrationsApi.SyncConfluenceRequestBuilder useOcr(Boolean useOcr) {
            this.useOcr = useOcr;
            return (IntegrationsApi.SyncConfluenceRequestBuilder) this;
        }
        
        /**
         * Set parsePdfTablesWithOcr
         * @param parsePdfTablesWithOcr  (optional, default to false)
         * @return IntegrationsApi.SyncConfluenceRequestBuilder
         */
        public IntegrationsApi.SyncConfluenceRequestBuilder parsePdfTablesWithOcr(Boolean parsePdfTablesWithOcr) {
            this.parsePdfTablesWithOcr = parsePdfTablesWithOcr;
            return (IntegrationsApi.SyncConfluenceRequestBuilder) this;
        }
        
        /**
         * Set incrementalSync
         * @param incrementalSync Only sync files if they have not already been synced or if the embedding properties have changed.         This flag is currently supported by ONEDRIVE, GOOGLE_DRIVE, BOX, DROPBOX, INTERCOM, GMAIL, OUTLOOK. It will be ignored for other data sources. (optional, default to false)
         * @return IntegrationsApi.SyncConfluenceRequestBuilder
         */
        public IntegrationsApi.SyncConfluenceRequestBuilder incrementalSync(Boolean incrementalSync) {
            this.incrementalSync = incrementalSync;
            return (IntegrationsApi.SyncConfluenceRequestBuilder) this;
        }
        
        /**
         * Set fileSyncConfig
         * @param fileSyncConfig  (optional)
         * @return IntegrationsApi.SyncConfluenceRequestBuilder
         */
        public IntegrationsApi.SyncConfluenceRequestBuilder fileSyncConfig(FileSyncConfigNullable fileSyncConfig) {
            this.fileSyncConfig = fileSyncConfig;
            return (IntegrationsApi.SyncConfluenceRequestBuilder) this;
        }
        
        /**
         * Build call for syncConfluence
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         * @deprecated
         */
        @Deprecated
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            SyncFilesRequest syncFilesRequest = buildBodyParams();
            return syncConfluenceCall(syncFilesRequest, _callback);
        }

        private SyncFilesRequest buildBodyParams() {
            SyncFilesRequest syncFilesRequest = new SyncFilesRequest();
            syncFilesRequest.tags(this.tags);
            syncFilesRequest.dataSourceId(this.dataSourceId);
            syncFilesRequest.ids(this.ids);
            syncFilesRequest.chunkSize(this.chunkSize);
            syncFilesRequest.chunkOverlap(this.chunkOverlap);
            syncFilesRequest.skipEmbeddingGeneration(this.skipEmbeddingGeneration);
            syncFilesRequest.embeddingModel(this.embeddingModel);
            syncFilesRequest.generateSparseVectors(this.generateSparseVectors);
            syncFilesRequest.prependFilenameToChunks(this.prependFilenameToChunks);
            syncFilesRequest.maxItemsPerChunk(this.maxItemsPerChunk);
            syncFilesRequest.setPageAsBoundary(this.setPageAsBoundary);
            syncFilesRequest.requestId(this.requestId);
            syncFilesRequest.useOcr(this.useOcr);
            syncFilesRequest.parsePdfTablesWithOcr(this.parsePdfTablesWithOcr);
            syncFilesRequest.incrementalSync(this.incrementalSync);
            syncFilesRequest.fileSyncConfig(this.fileSyncConfig);
            return syncFilesRequest;
        }

        /**
         * Execute syncConfluence request
         * @return GenericSuccessResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         * @deprecated
         */
        @Deprecated
        public GenericSuccessResponse execute() throws ApiException {
            SyncFilesRequest syncFilesRequest = buildBodyParams();
            ApiResponse<GenericSuccessResponse> localVarResp = syncConfluenceWithHttpInfo(syncFilesRequest);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute syncConfluence request with HTTP info returned
         * @return ApiResponse&lt;GenericSuccessResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         * @deprecated
         */
        @Deprecated
        public ApiResponse<GenericSuccessResponse> executeWithHttpInfo() throws ApiException {
            SyncFilesRequest syncFilesRequest = buildBodyParams();
            return syncConfluenceWithHttpInfo(syncFilesRequest);
        }

        /**
         * Execute syncConfluence request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         * @deprecated
         */
        @Deprecated
        public okhttp3.Call executeAsync(final ApiCallback<GenericSuccessResponse> _callback) throws ApiException {
            SyncFilesRequest syncFilesRequest = buildBodyParams();
            return syncConfluenceAsync(syncFilesRequest, _callback);
        }
    }

    /**
     * Confluence Sync
     * This endpoint has been deprecated. Use /integrations/files/sync instead.  After listing pages in a user&#39;s Confluence account, the set of selected page &#x60;ids&#x60; and the connected account&#39;s &#x60;data_source_id&#x60; can be passed into this endpoint to sync them into Carbon. Additional parameters listed below can be used to associate data to the selected pages or alter the behavior of the sync.
     * @param syncFilesRequest  (required)
     * @return SyncConfluenceRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
     </table>
     * @deprecated
     */
    @Deprecated
    public IntegrationsApi.SyncConfluenceRequestBuilder syncConfluence(Integer dataSourceId, List<Object> ids) throws IllegalArgumentException {
        if (dataSourceId == null) throw new IllegalArgumentException("\"dataSourceId\" is required but got null");
        if (ids == null) throw new IllegalArgumentException("\"ids\" is required but got null");
        return ((IntegrationsApi) this).new SyncConfluenceRequestBuilder(dataSourceId, ids);
    }
    private okhttp3.Call syncDataSourceItemsCall(SyncDirectoryRequest syncDirectoryRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = syncDirectoryRequest;

        // create path and map variables
        String localVarPath = "/integrations/items/sync";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "accessToken", "apiKey", "customerId" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call syncDataSourceItemsValidateBeforeCall(SyncDirectoryRequest syncDirectoryRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'syncDirectoryRequest' is set
        if (syncDirectoryRequest == null) {
            throw new ApiException("Missing the required parameter 'syncDirectoryRequest' when calling syncDataSourceItems(Async)");
        }

        return syncDataSourceItemsCall(syncDirectoryRequest, _callback);

    }


    private ApiResponse<OrganizationUserDataSourceAPI> syncDataSourceItemsWithHttpInfo(SyncDirectoryRequest syncDirectoryRequest) throws ApiException {
        okhttp3.Call localVarCall = syncDataSourceItemsValidateBeforeCall(syncDirectoryRequest, null);
        Type localVarReturnType = new TypeToken<OrganizationUserDataSourceAPI>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call syncDataSourceItemsAsync(SyncDirectoryRequest syncDirectoryRequest, final ApiCallback<OrganizationUserDataSourceAPI> _callback) throws ApiException {

        okhttp3.Call localVarCall = syncDataSourceItemsValidateBeforeCall(syncDirectoryRequest, _callback);
        Type localVarReturnType = new TypeToken<OrganizationUserDataSourceAPI>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public abstract class SyncDataSourceItemsRequestBuilderGenerated {
        final Integer dataSourceId;

        public SyncDataSourceItemsRequestBuilderGenerated(Integer dataSourceId) {
            this.dataSourceId = dataSourceId;
        }

        /**
         * Build call for syncDataSourceItems
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            SyncDirectoryRequest syncDirectoryRequest = buildBodyParams();
            return syncDataSourceItemsCall(syncDirectoryRequest, _callback);
        }

        private SyncDirectoryRequest buildBodyParams() {
            SyncDirectoryRequest syncDirectoryRequest = new SyncDirectoryRequest();
            syncDirectoryRequest.dataSourceId(this.dataSourceId);
            return syncDirectoryRequest;
        }

        /**
         * Execute syncDataSourceItems request
         * @return OrganizationUserDataSourceAPI
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public OrganizationUserDataSourceAPI execute() throws ApiException {
            SyncDirectoryRequest syncDirectoryRequest = buildBodyParams();
            ApiResponse<OrganizationUserDataSourceAPI> localVarResp = syncDataSourceItemsWithHttpInfo(syncDirectoryRequest);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute syncDataSourceItems request with HTTP info returned
         * @return ApiResponse&lt;OrganizationUserDataSourceAPI&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<OrganizationUserDataSourceAPI> executeWithHttpInfo() throws ApiException {
            SyncDirectoryRequest syncDirectoryRequest = buildBodyParams();
            return syncDataSourceItemsWithHttpInfo(syncDirectoryRequest);
        }

        /**
         * Execute syncDataSourceItems request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<OrganizationUserDataSourceAPI> _callback) throws ApiException {
            SyncDirectoryRequest syncDirectoryRequest = buildBodyParams();
            return syncDataSourceItemsAsync(syncDirectoryRequest, _callback);
        }
    }

    /**
     * Sync Data Source Items
     * 
     * @param syncDirectoryRequest  (required)
     * @return SyncDataSourceItemsRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
     </table>
     */
    public IntegrationsApi.SyncDataSourceItemsRequestBuilder syncDataSourceItems(Integer dataSourceId) throws IllegalArgumentException {
        if (dataSourceId == null) throw new IllegalArgumentException("\"dataSourceId\" is required but got null");
        return ((IntegrationsApi) this).new SyncDataSourceItemsRequestBuilder(dataSourceId);
    }
    private okhttp3.Call syncFilesCall(SyncFilesRequest syncFilesRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = syncFilesRequest;

        // create path and map variables
        String localVarPath = "/integrations/files/sync";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "accessToken", "apiKey", "customerId" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call syncFilesValidateBeforeCall(SyncFilesRequest syncFilesRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'syncFilesRequest' is set
        if (syncFilesRequest == null) {
            throw new ApiException("Missing the required parameter 'syncFilesRequest' when calling syncFiles(Async)");
        }

        return syncFilesCall(syncFilesRequest, _callback);

    }


    private ApiResponse<GenericSuccessResponse> syncFilesWithHttpInfo(SyncFilesRequest syncFilesRequest) throws ApiException {
        okhttp3.Call localVarCall = syncFilesValidateBeforeCall(syncFilesRequest, null);
        Type localVarReturnType = new TypeToken<GenericSuccessResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call syncFilesAsync(SyncFilesRequest syncFilesRequest, final ApiCallback<GenericSuccessResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = syncFilesValidateBeforeCall(syncFilesRequest, _callback);
        Type localVarReturnType = new TypeToken<GenericSuccessResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public abstract class SyncFilesRequestBuilderGenerated {
        final Integer dataSourceId;
        final List<Object> ids;
        Object tags;
        Integer chunkSize;
        Integer chunkOverlap;
        Boolean skipEmbeddingGeneration;
        EmbeddingGeneratorsNullable embeddingModel;
        Boolean generateSparseVectors;
        Boolean prependFilenameToChunks;
        Integer maxItemsPerChunk;
        Boolean setPageAsBoundary;
        String requestId;
        Boolean useOcr;
        Boolean parsePdfTablesWithOcr;
        Boolean incrementalSync;
        FileSyncConfigNullable fileSyncConfig;

        public SyncFilesRequestBuilderGenerated(Integer dataSourceId, List<Object> ids) {
            this.dataSourceId = dataSourceId;
            this.ids = ids;
        }

        /**
         * Set tags
         * @param tags  (optional)
         * @return IntegrationsApi.SyncFilesRequestBuilder
         */
        public IntegrationsApi.SyncFilesRequestBuilder tags(Object tags) {
            this.tags = tags;
            return (IntegrationsApi.SyncFilesRequestBuilder) this;
        }
        
        /**
         * Set chunkSize
         * @param chunkSize  (optional, default to 1500)
         * @return IntegrationsApi.SyncFilesRequestBuilder
         */
        public IntegrationsApi.SyncFilesRequestBuilder chunkSize(Integer chunkSize) {
            this.chunkSize = chunkSize;
            return (IntegrationsApi.SyncFilesRequestBuilder) this;
        }
        
        /**
         * Set chunkOverlap
         * @param chunkOverlap  (optional, default to 20)
         * @return IntegrationsApi.SyncFilesRequestBuilder
         */
        public IntegrationsApi.SyncFilesRequestBuilder chunkOverlap(Integer chunkOverlap) {
            this.chunkOverlap = chunkOverlap;
            return (IntegrationsApi.SyncFilesRequestBuilder) this;
        }
        
        /**
         * Set skipEmbeddingGeneration
         * @param skipEmbeddingGeneration  (optional, default to false)
         * @return IntegrationsApi.SyncFilesRequestBuilder
         */
        public IntegrationsApi.SyncFilesRequestBuilder skipEmbeddingGeneration(Boolean skipEmbeddingGeneration) {
            this.skipEmbeddingGeneration = skipEmbeddingGeneration;
            return (IntegrationsApi.SyncFilesRequestBuilder) this;
        }
        
        /**
         * Set embeddingModel
         * @param embeddingModel  (optional, default to OPENAI)
         * @return IntegrationsApi.SyncFilesRequestBuilder
         */
        public IntegrationsApi.SyncFilesRequestBuilder embeddingModel(EmbeddingGeneratorsNullable embeddingModel) {
            this.embeddingModel = embeddingModel;
            return (IntegrationsApi.SyncFilesRequestBuilder) this;
        }
        
        /**
         * Set generateSparseVectors
         * @param generateSparseVectors  (optional, default to false)
         * @return IntegrationsApi.SyncFilesRequestBuilder
         */
        public IntegrationsApi.SyncFilesRequestBuilder generateSparseVectors(Boolean generateSparseVectors) {
            this.generateSparseVectors = generateSparseVectors;
            return (IntegrationsApi.SyncFilesRequestBuilder) this;
        }
        
        /**
         * Set prependFilenameToChunks
         * @param prependFilenameToChunks  (optional, default to false)
         * @return IntegrationsApi.SyncFilesRequestBuilder
         */
        public IntegrationsApi.SyncFilesRequestBuilder prependFilenameToChunks(Boolean prependFilenameToChunks) {
            this.prependFilenameToChunks = prependFilenameToChunks;
            return (IntegrationsApi.SyncFilesRequestBuilder) this;
        }
        
        /**
         * Set maxItemsPerChunk
         * @param maxItemsPerChunk Number of objects per chunk. For csv, tsv, xlsx, and json files only. (optional)
         * @return IntegrationsApi.SyncFilesRequestBuilder
         */
        public IntegrationsApi.SyncFilesRequestBuilder maxItemsPerChunk(Integer maxItemsPerChunk) {
            this.maxItemsPerChunk = maxItemsPerChunk;
            return (IntegrationsApi.SyncFilesRequestBuilder) this;
        }
        
        /**
         * Set setPageAsBoundary
         * @param setPageAsBoundary  (optional, default to false)
         * @return IntegrationsApi.SyncFilesRequestBuilder
         */
        public IntegrationsApi.SyncFilesRequestBuilder setPageAsBoundary(Boolean setPageAsBoundary) {
            this.setPageAsBoundary = setPageAsBoundary;
            return (IntegrationsApi.SyncFilesRequestBuilder) this;
        }
        
        /**
         * Set requestId
         * @param requestId  (optional, default to 0a2f743b-fe89-4193-86c3-87ca6d2ffc43)
         * @return IntegrationsApi.SyncFilesRequestBuilder
         */
        public IntegrationsApi.SyncFilesRequestBuilder requestId(String requestId) {
            this.requestId = requestId;
            return (IntegrationsApi.SyncFilesRequestBuilder) this;
        }
        
        /**
         * Set useOcr
         * @param useOcr  (optional, default to false)
         * @return IntegrationsApi.SyncFilesRequestBuilder
         */
        public IntegrationsApi.SyncFilesRequestBuilder useOcr(Boolean useOcr) {
            this.useOcr = useOcr;
            return (IntegrationsApi.SyncFilesRequestBuilder) this;
        }
        
        /**
         * Set parsePdfTablesWithOcr
         * @param parsePdfTablesWithOcr  (optional, default to false)
         * @return IntegrationsApi.SyncFilesRequestBuilder
         */
        public IntegrationsApi.SyncFilesRequestBuilder parsePdfTablesWithOcr(Boolean parsePdfTablesWithOcr) {
            this.parsePdfTablesWithOcr = parsePdfTablesWithOcr;
            return (IntegrationsApi.SyncFilesRequestBuilder) this;
        }
        
        /**
         * Set incrementalSync
         * @param incrementalSync Only sync files if they have not already been synced or if the embedding properties have changed.         This flag is currently supported by ONEDRIVE, GOOGLE_DRIVE, BOX, DROPBOX, INTERCOM, GMAIL, OUTLOOK. It will be ignored for other data sources. (optional, default to false)
         * @return IntegrationsApi.SyncFilesRequestBuilder
         */
        public IntegrationsApi.SyncFilesRequestBuilder incrementalSync(Boolean incrementalSync) {
            this.incrementalSync = incrementalSync;
            return (IntegrationsApi.SyncFilesRequestBuilder) this;
        }
        
        /**
         * Set fileSyncConfig
         * @param fileSyncConfig  (optional)
         * @return IntegrationsApi.SyncFilesRequestBuilder
         */
        public IntegrationsApi.SyncFilesRequestBuilder fileSyncConfig(FileSyncConfigNullable fileSyncConfig) {
            this.fileSyncConfig = fileSyncConfig;
            return (IntegrationsApi.SyncFilesRequestBuilder) this;
        }
        
        /**
         * Build call for syncFiles
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            SyncFilesRequest syncFilesRequest = buildBodyParams();
            return syncFilesCall(syncFilesRequest, _callback);
        }

        private SyncFilesRequest buildBodyParams() {
            SyncFilesRequest syncFilesRequest = new SyncFilesRequest();
            syncFilesRequest.tags(this.tags);
            syncFilesRequest.dataSourceId(this.dataSourceId);
            syncFilesRequest.ids(this.ids);
            syncFilesRequest.chunkSize(this.chunkSize);
            syncFilesRequest.chunkOverlap(this.chunkOverlap);
            syncFilesRequest.skipEmbeddingGeneration(this.skipEmbeddingGeneration);
            syncFilesRequest.embeddingModel(this.embeddingModel);
            syncFilesRequest.generateSparseVectors(this.generateSparseVectors);
            syncFilesRequest.prependFilenameToChunks(this.prependFilenameToChunks);
            syncFilesRequest.maxItemsPerChunk(this.maxItemsPerChunk);
            syncFilesRequest.setPageAsBoundary(this.setPageAsBoundary);
            syncFilesRequest.requestId(this.requestId);
            syncFilesRequest.useOcr(this.useOcr);
            syncFilesRequest.parsePdfTablesWithOcr(this.parsePdfTablesWithOcr);
            syncFilesRequest.incrementalSync(this.incrementalSync);
            syncFilesRequest.fileSyncConfig(this.fileSyncConfig);
            return syncFilesRequest;
        }

        /**
         * Execute syncFiles request
         * @return GenericSuccessResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public GenericSuccessResponse execute() throws ApiException {
            SyncFilesRequest syncFilesRequest = buildBodyParams();
            ApiResponse<GenericSuccessResponse> localVarResp = syncFilesWithHttpInfo(syncFilesRequest);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute syncFiles request with HTTP info returned
         * @return ApiResponse&lt;GenericSuccessResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<GenericSuccessResponse> executeWithHttpInfo() throws ApiException {
            SyncFilesRequest syncFilesRequest = buildBodyParams();
            return syncFilesWithHttpInfo(syncFilesRequest);
        }

        /**
         * Execute syncFiles request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<GenericSuccessResponse> _callback) throws ApiException {
            SyncFilesRequest syncFilesRequest = buildBodyParams();
            return syncFilesAsync(syncFilesRequest, _callback);
        }
    }

    /**
     * Sync Files
     * After listing files and folders via /integrations/items/sync and integrations/items/list, use the selected items&#39; external ids  as the ids in this endpoint to sync them into Carbon. Sharepoint items take an additional parameter root_id, which identifies the drive the file or folder is in and is stored in root_external_id. That additional paramter is optional and excluding it will tell the sync to assume the item is stored in the default Documents drive.
     * @param syncFilesRequest  (required)
     * @return SyncFilesRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
     </table>
     */
    public IntegrationsApi.SyncFilesRequestBuilder syncFiles(Integer dataSourceId, List<Object> ids) throws IllegalArgumentException {
        if (dataSourceId == null) throw new IllegalArgumentException("\"dataSourceId\" is required but got null");
        if (ids == null) throw new IllegalArgumentException("\"ids\" is required but got null");
        return ((IntegrationsApi) this).new SyncFilesRequestBuilder(dataSourceId, ids);
    }
    private okhttp3.Call syncGitHubCall(GithubConnectRequest githubConnectRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = githubConnectRequest;

        // create path and map variables
        String localVarPath = "/integrations/github";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "accessToken", "apiKey", "customerId" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call syncGitHubValidateBeforeCall(GithubConnectRequest githubConnectRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'githubConnectRequest' is set
        if (githubConnectRequest == null) {
            throw new ApiException("Missing the required parameter 'githubConnectRequest' when calling syncGitHub(Async)");
        }

        return syncGitHubCall(githubConnectRequest, _callback);

    }


    private ApiResponse<GenericSuccessResponse> syncGitHubWithHttpInfo(GithubConnectRequest githubConnectRequest) throws ApiException {
        okhttp3.Call localVarCall = syncGitHubValidateBeforeCall(githubConnectRequest, null);
        Type localVarReturnType = new TypeToken<GenericSuccessResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call syncGitHubAsync(GithubConnectRequest githubConnectRequest, final ApiCallback<GenericSuccessResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = syncGitHubValidateBeforeCall(githubConnectRequest, _callback);
        Type localVarReturnType = new TypeToken<GenericSuccessResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public abstract class SyncGitHubRequestBuilderGenerated {
        final String username;
        final String accessToken;
        Boolean syncSourceItems;

        public SyncGitHubRequestBuilderGenerated(String username, String accessToken) {
            this.username = username;
            this.accessToken = accessToken;
        }

        /**
         * Set syncSourceItems
         * @param syncSourceItems Enabling this flag will fetch all available content from the source to be listed via list items endpoint (optional, default to false)
         * @return IntegrationsApi.SyncGitHubRequestBuilder
         */
        public IntegrationsApi.SyncGitHubRequestBuilder syncSourceItems(Boolean syncSourceItems) {
            this.syncSourceItems = syncSourceItems;
            return (IntegrationsApi.SyncGitHubRequestBuilder) this;
        }
        
        /**
         * Build call for syncGitHub
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            GithubConnectRequest githubConnectRequest = buildBodyParams();
            return syncGitHubCall(githubConnectRequest, _callback);
        }

        private GithubConnectRequest buildBodyParams() {
            GithubConnectRequest githubConnectRequest = new GithubConnectRequest();
            githubConnectRequest.username(this.username);
            githubConnectRequest.accessToken(this.accessToken);
            githubConnectRequest.syncSourceItems(this.syncSourceItems);
            return githubConnectRequest;
        }

        /**
         * Execute syncGitHub request
         * @return GenericSuccessResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public GenericSuccessResponse execute() throws ApiException {
            GithubConnectRequest githubConnectRequest = buildBodyParams();
            ApiResponse<GenericSuccessResponse> localVarResp = syncGitHubWithHttpInfo(githubConnectRequest);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute syncGitHub request with HTTP info returned
         * @return ApiResponse&lt;GenericSuccessResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<GenericSuccessResponse> executeWithHttpInfo() throws ApiException {
            GithubConnectRequest githubConnectRequest = buildBodyParams();
            return syncGitHubWithHttpInfo(githubConnectRequest);
        }

        /**
         * Execute syncGitHub request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<GenericSuccessResponse> _callback) throws ApiException {
            GithubConnectRequest githubConnectRequest = buildBodyParams();
            return syncGitHubAsync(githubConnectRequest, _callback);
        }
    }

    /**
     * Github Connect
     * Refer this article to obtain an access token https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/managing-your-personal-access-tokens. Make sure that your access token has the permission to read content from your desired repos. Note that if your access token expires you will need to manually update it through this endpoint.
     * @param githubConnectRequest  (required)
     * @return SyncGitHubRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
     </table>
     */
    public IntegrationsApi.SyncGitHubRequestBuilder syncGitHub(String username, String accessToken) throws IllegalArgumentException {
        if (username == null) throw new IllegalArgumentException("\"username\" is required but got null");
            

        if (accessToken == null) throw new IllegalArgumentException("\"accessToken\" is required but got null");
            

        return ((IntegrationsApi) this).new SyncGitHubRequestBuilder(username, accessToken);
    }
    private okhttp3.Call syncGitbookCall(GitbookSyncRequest gitbookSyncRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = gitbookSyncRequest;

        // create path and map variables
        String localVarPath = "/integrations/gitbook/sync";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "accessToken", "apiKey", "customerId" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call syncGitbookValidateBeforeCall(GitbookSyncRequest gitbookSyncRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'gitbookSyncRequest' is set
        if (gitbookSyncRequest == null) {
            throw new ApiException("Missing the required parameter 'gitbookSyncRequest' when calling syncGitbook(Async)");
        }

        return syncGitbookCall(gitbookSyncRequest, _callback);

    }


    private ApiResponse<Object> syncGitbookWithHttpInfo(GitbookSyncRequest gitbookSyncRequest) throws ApiException {
        okhttp3.Call localVarCall = syncGitbookValidateBeforeCall(gitbookSyncRequest, null);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call syncGitbookAsync(GitbookSyncRequest gitbookSyncRequest, final ApiCallback<Object> _callback) throws ApiException {

        okhttp3.Call localVarCall = syncGitbookValidateBeforeCall(gitbookSyncRequest, _callback);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public abstract class SyncGitbookRequestBuilderGenerated {
        final List<String> spaceIds;
        final Integer dataSourceId;
        Object tags;
        Integer chunkSize;
        Integer chunkOverlap;
        Boolean skipEmbeddingGeneration;
        EmbeddingGenerators embeddingModel;
        Boolean generateSparseVectors;
        Boolean prependFilenameToChunks;
        String requestId;

        public SyncGitbookRequestBuilderGenerated(List<String> spaceIds, Integer dataSourceId) {
            this.spaceIds = spaceIds;
            this.dataSourceId = dataSourceId;
        }

        /**
         * Set tags
         * @param tags  (optional)
         * @return IntegrationsApi.SyncGitbookRequestBuilder
         */
        public IntegrationsApi.SyncGitbookRequestBuilder tags(Object tags) {
            this.tags = tags;
            return (IntegrationsApi.SyncGitbookRequestBuilder) this;
        }
        
        /**
         * Set chunkSize
         * @param chunkSize  (optional, default to 1500)
         * @return IntegrationsApi.SyncGitbookRequestBuilder
         */
        public IntegrationsApi.SyncGitbookRequestBuilder chunkSize(Integer chunkSize) {
            this.chunkSize = chunkSize;
            return (IntegrationsApi.SyncGitbookRequestBuilder) this;
        }
        
        /**
         * Set chunkOverlap
         * @param chunkOverlap  (optional, default to 20)
         * @return IntegrationsApi.SyncGitbookRequestBuilder
         */
        public IntegrationsApi.SyncGitbookRequestBuilder chunkOverlap(Integer chunkOverlap) {
            this.chunkOverlap = chunkOverlap;
            return (IntegrationsApi.SyncGitbookRequestBuilder) this;
        }
        
        /**
         * Set skipEmbeddingGeneration
         * @param skipEmbeddingGeneration  (optional, default to false)
         * @return IntegrationsApi.SyncGitbookRequestBuilder
         */
        public IntegrationsApi.SyncGitbookRequestBuilder skipEmbeddingGeneration(Boolean skipEmbeddingGeneration) {
            this.skipEmbeddingGeneration = skipEmbeddingGeneration;
            return (IntegrationsApi.SyncGitbookRequestBuilder) this;
        }
        
        /**
         * Set embeddingModel
         * @param embeddingModel  (optional)
         * @return IntegrationsApi.SyncGitbookRequestBuilder
         */
        public IntegrationsApi.SyncGitbookRequestBuilder embeddingModel(EmbeddingGenerators embeddingModel) {
            this.embeddingModel = embeddingModel;
            return (IntegrationsApi.SyncGitbookRequestBuilder) this;
        }
        
        /**
         * Set generateSparseVectors
         * @param generateSparseVectors  (optional, default to false)
         * @return IntegrationsApi.SyncGitbookRequestBuilder
         */
        public IntegrationsApi.SyncGitbookRequestBuilder generateSparseVectors(Boolean generateSparseVectors) {
            this.generateSparseVectors = generateSparseVectors;
            return (IntegrationsApi.SyncGitbookRequestBuilder) this;
        }
        
        /**
         * Set prependFilenameToChunks
         * @param prependFilenameToChunks  (optional, default to false)
         * @return IntegrationsApi.SyncGitbookRequestBuilder
         */
        public IntegrationsApi.SyncGitbookRequestBuilder prependFilenameToChunks(Boolean prependFilenameToChunks) {
            this.prependFilenameToChunks = prependFilenameToChunks;
            return (IntegrationsApi.SyncGitbookRequestBuilder) this;
        }
        
        /**
         * Set requestId
         * @param requestId  (optional)
         * @return IntegrationsApi.SyncGitbookRequestBuilder
         */
        public IntegrationsApi.SyncGitbookRequestBuilder requestId(String requestId) {
            this.requestId = requestId;
            return (IntegrationsApi.SyncGitbookRequestBuilder) this;
        }
        
        /**
         * Build call for syncGitbook
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            GitbookSyncRequest gitbookSyncRequest = buildBodyParams();
            return syncGitbookCall(gitbookSyncRequest, _callback);
        }

        private GitbookSyncRequest buildBodyParams() {
            GitbookSyncRequest gitbookSyncRequest = new GitbookSyncRequest();
            gitbookSyncRequest.tags(this.tags);
            gitbookSyncRequest.spaceIds(this.spaceIds);
            gitbookSyncRequest.dataSourceId(this.dataSourceId);
            gitbookSyncRequest.chunkSize(this.chunkSize);
            gitbookSyncRequest.chunkOverlap(this.chunkOverlap);
            gitbookSyncRequest.skipEmbeddingGeneration(this.skipEmbeddingGeneration);
            gitbookSyncRequest.embeddingModel(this.embeddingModel);
            gitbookSyncRequest.generateSparseVectors(this.generateSparseVectors);
            gitbookSyncRequest.prependFilenameToChunks(this.prependFilenameToChunks);
            gitbookSyncRequest.requestId(this.requestId);
            return gitbookSyncRequest;
        }

        /**
         * Execute syncGitbook request
         * @return Object
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public Object execute() throws ApiException {
            GitbookSyncRequest gitbookSyncRequest = buildBodyParams();
            ApiResponse<Object> localVarResp = syncGitbookWithHttpInfo(gitbookSyncRequest);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute syncGitbook request with HTTP info returned
         * @return ApiResponse&lt;Object&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Object> executeWithHttpInfo() throws ApiException {
            GitbookSyncRequest gitbookSyncRequest = buildBodyParams();
            return syncGitbookWithHttpInfo(gitbookSyncRequest);
        }

        /**
         * Execute syncGitbook request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Object> _callback) throws ApiException {
            GitbookSyncRequest gitbookSyncRequest = buildBodyParams();
            return syncGitbookAsync(gitbookSyncRequest, _callback);
        }
    }

    /**
     * Gitbook Sync
     * You can sync upto 20 Gitbook spaces at a time using this endpoint. Additional parameters below can be used to associate  data with the synced pages or modify the sync behavior.
     * @param gitbookSyncRequest  (required)
     * @return SyncGitbookRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
     </table>
     */
    public IntegrationsApi.SyncGitbookRequestBuilder syncGitbook(List<String> spaceIds, Integer dataSourceId) throws IllegalArgumentException {
        if (spaceIds == null) throw new IllegalArgumentException("\"spaceIds\" is required but got null");
        if (dataSourceId == null) throw new IllegalArgumentException("\"dataSourceId\" is required but got null");
        return ((IntegrationsApi) this).new SyncGitbookRequestBuilder(spaceIds, dataSourceId);
    }
    private okhttp3.Call syncGmailCall(GmailSyncInput gmailSyncInput, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = gmailSyncInput;

        // create path and map variables
        String localVarPath = "/integrations/gmail/sync";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "accessToken", "apiKey", "customerId" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call syncGmailValidateBeforeCall(GmailSyncInput gmailSyncInput, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'gmailSyncInput' is set
        if (gmailSyncInput == null) {
            throw new ApiException("Missing the required parameter 'gmailSyncInput' when calling syncGmail(Async)");
        }

        return syncGmailCall(gmailSyncInput, _callback);

    }


    private ApiResponse<GenericSuccessResponse> syncGmailWithHttpInfo(GmailSyncInput gmailSyncInput) throws ApiException {
        okhttp3.Call localVarCall = syncGmailValidateBeforeCall(gmailSyncInput, null);
        Type localVarReturnType = new TypeToken<GenericSuccessResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call syncGmailAsync(GmailSyncInput gmailSyncInput, final ApiCallback<GenericSuccessResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = syncGmailValidateBeforeCall(gmailSyncInput, _callback);
        Type localVarReturnType = new TypeToken<GenericSuccessResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public abstract class SyncGmailRequestBuilderGenerated {
        final Object filters;
        Object tags;
        Integer chunkSize;
        Integer chunkOverlap;
        Boolean skipEmbeddingGeneration;
        EmbeddingGenerators embeddingModel;
        Boolean generateSparseVectors;
        Boolean prependFilenameToChunks;
        Integer dataSourceId;
        String requestId;
        Boolean syncAttachments;
        FileSyncConfigNullable fileSyncConfig;
        Boolean incrementalSync;

        public SyncGmailRequestBuilderGenerated(Object filters) {
            this.filters = filters;
        }

        /**
         * Set tags
         * @param tags  (optional)
         * @return IntegrationsApi.SyncGmailRequestBuilder
         */
        public IntegrationsApi.SyncGmailRequestBuilder tags(Object tags) {
            this.tags = tags;
            return (IntegrationsApi.SyncGmailRequestBuilder) this;
        }
        
        /**
         * Set chunkSize
         * @param chunkSize  (optional, default to 1500)
         * @return IntegrationsApi.SyncGmailRequestBuilder
         */
        public IntegrationsApi.SyncGmailRequestBuilder chunkSize(Integer chunkSize) {
            this.chunkSize = chunkSize;
            return (IntegrationsApi.SyncGmailRequestBuilder) this;
        }
        
        /**
         * Set chunkOverlap
         * @param chunkOverlap  (optional, default to 20)
         * @return IntegrationsApi.SyncGmailRequestBuilder
         */
        public IntegrationsApi.SyncGmailRequestBuilder chunkOverlap(Integer chunkOverlap) {
            this.chunkOverlap = chunkOverlap;
            return (IntegrationsApi.SyncGmailRequestBuilder) this;
        }
        
        /**
         * Set skipEmbeddingGeneration
         * @param skipEmbeddingGeneration  (optional, default to false)
         * @return IntegrationsApi.SyncGmailRequestBuilder
         */
        public IntegrationsApi.SyncGmailRequestBuilder skipEmbeddingGeneration(Boolean skipEmbeddingGeneration) {
            this.skipEmbeddingGeneration = skipEmbeddingGeneration;
            return (IntegrationsApi.SyncGmailRequestBuilder) this;
        }
        
        /**
         * Set embeddingModel
         * @param embeddingModel  (optional)
         * @return IntegrationsApi.SyncGmailRequestBuilder
         */
        public IntegrationsApi.SyncGmailRequestBuilder embeddingModel(EmbeddingGenerators embeddingModel) {
            this.embeddingModel = embeddingModel;
            return (IntegrationsApi.SyncGmailRequestBuilder) this;
        }
        
        /**
         * Set generateSparseVectors
         * @param generateSparseVectors  (optional, default to false)
         * @return IntegrationsApi.SyncGmailRequestBuilder
         */
        public IntegrationsApi.SyncGmailRequestBuilder generateSparseVectors(Boolean generateSparseVectors) {
            this.generateSparseVectors = generateSparseVectors;
            return (IntegrationsApi.SyncGmailRequestBuilder) this;
        }
        
        /**
         * Set prependFilenameToChunks
         * @param prependFilenameToChunks  (optional, default to false)
         * @return IntegrationsApi.SyncGmailRequestBuilder
         */
        public IntegrationsApi.SyncGmailRequestBuilder prependFilenameToChunks(Boolean prependFilenameToChunks) {
            this.prependFilenameToChunks = prependFilenameToChunks;
            return (IntegrationsApi.SyncGmailRequestBuilder) this;
        }
        
        /**
         * Set dataSourceId
         * @param dataSourceId  (optional)
         * @return IntegrationsApi.SyncGmailRequestBuilder
         */
        public IntegrationsApi.SyncGmailRequestBuilder dataSourceId(Integer dataSourceId) {
            this.dataSourceId = dataSourceId;
            return (IntegrationsApi.SyncGmailRequestBuilder) this;
        }
        
        /**
         * Set requestId
         * @param requestId  (optional)
         * @return IntegrationsApi.SyncGmailRequestBuilder
         */
        public IntegrationsApi.SyncGmailRequestBuilder requestId(String requestId) {
            this.requestId = requestId;
            return (IntegrationsApi.SyncGmailRequestBuilder) this;
        }
        
        /**
         * Set syncAttachments
         * @param syncAttachments  (optional, default to false)
         * @return IntegrationsApi.SyncGmailRequestBuilder
         */
        public IntegrationsApi.SyncGmailRequestBuilder syncAttachments(Boolean syncAttachments) {
            this.syncAttachments = syncAttachments;
            return (IntegrationsApi.SyncGmailRequestBuilder) this;
        }
        
        /**
         * Set fileSyncConfig
         * @param fileSyncConfig  (optional)
         * @return IntegrationsApi.SyncGmailRequestBuilder
         */
        public IntegrationsApi.SyncGmailRequestBuilder fileSyncConfig(FileSyncConfigNullable fileSyncConfig) {
            this.fileSyncConfig = fileSyncConfig;
            return (IntegrationsApi.SyncGmailRequestBuilder) this;
        }
        
        /**
         * Set incrementalSync
         * @param incrementalSync  (optional, default to false)
         * @return IntegrationsApi.SyncGmailRequestBuilder
         */
        public IntegrationsApi.SyncGmailRequestBuilder incrementalSync(Boolean incrementalSync) {
            this.incrementalSync = incrementalSync;
            return (IntegrationsApi.SyncGmailRequestBuilder) this;
        }
        
        /**
         * Build call for syncGmail
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            GmailSyncInput gmailSyncInput = buildBodyParams();
            return syncGmailCall(gmailSyncInput, _callback);
        }

        private GmailSyncInput buildBodyParams() {
            GmailSyncInput gmailSyncInput = new GmailSyncInput();
            gmailSyncInput.tags(this.tags);
            gmailSyncInput.filters(this.filters);
            gmailSyncInput.chunkSize(this.chunkSize);
            gmailSyncInput.chunkOverlap(this.chunkOverlap);
            gmailSyncInput.skipEmbeddingGeneration(this.skipEmbeddingGeneration);
            gmailSyncInput.embeddingModel(this.embeddingModel);
            gmailSyncInput.generateSparseVectors(this.generateSparseVectors);
            gmailSyncInput.prependFilenameToChunks(this.prependFilenameToChunks);
            gmailSyncInput.dataSourceId(this.dataSourceId);
            gmailSyncInput.requestId(this.requestId);
            gmailSyncInput.syncAttachments(this.syncAttachments);
            gmailSyncInput.fileSyncConfig(this.fileSyncConfig);
            gmailSyncInput.incrementalSync(this.incrementalSync);
            return gmailSyncInput;
        }

        /**
         * Execute syncGmail request
         * @return GenericSuccessResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public GenericSuccessResponse execute() throws ApiException {
            GmailSyncInput gmailSyncInput = buildBodyParams();
            ApiResponse<GenericSuccessResponse> localVarResp = syncGmailWithHttpInfo(gmailSyncInput);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute syncGmail request with HTTP info returned
         * @return ApiResponse&lt;GenericSuccessResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<GenericSuccessResponse> executeWithHttpInfo() throws ApiException {
            GmailSyncInput gmailSyncInput = buildBodyParams();
            return syncGmailWithHttpInfo(gmailSyncInput);
        }

        /**
         * Execute syncGmail request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<GenericSuccessResponse> _callback) throws ApiException {
            GmailSyncInput gmailSyncInput = buildBodyParams();
            return syncGmailAsync(gmailSyncInput, _callback);
        }
    }

    /**
     * Gmail Sync
     * Once you have successfully connected your gmail account, you can choose which emails to sync with us using the filters parameter. Filters is a JSON object with key value pairs. It also supports AND and OR operations. For now, we support a limited set of keys listed below.  &lt;b&gt;label&lt;/b&gt;: Inbuilt Gmail labels, for example \&quot;Important\&quot; or a custom label you created.   &lt;b&gt;after&lt;/b&gt; or &lt;b&gt;before&lt;/b&gt;: A date in YYYY/mm/dd format (example 2023/12/31). Gets emails after/before a certain date. You can also use them in combination to get emails from a certain period.   &lt;b&gt;is&lt;/b&gt;: Can have the following values - starred, important, snoozed, and unread   &lt;b&gt;from&lt;/b&gt;: Email address of the sender   &lt;b&gt;to&lt;/b&gt;: Email address of the recipient    Using keys or values outside of the specified values can lead to unexpected behaviour.  An example of a basic query with filters can be &#x60;&#x60;&#x60;json {     \&quot;filters\&quot;: {             \&quot;key\&quot;: \&quot;label\&quot;,             \&quot;value\&quot;: \&quot;Test\&quot;         } } &#x60;&#x60;&#x60; Which will list all emails that have the label \&quot;Test\&quot;.  You can use AND and OR operation in the following way: &#x60;&#x60;&#x60;json {     \&quot;filters\&quot;: {         \&quot;AND\&quot;: [             {                 \&quot;key\&quot;: \&quot;after\&quot;,                 \&quot;value\&quot;: \&quot;2024/01/07\&quot;             },             {                 \&quot;OR\&quot;: [                     {                         \&quot;key\&quot;: \&quot;label\&quot;,                         \&quot;value\&quot;: \&quot;Personal\&quot;                     },                     {                         \&quot;key\&quot;: \&quot;is\&quot;,                         \&quot;value\&quot;: \&quot;starred\&quot;                     }                 ]             }         ]     } } &#x60;&#x60;&#x60; This will return emails after 7th of Jan that are either starred or have the label \&quot;Personal\&quot;.  Note that this is the highest level of nesting we support, i.e. you can&#39;t add more AND/OR filters within the OR filter in the above example.
     * @param gmailSyncInput  (required)
     * @return SyncGmailRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
     </table>
     */
    public IntegrationsApi.SyncGmailRequestBuilder syncGmail(Object filters) throws IllegalArgumentException {
        if (filters == null) throw new IllegalArgumentException("\"filters\" is required but got null");
        return ((IntegrationsApi) this).new SyncGmailRequestBuilder(filters);
    }
    private okhttp3.Call syncOutlookCall(OutlookSyncInput outlookSyncInput, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = outlookSyncInput;

        // create path and map variables
        String localVarPath = "/integrations/outlook/sync";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "accessToken", "apiKey", "customerId" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call syncOutlookValidateBeforeCall(OutlookSyncInput outlookSyncInput, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'outlookSyncInput' is set
        if (outlookSyncInput == null) {
            throw new ApiException("Missing the required parameter 'outlookSyncInput' when calling syncOutlook(Async)");
        }

        return syncOutlookCall(outlookSyncInput, _callback);

    }


    private ApiResponse<GenericSuccessResponse> syncOutlookWithHttpInfo(OutlookSyncInput outlookSyncInput) throws ApiException {
        okhttp3.Call localVarCall = syncOutlookValidateBeforeCall(outlookSyncInput, null);
        Type localVarReturnType = new TypeToken<GenericSuccessResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call syncOutlookAsync(OutlookSyncInput outlookSyncInput, final ApiCallback<GenericSuccessResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = syncOutlookValidateBeforeCall(outlookSyncInput, _callback);
        Type localVarReturnType = new TypeToken<GenericSuccessResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public abstract class SyncOutlookRequestBuilderGenerated {
        final Object filters;
        Object tags;
        String folder;
        Integer chunkSize;
        Integer chunkOverlap;
        Boolean skipEmbeddingGeneration;
        EmbeddingGenerators embeddingModel;
        Boolean generateSparseVectors;
        Boolean prependFilenameToChunks;
        Integer dataSourceId;
        String requestId;
        Boolean syncAttachments;
        FileSyncConfigNullable fileSyncConfig;
        Boolean incrementalSync;

        public SyncOutlookRequestBuilderGenerated(Object filters) {
            this.filters = filters;
        }

        /**
         * Set tags
         * @param tags  (optional)
         * @return IntegrationsApi.SyncOutlookRequestBuilder
         */
        public IntegrationsApi.SyncOutlookRequestBuilder tags(Object tags) {
            this.tags = tags;
            return (IntegrationsApi.SyncOutlookRequestBuilder) this;
        }
        
        /**
         * Set folder
         * @param folder  (optional, default to Inbox)
         * @return IntegrationsApi.SyncOutlookRequestBuilder
         */
        public IntegrationsApi.SyncOutlookRequestBuilder folder(String folder) {
            this.folder = folder;
            return (IntegrationsApi.SyncOutlookRequestBuilder) this;
        }
        
        /**
         * Set chunkSize
         * @param chunkSize  (optional, default to 1500)
         * @return IntegrationsApi.SyncOutlookRequestBuilder
         */
        public IntegrationsApi.SyncOutlookRequestBuilder chunkSize(Integer chunkSize) {
            this.chunkSize = chunkSize;
            return (IntegrationsApi.SyncOutlookRequestBuilder) this;
        }
        
        /**
         * Set chunkOverlap
         * @param chunkOverlap  (optional, default to 20)
         * @return IntegrationsApi.SyncOutlookRequestBuilder
         */
        public IntegrationsApi.SyncOutlookRequestBuilder chunkOverlap(Integer chunkOverlap) {
            this.chunkOverlap = chunkOverlap;
            return (IntegrationsApi.SyncOutlookRequestBuilder) this;
        }
        
        /**
         * Set skipEmbeddingGeneration
         * @param skipEmbeddingGeneration  (optional, default to false)
         * @return IntegrationsApi.SyncOutlookRequestBuilder
         */
        public IntegrationsApi.SyncOutlookRequestBuilder skipEmbeddingGeneration(Boolean skipEmbeddingGeneration) {
            this.skipEmbeddingGeneration = skipEmbeddingGeneration;
            return (IntegrationsApi.SyncOutlookRequestBuilder) this;
        }
        
        /**
         * Set embeddingModel
         * @param embeddingModel  (optional)
         * @return IntegrationsApi.SyncOutlookRequestBuilder
         */
        public IntegrationsApi.SyncOutlookRequestBuilder embeddingModel(EmbeddingGenerators embeddingModel) {
            this.embeddingModel = embeddingModel;
            return (IntegrationsApi.SyncOutlookRequestBuilder) this;
        }
        
        /**
         * Set generateSparseVectors
         * @param generateSparseVectors  (optional, default to false)
         * @return IntegrationsApi.SyncOutlookRequestBuilder
         */
        public IntegrationsApi.SyncOutlookRequestBuilder generateSparseVectors(Boolean generateSparseVectors) {
            this.generateSparseVectors = generateSparseVectors;
            return (IntegrationsApi.SyncOutlookRequestBuilder) this;
        }
        
        /**
         * Set prependFilenameToChunks
         * @param prependFilenameToChunks  (optional, default to false)
         * @return IntegrationsApi.SyncOutlookRequestBuilder
         */
        public IntegrationsApi.SyncOutlookRequestBuilder prependFilenameToChunks(Boolean prependFilenameToChunks) {
            this.prependFilenameToChunks = prependFilenameToChunks;
            return (IntegrationsApi.SyncOutlookRequestBuilder) this;
        }
        
        /**
         * Set dataSourceId
         * @param dataSourceId  (optional)
         * @return IntegrationsApi.SyncOutlookRequestBuilder
         */
        public IntegrationsApi.SyncOutlookRequestBuilder dataSourceId(Integer dataSourceId) {
            this.dataSourceId = dataSourceId;
            return (IntegrationsApi.SyncOutlookRequestBuilder) this;
        }
        
        /**
         * Set requestId
         * @param requestId  (optional)
         * @return IntegrationsApi.SyncOutlookRequestBuilder
         */
        public IntegrationsApi.SyncOutlookRequestBuilder requestId(String requestId) {
            this.requestId = requestId;
            return (IntegrationsApi.SyncOutlookRequestBuilder) this;
        }
        
        /**
         * Set syncAttachments
         * @param syncAttachments  (optional, default to false)
         * @return IntegrationsApi.SyncOutlookRequestBuilder
         */
        public IntegrationsApi.SyncOutlookRequestBuilder syncAttachments(Boolean syncAttachments) {
            this.syncAttachments = syncAttachments;
            return (IntegrationsApi.SyncOutlookRequestBuilder) this;
        }
        
        /**
         * Set fileSyncConfig
         * @param fileSyncConfig  (optional)
         * @return IntegrationsApi.SyncOutlookRequestBuilder
         */
        public IntegrationsApi.SyncOutlookRequestBuilder fileSyncConfig(FileSyncConfigNullable fileSyncConfig) {
            this.fileSyncConfig = fileSyncConfig;
            return (IntegrationsApi.SyncOutlookRequestBuilder) this;
        }
        
        /**
         * Set incrementalSync
         * @param incrementalSync  (optional, default to false)
         * @return IntegrationsApi.SyncOutlookRequestBuilder
         */
        public IntegrationsApi.SyncOutlookRequestBuilder incrementalSync(Boolean incrementalSync) {
            this.incrementalSync = incrementalSync;
            return (IntegrationsApi.SyncOutlookRequestBuilder) this;
        }
        
        /**
         * Build call for syncOutlook
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            OutlookSyncInput outlookSyncInput = buildBodyParams();
            return syncOutlookCall(outlookSyncInput, _callback);
        }

        private OutlookSyncInput buildBodyParams() {
            OutlookSyncInput outlookSyncInput = new OutlookSyncInput();
            outlookSyncInput.tags(this.tags);
            outlookSyncInput.folder(this.folder);
            outlookSyncInput.filters(this.filters);
            outlookSyncInput.chunkSize(this.chunkSize);
            outlookSyncInput.chunkOverlap(this.chunkOverlap);
            outlookSyncInput.skipEmbeddingGeneration(this.skipEmbeddingGeneration);
            outlookSyncInput.embeddingModel(this.embeddingModel);
            outlookSyncInput.generateSparseVectors(this.generateSparseVectors);
            outlookSyncInput.prependFilenameToChunks(this.prependFilenameToChunks);
            outlookSyncInput.dataSourceId(this.dataSourceId);
            outlookSyncInput.requestId(this.requestId);
            outlookSyncInput.syncAttachments(this.syncAttachments);
            outlookSyncInput.fileSyncConfig(this.fileSyncConfig);
            outlookSyncInput.incrementalSync(this.incrementalSync);
            return outlookSyncInput;
        }

        /**
         * Execute syncOutlook request
         * @return GenericSuccessResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public GenericSuccessResponse execute() throws ApiException {
            OutlookSyncInput outlookSyncInput = buildBodyParams();
            ApiResponse<GenericSuccessResponse> localVarResp = syncOutlookWithHttpInfo(outlookSyncInput);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute syncOutlook request with HTTP info returned
         * @return ApiResponse&lt;GenericSuccessResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<GenericSuccessResponse> executeWithHttpInfo() throws ApiException {
            OutlookSyncInput outlookSyncInput = buildBodyParams();
            return syncOutlookWithHttpInfo(outlookSyncInput);
        }

        /**
         * Execute syncOutlook request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<GenericSuccessResponse> _callback) throws ApiException {
            OutlookSyncInput outlookSyncInput = buildBodyParams();
            return syncOutlookAsync(outlookSyncInput, _callback);
        }
    }

    /**
     * Outlook Sync
     * Once you have successfully connected your Outlook account, you can choose which emails to sync with us using the filters and folder parameter. \&quot;folder\&quot; should be the folder you want to sync from Outlook. By default we get messages from your inbox folder.   Filters is a JSON object with key value pairs. It also supports AND and OR operations. For now, we support a limited set of keys listed below.  &lt;b&gt;category&lt;/b&gt;: Custom categories that you created in Outlook.   &lt;b&gt;after&lt;/b&gt; or &lt;b&gt;before&lt;/b&gt;: A date in YYYY/mm/dd format (example 2023/12/31). Gets emails after/before a certain date. You can also use them in combination to get emails from a certain period.     &lt;b&gt;is&lt;/b&gt;: Can have the following values: flagged   &lt;b&gt;from&lt;/b&gt;: Email address of the sender     An example of a basic query with filters can be &#x60;&#x60;&#x60;json {     \&quot;filters\&quot;: {             \&quot;key\&quot;: \&quot;category\&quot;,             \&quot;value\&quot;: \&quot;Test\&quot;         } } &#x60;&#x60;&#x60; Which will list all emails that have the category \&quot;Test\&quot;.    Specifying a custom folder in the same query &#x60;&#x60;&#x60;json {     \&quot;folder\&quot;: \&quot;Folder Name\&quot;,     \&quot;filters\&quot;: {             \&quot;key\&quot;: \&quot;category\&quot;,             \&quot;value\&quot;: \&quot;Test\&quot;         } } &#x60;&#x60;&#x60;  You can use AND and OR operation in the following way: &#x60;&#x60;&#x60;json {     \&quot;filters\&quot;: {         \&quot;AND\&quot;: [             {                 \&quot;key\&quot;: \&quot;after\&quot;,                 \&quot;value\&quot;: \&quot;2024/01/07\&quot;             },             {                 \&quot;OR\&quot;: [                     {                         \&quot;key\&quot;: \&quot;category\&quot;,                         \&quot;value\&quot;: \&quot;Personal\&quot;                     },                     {                         \&quot;key\&quot;: \&quot;category\&quot;,                         \&quot;value\&quot;: \&quot;Test\&quot;                     },                 ]             }         ]     } } &#x60;&#x60;&#x60; This will return emails after 7th of Jan that have either Personal or Test as category.  Note that this is the highest level of nesting we support, i.e. you can&#39;t add more AND/OR filters within the OR filter in the above example.
     * @param outlookSyncInput  (required)
     * @return SyncOutlookRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
     </table>
     */
    public IntegrationsApi.SyncOutlookRequestBuilder syncOutlook(Object filters) throws IllegalArgumentException {
        if (filters == null) throw new IllegalArgumentException("\"filters\" is required but got null");
        return ((IntegrationsApi) this).new SyncOutlookRequestBuilder(filters);
    }
    private okhttp3.Call syncReposCall(GithubFetchReposRequest githubFetchReposRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = githubFetchReposRequest;

        // create path and map variables
        String localVarPath = "/integrations/github/sync_repos";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "accessToken", "apiKey", "customerId" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call syncReposValidateBeforeCall(GithubFetchReposRequest githubFetchReposRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'githubFetchReposRequest' is set
        if (githubFetchReposRequest == null) {
            throw new ApiException("Missing the required parameter 'githubFetchReposRequest' when calling syncRepos(Async)");
        }

        return syncReposCall(githubFetchReposRequest, _callback);

    }


    private ApiResponse<Object> syncReposWithHttpInfo(GithubFetchReposRequest githubFetchReposRequest) throws ApiException {
        okhttp3.Call localVarCall = syncReposValidateBeforeCall(githubFetchReposRequest, null);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call syncReposAsync(GithubFetchReposRequest githubFetchReposRequest, final ApiCallback<Object> _callback) throws ApiException {

        okhttp3.Call localVarCall = syncReposValidateBeforeCall(githubFetchReposRequest, _callback);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public abstract class SyncReposRequestBuilderGenerated {
        final List<String> repos;
        Integer dataSourceId;

        public SyncReposRequestBuilderGenerated(List<String> repos) {
            this.repos = repos;
        }

        /**
         * Set dataSourceId
         * @param dataSourceId  (optional)
         * @return IntegrationsApi.SyncReposRequestBuilder
         */
        public IntegrationsApi.SyncReposRequestBuilder dataSourceId(Integer dataSourceId) {
            this.dataSourceId = dataSourceId;
            return (IntegrationsApi.SyncReposRequestBuilder) this;
        }
        
        /**
         * Build call for syncRepos
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            GithubFetchReposRequest githubFetchReposRequest = buildBodyParams();
            return syncReposCall(githubFetchReposRequest, _callback);
        }

        private GithubFetchReposRequest buildBodyParams() {
            GithubFetchReposRequest githubFetchReposRequest = new GithubFetchReposRequest();
            githubFetchReposRequest.repos(this.repos);
            githubFetchReposRequest.dataSourceId(this.dataSourceId);
            return githubFetchReposRequest;
        }

        /**
         * Execute syncRepos request
         * @return Object
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public Object execute() throws ApiException {
            GithubFetchReposRequest githubFetchReposRequest = buildBodyParams();
            ApiResponse<Object> localVarResp = syncReposWithHttpInfo(githubFetchReposRequest);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute syncRepos request with HTTP info returned
         * @return ApiResponse&lt;Object&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Object> executeWithHttpInfo() throws ApiException {
            GithubFetchReposRequest githubFetchReposRequest = buildBodyParams();
            return syncReposWithHttpInfo(githubFetchReposRequest);
        }

        /**
         * Execute syncRepos request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Object> _callback) throws ApiException {
            GithubFetchReposRequest githubFetchReposRequest = buildBodyParams();
            return syncReposAsync(githubFetchReposRequest, _callback);
        }
    }

    /**
     * Github Sync Repos
     * You can retreive repos your token has access to using /integrations/github/repos and sync their content.  You can also pass full name of any public repository (username/repo-name). This will store the repo content with  carbon which can be accessed through /integrations/items/list endpoint. Maximum of 25 repositories are accepted per request.
     * @param githubFetchReposRequest  (required)
     * @return SyncReposRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
     </table>
     */
    public IntegrationsApi.SyncReposRequestBuilder syncRepos(List<String> repos) throws IllegalArgumentException {
        if (repos == null) throw new IllegalArgumentException("\"repos\" is required but got null");
        return ((IntegrationsApi) this).new SyncReposRequestBuilder(repos);
    }
    private okhttp3.Call syncRssFeedCall(RSSFeedInput rsSFeedInput, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = rsSFeedInput;

        // create path and map variables
        String localVarPath = "/integrations/rss_feed";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "accessToken", "apiKey", "customerId" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call syncRssFeedValidateBeforeCall(RSSFeedInput rsSFeedInput, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'rsSFeedInput' is set
        if (rsSFeedInput == null) {
            throw new ApiException("Missing the required parameter 'rsSFeedInput' when calling syncRssFeed(Async)");
        }

        return syncRssFeedCall(rsSFeedInput, _callback);

    }


    private ApiResponse<GenericSuccessResponse> syncRssFeedWithHttpInfo(RSSFeedInput rsSFeedInput) throws ApiException {
        okhttp3.Call localVarCall = syncRssFeedValidateBeforeCall(rsSFeedInput, null);
        Type localVarReturnType = new TypeToken<GenericSuccessResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call syncRssFeedAsync(RSSFeedInput rsSFeedInput, final ApiCallback<GenericSuccessResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = syncRssFeedValidateBeforeCall(rsSFeedInput, _callback);
        Type localVarReturnType = new TypeToken<GenericSuccessResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public abstract class SyncRssFeedRequestBuilderGenerated {
        final String url;
        Object tags;
        Integer chunkSize;
        Integer chunkOverlap;
        Boolean skipEmbeddingGeneration;
        EmbeddingGenerators embeddingModel;
        Boolean generateSparseVectors;
        Boolean prependFilenameToChunks;
        String requestId;

        public SyncRssFeedRequestBuilderGenerated(String url) {
            this.url = url;
        }

        /**
         * Set tags
         * @param tags  (optional)
         * @return IntegrationsApi.SyncRssFeedRequestBuilder
         */
        public IntegrationsApi.SyncRssFeedRequestBuilder tags(Object tags) {
            this.tags = tags;
            return (IntegrationsApi.SyncRssFeedRequestBuilder) this;
        }
        
        /**
         * Set chunkSize
         * @param chunkSize  (optional, default to 1500)
         * @return IntegrationsApi.SyncRssFeedRequestBuilder
         */
        public IntegrationsApi.SyncRssFeedRequestBuilder chunkSize(Integer chunkSize) {
            this.chunkSize = chunkSize;
            return (IntegrationsApi.SyncRssFeedRequestBuilder) this;
        }
        
        /**
         * Set chunkOverlap
         * @param chunkOverlap  (optional, default to 20)
         * @return IntegrationsApi.SyncRssFeedRequestBuilder
         */
        public IntegrationsApi.SyncRssFeedRequestBuilder chunkOverlap(Integer chunkOverlap) {
            this.chunkOverlap = chunkOverlap;
            return (IntegrationsApi.SyncRssFeedRequestBuilder) this;
        }
        
        /**
         * Set skipEmbeddingGeneration
         * @param skipEmbeddingGeneration  (optional, default to false)
         * @return IntegrationsApi.SyncRssFeedRequestBuilder
         */
        public IntegrationsApi.SyncRssFeedRequestBuilder skipEmbeddingGeneration(Boolean skipEmbeddingGeneration) {
            this.skipEmbeddingGeneration = skipEmbeddingGeneration;
            return (IntegrationsApi.SyncRssFeedRequestBuilder) this;
        }
        
        /**
         * Set embeddingModel
         * @param embeddingModel  (optional)
         * @return IntegrationsApi.SyncRssFeedRequestBuilder
         */
        public IntegrationsApi.SyncRssFeedRequestBuilder embeddingModel(EmbeddingGenerators embeddingModel) {
            this.embeddingModel = embeddingModel;
            return (IntegrationsApi.SyncRssFeedRequestBuilder) this;
        }
        
        /**
         * Set generateSparseVectors
         * @param generateSparseVectors  (optional, default to false)
         * @return IntegrationsApi.SyncRssFeedRequestBuilder
         */
        public IntegrationsApi.SyncRssFeedRequestBuilder generateSparseVectors(Boolean generateSparseVectors) {
            this.generateSparseVectors = generateSparseVectors;
            return (IntegrationsApi.SyncRssFeedRequestBuilder) this;
        }
        
        /**
         * Set prependFilenameToChunks
         * @param prependFilenameToChunks  (optional, default to false)
         * @return IntegrationsApi.SyncRssFeedRequestBuilder
         */
        public IntegrationsApi.SyncRssFeedRequestBuilder prependFilenameToChunks(Boolean prependFilenameToChunks) {
            this.prependFilenameToChunks = prependFilenameToChunks;
            return (IntegrationsApi.SyncRssFeedRequestBuilder) this;
        }
        
        /**
         * Set requestId
         * @param requestId  (optional)
         * @return IntegrationsApi.SyncRssFeedRequestBuilder
         */
        public IntegrationsApi.SyncRssFeedRequestBuilder requestId(String requestId) {
            this.requestId = requestId;
            return (IntegrationsApi.SyncRssFeedRequestBuilder) this;
        }
        
        /**
         * Build call for syncRssFeed
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            RSSFeedInput rsSFeedInput = buildBodyParams();
            return syncRssFeedCall(rsSFeedInput, _callback);
        }

        private RSSFeedInput buildBodyParams() {
            RSSFeedInput rsSFeedInput = new RSSFeedInput();
            rsSFeedInput.tags(this.tags);
            rsSFeedInput.url(this.url);
            rsSFeedInput.chunkSize(this.chunkSize);
            rsSFeedInput.chunkOverlap(this.chunkOverlap);
            rsSFeedInput.skipEmbeddingGeneration(this.skipEmbeddingGeneration);
            rsSFeedInput.embeddingModel(this.embeddingModel);
            rsSFeedInput.generateSparseVectors(this.generateSparseVectors);
            rsSFeedInput.prependFilenameToChunks(this.prependFilenameToChunks);
            rsSFeedInput.requestId(this.requestId);
            return rsSFeedInput;
        }

        /**
         * Execute syncRssFeed request
         * @return GenericSuccessResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public GenericSuccessResponse execute() throws ApiException {
            RSSFeedInput rsSFeedInput = buildBodyParams();
            ApiResponse<GenericSuccessResponse> localVarResp = syncRssFeedWithHttpInfo(rsSFeedInput);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute syncRssFeed request with HTTP info returned
         * @return ApiResponse&lt;GenericSuccessResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<GenericSuccessResponse> executeWithHttpInfo() throws ApiException {
            RSSFeedInput rsSFeedInput = buildBodyParams();
            return syncRssFeedWithHttpInfo(rsSFeedInput);
        }

        /**
         * Execute syncRssFeed request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<GenericSuccessResponse> _callback) throws ApiException {
            RSSFeedInput rsSFeedInput = buildBodyParams();
            return syncRssFeedAsync(rsSFeedInput, _callback);
        }
    }

    /**
     * Rss Feed
     * 
     * @param rsSFeedInput  (required)
     * @return SyncRssFeedRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
     </table>
     */
    public IntegrationsApi.SyncRssFeedRequestBuilder syncRssFeed(String url) throws IllegalArgumentException {
        if (url == null) throw new IllegalArgumentException("\"url\" is required but got null");
            

        return ((IntegrationsApi) this).new SyncRssFeedRequestBuilder(url);
    }
    private okhttp3.Call syncS3FilesCall(S3FileSyncInput s3FileSyncInput, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = s3FileSyncInput;

        // create path and map variables
        String localVarPath = "/integrations/s3/files";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "accessToken", "apiKey", "customerId" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call syncS3FilesValidateBeforeCall(S3FileSyncInput s3FileSyncInput, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 's3FileSyncInput' is set
        if (s3FileSyncInput == null) {
            throw new ApiException("Missing the required parameter 's3FileSyncInput' when calling syncS3Files(Async)");
        }

        return syncS3FilesCall(s3FileSyncInput, _callback);

    }


    private ApiResponse<GenericSuccessResponse> syncS3FilesWithHttpInfo(S3FileSyncInput s3FileSyncInput) throws ApiException {
        okhttp3.Call localVarCall = syncS3FilesValidateBeforeCall(s3FileSyncInput, null);
        Type localVarReturnType = new TypeToken<GenericSuccessResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call syncS3FilesAsync(S3FileSyncInput s3FileSyncInput, final ApiCallback<GenericSuccessResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = syncS3FilesValidateBeforeCall(s3FileSyncInput, _callback);
        Type localVarReturnType = new TypeToken<GenericSuccessResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public abstract class SyncS3FilesRequestBuilderGenerated {
        final List<S3GetFileInput> ids;
        Object tags;
        Integer chunkSize;
        Integer chunkOverlap;
        Boolean skipEmbeddingGeneration;
        EmbeddingGenerators embeddingModel;
        Boolean generateSparseVectors;
        Boolean prependFilenameToChunks;
        Integer maxItemsPerChunk;
        Boolean setPageAsBoundary;
        Integer dataSourceId;
        String requestId;
        Boolean useOcr;
        Boolean parsePdfTablesWithOcr;
        FileSyncConfigNullable fileSyncConfig;

        public SyncS3FilesRequestBuilderGenerated(List<S3GetFileInput> ids) {
            this.ids = ids;
        }

        /**
         * Set tags
         * @param tags  (optional)
         * @return IntegrationsApi.SyncS3FilesRequestBuilder
         */
        public IntegrationsApi.SyncS3FilesRequestBuilder tags(Object tags) {
            this.tags = tags;
            return (IntegrationsApi.SyncS3FilesRequestBuilder) this;
        }
        
        /**
         * Set chunkSize
         * @param chunkSize  (optional, default to 1500)
         * @return IntegrationsApi.SyncS3FilesRequestBuilder
         */
        public IntegrationsApi.SyncS3FilesRequestBuilder chunkSize(Integer chunkSize) {
            this.chunkSize = chunkSize;
            return (IntegrationsApi.SyncS3FilesRequestBuilder) this;
        }
        
        /**
         * Set chunkOverlap
         * @param chunkOverlap  (optional, default to 20)
         * @return IntegrationsApi.SyncS3FilesRequestBuilder
         */
        public IntegrationsApi.SyncS3FilesRequestBuilder chunkOverlap(Integer chunkOverlap) {
            this.chunkOverlap = chunkOverlap;
            return (IntegrationsApi.SyncS3FilesRequestBuilder) this;
        }
        
        /**
         * Set skipEmbeddingGeneration
         * @param skipEmbeddingGeneration  (optional, default to false)
         * @return IntegrationsApi.SyncS3FilesRequestBuilder
         */
        public IntegrationsApi.SyncS3FilesRequestBuilder skipEmbeddingGeneration(Boolean skipEmbeddingGeneration) {
            this.skipEmbeddingGeneration = skipEmbeddingGeneration;
            return (IntegrationsApi.SyncS3FilesRequestBuilder) this;
        }
        
        /**
         * Set embeddingModel
         * @param embeddingModel  (optional)
         * @return IntegrationsApi.SyncS3FilesRequestBuilder
         */
        public IntegrationsApi.SyncS3FilesRequestBuilder embeddingModel(EmbeddingGenerators embeddingModel) {
            this.embeddingModel = embeddingModel;
            return (IntegrationsApi.SyncS3FilesRequestBuilder) this;
        }
        
        /**
         * Set generateSparseVectors
         * @param generateSparseVectors  (optional, default to false)
         * @return IntegrationsApi.SyncS3FilesRequestBuilder
         */
        public IntegrationsApi.SyncS3FilesRequestBuilder generateSparseVectors(Boolean generateSparseVectors) {
            this.generateSparseVectors = generateSparseVectors;
            return (IntegrationsApi.SyncS3FilesRequestBuilder) this;
        }
        
        /**
         * Set prependFilenameToChunks
         * @param prependFilenameToChunks  (optional, default to false)
         * @return IntegrationsApi.SyncS3FilesRequestBuilder
         */
        public IntegrationsApi.SyncS3FilesRequestBuilder prependFilenameToChunks(Boolean prependFilenameToChunks) {
            this.prependFilenameToChunks = prependFilenameToChunks;
            return (IntegrationsApi.SyncS3FilesRequestBuilder) this;
        }
        
        /**
         * Set maxItemsPerChunk
         * @param maxItemsPerChunk Number of objects per chunk. For csv, tsv, xlsx, and json files only. (optional)
         * @return IntegrationsApi.SyncS3FilesRequestBuilder
         */
        public IntegrationsApi.SyncS3FilesRequestBuilder maxItemsPerChunk(Integer maxItemsPerChunk) {
            this.maxItemsPerChunk = maxItemsPerChunk;
            return (IntegrationsApi.SyncS3FilesRequestBuilder) this;
        }
        
        /**
         * Set setPageAsBoundary
         * @param setPageAsBoundary  (optional, default to false)
         * @return IntegrationsApi.SyncS3FilesRequestBuilder
         */
        public IntegrationsApi.SyncS3FilesRequestBuilder setPageAsBoundary(Boolean setPageAsBoundary) {
            this.setPageAsBoundary = setPageAsBoundary;
            return (IntegrationsApi.SyncS3FilesRequestBuilder) this;
        }
        
        /**
         * Set dataSourceId
         * @param dataSourceId  (optional)
         * @return IntegrationsApi.SyncS3FilesRequestBuilder
         */
        public IntegrationsApi.SyncS3FilesRequestBuilder dataSourceId(Integer dataSourceId) {
            this.dataSourceId = dataSourceId;
            return (IntegrationsApi.SyncS3FilesRequestBuilder) this;
        }
        
        /**
         * Set requestId
         * @param requestId  (optional)
         * @return IntegrationsApi.SyncS3FilesRequestBuilder
         */
        public IntegrationsApi.SyncS3FilesRequestBuilder requestId(String requestId) {
            this.requestId = requestId;
            return (IntegrationsApi.SyncS3FilesRequestBuilder) this;
        }
        
        /**
         * Set useOcr
         * @param useOcr  (optional, default to false)
         * @return IntegrationsApi.SyncS3FilesRequestBuilder
         */
        public IntegrationsApi.SyncS3FilesRequestBuilder useOcr(Boolean useOcr) {
            this.useOcr = useOcr;
            return (IntegrationsApi.SyncS3FilesRequestBuilder) this;
        }
        
        /**
         * Set parsePdfTablesWithOcr
         * @param parsePdfTablesWithOcr  (optional, default to false)
         * @return IntegrationsApi.SyncS3FilesRequestBuilder
         */
        public IntegrationsApi.SyncS3FilesRequestBuilder parsePdfTablesWithOcr(Boolean parsePdfTablesWithOcr) {
            this.parsePdfTablesWithOcr = parsePdfTablesWithOcr;
            return (IntegrationsApi.SyncS3FilesRequestBuilder) this;
        }
        
        /**
         * Set fileSyncConfig
         * @param fileSyncConfig  (optional)
         * @return IntegrationsApi.SyncS3FilesRequestBuilder
         */
        public IntegrationsApi.SyncS3FilesRequestBuilder fileSyncConfig(FileSyncConfigNullable fileSyncConfig) {
            this.fileSyncConfig = fileSyncConfig;
            return (IntegrationsApi.SyncS3FilesRequestBuilder) this;
        }
        
        /**
         * Build call for syncS3Files
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            S3FileSyncInput s3FileSyncInput = buildBodyParams();
            return syncS3FilesCall(s3FileSyncInput, _callback);
        }

        private S3FileSyncInput buildBodyParams() {
            S3FileSyncInput s3FileSyncInput = new S3FileSyncInput();
            s3FileSyncInput.tags(this.tags);
            s3FileSyncInput.ids(this.ids);
            s3FileSyncInput.chunkSize(this.chunkSize);
            s3FileSyncInput.chunkOverlap(this.chunkOverlap);
            s3FileSyncInput.skipEmbeddingGeneration(this.skipEmbeddingGeneration);
            s3FileSyncInput.embeddingModel(this.embeddingModel);
            s3FileSyncInput.generateSparseVectors(this.generateSparseVectors);
            s3FileSyncInput.prependFilenameToChunks(this.prependFilenameToChunks);
            s3FileSyncInput.maxItemsPerChunk(this.maxItemsPerChunk);
            s3FileSyncInput.setPageAsBoundary(this.setPageAsBoundary);
            s3FileSyncInput.dataSourceId(this.dataSourceId);
            s3FileSyncInput.requestId(this.requestId);
            s3FileSyncInput.useOcr(this.useOcr);
            s3FileSyncInput.parsePdfTablesWithOcr(this.parsePdfTablesWithOcr);
            s3FileSyncInput.fileSyncConfig(this.fileSyncConfig);
            return s3FileSyncInput;
        }

        /**
         * Execute syncS3Files request
         * @return GenericSuccessResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public GenericSuccessResponse execute() throws ApiException {
            S3FileSyncInput s3FileSyncInput = buildBodyParams();
            ApiResponse<GenericSuccessResponse> localVarResp = syncS3FilesWithHttpInfo(s3FileSyncInput);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute syncS3Files request with HTTP info returned
         * @return ApiResponse&lt;GenericSuccessResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<GenericSuccessResponse> executeWithHttpInfo() throws ApiException {
            S3FileSyncInput s3FileSyncInput = buildBodyParams();
            return syncS3FilesWithHttpInfo(s3FileSyncInput);
        }

        /**
         * Execute syncS3Files request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<GenericSuccessResponse> _callback) throws ApiException {
            S3FileSyncInput s3FileSyncInput = buildBodyParams();
            return syncS3FilesAsync(s3FileSyncInput, _callback);
        }
    }

    /**
     * S3 Files
     * After optionally loading the items via /integrations/items/sync and integrations/items/list, use the bucket name  and object key as the ID in this endpoint to sync them into Carbon. Additional parameters below can associate  data with the selected items or modify the sync behavior
     * @param s3FileSyncInput  (required)
     * @return SyncS3FilesRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
     </table>
     */
    public IntegrationsApi.SyncS3FilesRequestBuilder syncS3Files(List<S3GetFileInput> ids) throws IllegalArgumentException {
        if (ids == null) throw new IllegalArgumentException("\"ids\" is required but got null");
        return ((IntegrationsApi) this).new SyncS3FilesRequestBuilder(ids);
    }
    private okhttp3.Call syncSlackCall(SlackSyncRequest slackSyncRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = slackSyncRequest;

        // create path and map variables
        String localVarPath = "/integrations/slack/sync";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "accessToken", "apiKey", "customerId" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call syncSlackValidateBeforeCall(SlackSyncRequest slackSyncRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'slackSyncRequest' is set
        if (slackSyncRequest == null) {
            throw new ApiException("Missing the required parameter 'slackSyncRequest' when calling syncSlack(Async)");
        }

        return syncSlackCall(slackSyncRequest, _callback);

    }


    private ApiResponse<Object> syncSlackWithHttpInfo(SlackSyncRequest slackSyncRequest) throws ApiException {
        okhttp3.Call localVarCall = syncSlackValidateBeforeCall(slackSyncRequest, null);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call syncSlackAsync(SlackSyncRequest slackSyncRequest, final ApiCallback<Object> _callback) throws ApiException {

        okhttp3.Call localVarCall = syncSlackValidateBeforeCall(slackSyncRequest, _callback);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public abstract class SyncSlackRequestBuilderGenerated {
        final SlackFilters filters;
        Object tags;
        Integer chunkSize;
        Integer chunkOverlap;
        Boolean skipEmbeddingGeneration;
        EmbeddingGenerators embeddingModel;
        Boolean generateSparseVectors;
        Boolean prependFilenameToChunks;
        Integer dataSourceId;
        String requestId;

        public SyncSlackRequestBuilderGenerated(SlackFilters filters) {
            this.filters = filters;
        }

        /**
         * Set tags
         * @param tags  (optional)
         * @return IntegrationsApi.SyncSlackRequestBuilder
         */
        public IntegrationsApi.SyncSlackRequestBuilder tags(Object tags) {
            this.tags = tags;
            return (IntegrationsApi.SyncSlackRequestBuilder) this;
        }
        
        /**
         * Set chunkSize
         * @param chunkSize  (optional, default to 1500)
         * @return IntegrationsApi.SyncSlackRequestBuilder
         */
        public IntegrationsApi.SyncSlackRequestBuilder chunkSize(Integer chunkSize) {
            this.chunkSize = chunkSize;
            return (IntegrationsApi.SyncSlackRequestBuilder) this;
        }
        
        /**
         * Set chunkOverlap
         * @param chunkOverlap  (optional, default to 20)
         * @return IntegrationsApi.SyncSlackRequestBuilder
         */
        public IntegrationsApi.SyncSlackRequestBuilder chunkOverlap(Integer chunkOverlap) {
            this.chunkOverlap = chunkOverlap;
            return (IntegrationsApi.SyncSlackRequestBuilder) this;
        }
        
        /**
         * Set skipEmbeddingGeneration
         * @param skipEmbeddingGeneration  (optional, default to false)
         * @return IntegrationsApi.SyncSlackRequestBuilder
         */
        public IntegrationsApi.SyncSlackRequestBuilder skipEmbeddingGeneration(Boolean skipEmbeddingGeneration) {
            this.skipEmbeddingGeneration = skipEmbeddingGeneration;
            return (IntegrationsApi.SyncSlackRequestBuilder) this;
        }
        
        /**
         * Set embeddingModel
         * @param embeddingModel  (optional)
         * @return IntegrationsApi.SyncSlackRequestBuilder
         */
        public IntegrationsApi.SyncSlackRequestBuilder embeddingModel(EmbeddingGenerators embeddingModel) {
            this.embeddingModel = embeddingModel;
            return (IntegrationsApi.SyncSlackRequestBuilder) this;
        }
        
        /**
         * Set generateSparseVectors
         * @param generateSparseVectors  (optional, default to false)
         * @return IntegrationsApi.SyncSlackRequestBuilder
         */
        public IntegrationsApi.SyncSlackRequestBuilder generateSparseVectors(Boolean generateSparseVectors) {
            this.generateSparseVectors = generateSparseVectors;
            return (IntegrationsApi.SyncSlackRequestBuilder) this;
        }
        
        /**
         * Set prependFilenameToChunks
         * @param prependFilenameToChunks  (optional, default to false)
         * @return IntegrationsApi.SyncSlackRequestBuilder
         */
        public IntegrationsApi.SyncSlackRequestBuilder prependFilenameToChunks(Boolean prependFilenameToChunks) {
            this.prependFilenameToChunks = prependFilenameToChunks;
            return (IntegrationsApi.SyncSlackRequestBuilder) this;
        }
        
        /**
         * Set dataSourceId
         * @param dataSourceId  (optional)
         * @return IntegrationsApi.SyncSlackRequestBuilder
         */
        public IntegrationsApi.SyncSlackRequestBuilder dataSourceId(Integer dataSourceId) {
            this.dataSourceId = dataSourceId;
            return (IntegrationsApi.SyncSlackRequestBuilder) this;
        }
        
        /**
         * Set requestId
         * @param requestId  (optional)
         * @return IntegrationsApi.SyncSlackRequestBuilder
         */
        public IntegrationsApi.SyncSlackRequestBuilder requestId(String requestId) {
            this.requestId = requestId;
            return (IntegrationsApi.SyncSlackRequestBuilder) this;
        }
        
        /**
         * Build call for syncSlack
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            SlackSyncRequest slackSyncRequest = buildBodyParams();
            return syncSlackCall(slackSyncRequest, _callback);
        }

        private SlackSyncRequest buildBodyParams() {
            SlackSyncRequest slackSyncRequest = new SlackSyncRequest();
            slackSyncRequest.tags(this.tags);
            slackSyncRequest.filters(this.filters);
            slackSyncRequest.chunkSize(this.chunkSize);
            slackSyncRequest.chunkOverlap(this.chunkOverlap);
            slackSyncRequest.skipEmbeddingGeneration(this.skipEmbeddingGeneration);
            slackSyncRequest.embeddingModel(this.embeddingModel);
            slackSyncRequest.generateSparseVectors(this.generateSparseVectors);
            slackSyncRequest.prependFilenameToChunks(this.prependFilenameToChunks);
            slackSyncRequest.dataSourceId(this.dataSourceId);
            slackSyncRequest.requestId(this.requestId);
            return slackSyncRequest;
        }

        /**
         * Execute syncSlack request
         * @return Object
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public Object execute() throws ApiException {
            SlackSyncRequest slackSyncRequest = buildBodyParams();
            ApiResponse<Object> localVarResp = syncSlackWithHttpInfo(slackSyncRequest);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute syncSlack request with HTTP info returned
         * @return ApiResponse&lt;Object&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Object> executeWithHttpInfo() throws ApiException {
            SlackSyncRequest slackSyncRequest = buildBodyParams();
            return syncSlackWithHttpInfo(slackSyncRequest);
        }

        /**
         * Execute syncSlack request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Object> _callback) throws ApiException {
            SlackSyncRequest slackSyncRequest = buildBodyParams();
            return syncSlackAsync(slackSyncRequest, _callback);
        }
    }

    /**
     * Slack Sync
     * You can list all conversations using the endpoint /integrations/slack/conversations. The ID of  conversation will be used as an input for this endpoint with timestamps as optional filters.
     * @param slackSyncRequest  (required)
     * @return SyncSlackRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
     </table>
     */
    public IntegrationsApi.SyncSlackRequestBuilder syncSlack(SlackFilters filters) throws IllegalArgumentException {
        if (filters == null) throw new IllegalArgumentException("\"filters\" is required but got null");
        return ((IntegrationsApi) this).new SyncSlackRequestBuilder(filters);
    }
}
