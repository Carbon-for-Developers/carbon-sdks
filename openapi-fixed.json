{
  "openapi": "3.0.3",
  "info": {
    "title": "Carbon",
    "description": "Connect external data to LLMs, no matter the source.",
    "version": "1.0.0",
    "x-logo": {
      "url": "https://i.ibb.co/qBqT3Ft/Group-14-1.png"
    },
    "x-konfig-ignore": {
      "object-with-no-properties": true
    }
  },
  "servers": [
    {
      "url": "https://api.carbon.ai"
    }
  ],
  "tags": [
    {
      "description": "\nEmploy these endpoints when syncing files from external data sources outside of Carbon Connect.\n",
      "name": "Integrations"
    },
    {
      "description": "\n---\nUtilize these API endpoints to manage user documents. Whether the data is sourced from third-party integrations, web pages, or file uploads, Carbon maintains consistency by standardizing all documents as \"files\" within our data model.\n\nCarbon supports the following file formats:\n\n### Text\n- `pdf`\n- `xlsx`\n- `csv`\n- `docx`\n- `txt`\n- `md`\n- `rtf`\n- `tsv`\n- `pptx`\n- `json` (Coming Soon)\n\n### Audio\n- `mp3`\n- `mp4`\n- `mp2`\n- `aac`\n- `wav`\n- `flac`\n- `pcm`\n- `m4a`\n- `ogg`\n- `opus`\n- `webm`\n\n### Images\n- `jpg`\n- `png`\n",
      "name": "Files"
    },
    {
      "description": "\n---\nLeverage these `Utilities` endpoints to execute a wide range of helpful actions, including initiating web scraping, processing sitemaps, retrieving URLs from a specific webpage, obtaining relevant URLs based on a search query, fetching YouTube video transcripts, and many other functionalities.\n",
      "name": "Utilities"
    },
    {
      "description": "\n---\nEmploy these endpoints for direct vector searches within our managed vector database or to fetch embeddings for storage in your custom vector store. Additionally, we offer hybrid support for keyword-based searches.\n",
      "name": "Embeddings"
    },
    {
      "description": "\n---\nCarbon offers a set of webhooks for a variety of events, listed below. Currently, there is no way to choose\nwhich events to receive webhooks for - it's on our roadmap to allow for more fine-grained filtering. The steps\nin setting up webhooks for your service are:\n1. Add a URL to which webhoooks should be sent. This can be done using the `/add_webhook` endpoint.\n2. Save the `signing_key` in the response somewhere safe - this can't be retrieved again.\n\nAt this point, all events will be sent to the URL specified in step 1. An event - sent via an HTTP POST\nrequest - contains two important elements, a `Carbon-Signature` header and a body with a single key-value pair.\nYou can validate the authenticity and integrity of the webhook by calculating its signature. To do this, you should:\n1. Extract the timestamp and signature.\n    1. Extract the timestamp and signature from the `Carbon-Signature` header. It will be of the form\n`Carbon-Signature:t=1492774577,v1=5257a869e7ecebeda32affa62cdca3fa51cad7e77a0e56ff536d0ce8e108d8bd`.\n    2. For those using JavaScript and decoding the request json via `JSON.stringify`, we suggest using the `Carbon-Signature-Compact`\nheader instead. It will have the form `Carbon-Signature:t=1492774577,v2=5257a869e7ecebeda32affa62cdca3fa51cad7e77a0e56ff536d0ce8e108d8bd`.\n2. Create a string of the form `{timestamp}.{request_body}`, where `request_body` is the entire request body.\nNote that all values in the webhook request body are coerced to strings - this is *intentional*.\n    1. If using `Carbon-Signature`, you can use `request_body` as is, or you can decode it as json. When decoding, ensure that the \nresulting json is formatted *exactly* as it is in `request_body`. In other words, the json should look like:\n```\n{\"x\": 5, \"y\": 6}\n```\n    2. If using `Carbon-Signature-V2`, when decoding the request body, ensure that the resulting json is in compact form, where there \nare no spaces between key-value pairs or between keys and values. For example,\n```\n{\"x\":5,\"y\":6}\n```\nGiven a request body, `x`, you can do this in Python via `json.dumps(x, separators=[\",\", \":\"])` or in JavaScript via `JSON.stringify(x)`.\n3. Compute an HMAC of the above string with the SHA256 hash function. Use `signing_key` obtained from the `/add_webhook` endpoint as the key.\n4. Compare the computed signature with the signature in the header (the value that `v1` - or `v2` - is equal to). If they're identical,\nyou can be assured that the webhook is both genuine and hasn't been tampered with.\n\nOnce you receive and handle the webhook, you should respond to the POST request with a 200 status - otherwise the webhook\nwill be retried (up to three times).\n\n### Webhooks for File Processing\n\nWe currently support the following webhook events for file processing:\n1. `FILE_READY`\n    - Sent after a file has been fully processed and added to Carbon.\n2. `FILE_ERROR`\n    - Sent if there was an error during the file processing stage. If an error occurred, the file is requeued for reprocessing\n    up to three times.\n3. `FILE_DELETED`\n    - Sent if a file has been successfully deleted.\n4. `RATE_LIMIT_ERROR`\n    - Sent if the organization has reached the rate limit for file processing. In this case, the file is requeued for reprocessing\n    up to three times.\n\nThese are sent *after* a file has been processed.\n\n### Webhooks for Data Sources\n\nWe currently support the following webhook events for managing user connections to data sources:\n\n1. `ADD` \n    - This event is fired when a user authenticates their account for a specific data source for the first time.\n\n2. `UPDATE` \n    - This event is fired when a user selects one or more files for a particular data source. This event is fired once per file selection confirmation, regardless of how many files are selected.\n\n3. `CANCEL` \n    - This event is fired when a user cancels the authentication flow. It's important to note that this event cannot capture tab-close events, so directly closing a tab is not within our tracking capabilities.\n\n4. `REVOKE`\n    - This event is triggered when a user's data source connection is revoked via the `/revoke_access_token` endpoint.\n\nAn organization is allowed up to *3* webhook URLs. To delete an existing URL, you can use the `/delete_webhook` endpoint.\nTo view all existing webhooks, use the `/webhooks` endpoint.\n\nAll webhook payloads have the form\n```\n{\n    \"payload\": str\n}\n```\nThe value of `payload` (which is a stringified json object) will always have the form\n```\n{\n    \"webhook_type\": WebhookType,\n    \"obj\": {\n        \"object_type\": WebhookObjectType,\n        \"object_id\": str,\n        \"additional_information\": dict[str, str] | str\n    },\n    \"timestamp\": str\n}\n```\nNote that `WebhookType` is one of the webhook events described above. `WebhookObjectType` is limited to `FILE` currently.\n`additional_information` is always a dictionary of string-string key-value pairs, unless it's empty, in which case it is\nthe string value \"null\". Finally, `timestamp` is an int POSIX timestamp as a string. Note that to use `object_id` in\nsubsequent API requests, you'll likely need to convert it to an int.\n",
      "name": "Webhooks"
    },
    {
      "description": "\n---\n",
      "name": "Auth"
    },
    {
      "description": "\n---\n",
      "name": "Users"
    },
    {
      "description": "\n---\nCarbon facilitates user connections and content synchronization with third-party applications. We manage authentication, ingestion, parsing, and sync scheduling. Within Carbon, content from third-party applications is uniformly categorized as \"files\" within our data model. \n\nCarbon also supports websites as a data source (see [here](https://api.carbon.ai/redoc#tag/Data-Sources/operation/web_scrape_web_scrape_post)).\n\n# Google Drive\nThe Carbon Connect `enabledIntegrations` value for Google Drive is `GOOGLE_DRIVE`. Google Slides, Google Docs and Google Sheets are supported with our Google Drive integration, along with regular text, audio and image files.\n\n## Authorization Type\n\nCarbon uses **[OAuth 2.0](https://developers.google.com/identity/protocols/oauth2)** to connect to Google workspace.\n\n## Authorization Flow\n\n**Carbon's Google Drive integration is still pending approval from Google. In the meantime, end users are required to take a couple additional steps to connect their accounts (see gif below).**\n\n![](https://files.readme.io/19f57f6-Carbon_-_Google_OAuth_Flow.gif)\n\nLog into your Google Drive account.\n![](https://i.ibb.co/wQsyjrV/Screen-Shot-2023-08-11-at-2-04-49-PM.png)\n\nOnce you've successfully authenticated your account, you can select files directly.\n![](https://i.ibb.co/wYs9Xbp/image.png)\n\nClick \"Select\" after selecting files to grant Carbon access to files.\n![](https://i.ibb.co/1fSzKHS/image.png)\n\n\n## Configuration\n\n### Custom OAuth Credentials\n\n1. Go to `APIs and Services` > `Enabled APIs and Services` in your Google Cloud console, then click on the button titled `ENABLE APIS AND SERVICES` and enable `Google Drive API` and `Google Picker API`.\n2. Then create an `OAuth Client ID` in the `Credentials section` under `Google Drive API`. Select `Web Application` as the Application type and give it an identifiable name for your reference.\n\n![](https://files.readme.io/e7f42e5-image.png)\n\n3. Add [https://api.carbon.ai](https://api.carbon.ai/) as the `Authorized JS origin` and <https://api.carbon.ai/integrations/google> as an `Authorized redirect URI`.\n\n![](https://files.readme.io/60d16d3-image.png)\n\n4. Save the credentials. Download the credentials.json file once you save the OAuth Client ID data and share the file with Carbon.\n\n![](https://files.readme.io/f265775-image.png)\n\n5. Then create an `API key` in the `Credentials section` under `Google Picker API`. Restrict the application to websites and then add [https://api.carbon.ai](https://api.carbon.ai/) to the list under website restrictions. For `API Restrictions`, pick `Restrict key` and select `Google Picker API` from the list.\n\n6. Save the API key. Copy the API key and share it with Carbon.\n\n7. Configure your consent screen in the OAuth Consent Screen. Provide your **App name**, **support email address**, and **brand logo**. Add [carbon.ai](http://carbon.ai/) to `Authorized domain`.\n\n![](https://files.readme.io/33ebd01-image.png)\n\n![](https://files.readme.io/6d7f247-image.png)\n\n\n8. Click on `Add or Remove Scopes` button to add the following scopes: `userinfo.profile`, `userinfo.email`, `drive.readonly`, `drive.metadata.readonly`\n\n![](https://files.readme.io/6649d66-image.png)\n![](https://i.ibb.co/PNRnYwV/Screen-Shot-2023-08-11-at-2-11-51-PM.png)\n\n9. If you wish to add test users, you can do so. These users will not see the \"App is unverified\" notification. Other users will see this alert.\n10. Click `Publish App` to make this app available to your end-users.\n\n![](https://files.readme.io/d24c355-image.png)\n\n## Synchronization\n\nSyncs are triggered when end-users add or remove Google Drive files and folders via the Google Drive picker. When a user selects a folder to be synced, we auto-sync all files added to the folder as well.\n\nYou can use the `resync_file` API endpoint to programmatically resync specific Google Drive files.\n\nIn addition, we have a 24-hour batch sync running in the background. You can request us via Slack to run more frequent batch syncs.\n\n# Dropbox\nThe Carbon Connect `enabledIntegrations` value for Dropbox is `DROPBOX`.\n\n## Authorization Type\n\nCarbon uses **[OAuth 2.0](https://developers.dropbox.com/oauth-guide)** to connect to Dropbox.\n\n## Authorization Flow\n\nLog into your Dropbox account.\n![](https://files.readme.io/9427ebb-image.png)\n\nOnce you've successfully authenticated your account, you can select files directly.\n![](https://files.readme.io/0efd7b0-image.png)\n\nClick \"Choose\" after selecting files to grant Carbon access to files.\n![](https://files.readme.io/9c32acb-image.png)\n\n## Configuration\n\n### Custom OAuth Credentials\n\n1. Sign up on [Dropbox Developers](https://www.dropbox.com/developers) and create a new app with `Full Dropbox` access.\n\n![](https://i.ibb.co/fdrPky4/Screen-Shot-2023-09-08-at-12-39-39-PM.png)\n\n2. Copy and share the `App key` and `App secret` under the `Settings` tab with us.\n\n![](https://i.ibb.co/QmR2WXb/Screen-Shot-2023-09-08-at-1-06-46-PM.png)\n\n3. Add <https://api.carbon.ai/integrations/dropbox> as a `Redirect URIs` and [carbon.ai](carbon.ai) as the `Chooser / Saver / Embedder domains`.\n\n![](https://i.ibb.co/5vR8zgf/Screen-Shot-2023-09-08-at-1-15-17-PM.png)\n\n4. Configure your app details under the `Branding` tab. These details will appear on the OAuth Consent Screen as well. Provide your **App name**, **Publisher**, and **App icons**. \n\n![](https://i.ibb.co/wYj1LL7/Screen-Shot-2023-09-08-at-1-10-10-PM.png)\n\n5. Under the `Permissions` tab, add the following scopes: `account_info.read`, `files.metadata.read`, and `files.content.read`.\n\n![](https://i.ibb.co/xSzhgYC/Screen-Shot-2023-09-08-at-1-03-32-PM.png)\n\n6. Click `Apply for Production` under the `Settings` tab to make this app available to your end-users.\n\n## Functionality\n\nCarbon allows users to upload `pdf`, `docx`, `pptx`,`txt`,`csv`, `png`, `rtf`, `tsv`, `xlsx`, `jpeg` and `md` files directly from Dropbox.\n\n## Synchronization\n\nSyncs are triggered when end-users select files to upload via the Dropbox file selector UI. You can also use the `resync_file` API endpoint to programmatically resync specific Dropbox files. To delete Dropbox files from Carbon, you can use the `deletefile` endpoint directly.\n\nWe do not run our 24-hour batch sync for Dropbox by default. If you'd like us to enable batch syncs to run in the background, you can request this via Slack.\n\n# Intercom\n\nThe Carbon Connect `enabledIntegrations` value for Intercom is `INTERCOM`.\n\n## Authorization Type\n\nCarbon uses **[OAuth 2.0](https://developers.intercom.com/building-apps/docs/setting-up-oauth)** to connect to Intercom workspaces.\n\n## Authorization Flow\n\n![](https://files.readme.io/d72b15d-image.png)\n\n![](https://files.readme.io/c2825e3-image.png)\n\n## Functionality\n\nCarbon syncs all `Published` articles under a single Intercom workspace. Any `Draft` article won't be synced. We currently support only having a single Intercom workspace connected per `customer_id`.\n\n## Configuration\n\n### Custom OAuth Credentials\n\n1. After you create or log into your [Intercom Developer](https://developers.intercom.com/) account, click `New App` to create your own app.\n\n![](https://i.ibb.co/Y3Nmh4r/Screen-Shot-2023-09-11-at-5-06-46-PM.png)\n\n2. Under the `Authentication` tab, click `Edit` -> `Use OAuth` -> `Add redirect URL` and then enter https://api.carbon.ai/integrations/intercom.\n\n![](https://i.ibb.co/pfzG9VJ/Screen-Shot-2023-09-11-at-5-17-47-PM.png)\n\n3. Under the `Authentication` tab, click `Edit` and then add permissions for `Read one admin`, `Read and List Articles`, and `Read and Write Articles`. You can remove access to the other permissions.\n\n![](https://i.ibb.co/L9BxJFK/Screen-Shot-2023-09-11-at-5-21-01-PM.png)\n\n4. Under the `Basic Info` tab, share the `Client ID` and `Client secret` with us via Slack.\n\n![](https://i.ibb.co/wCnVcQq/Screen-Shot-2023-09-11-at-5-25-39-PM.png)\n\n5. Under the `Basic Info` tab, add an `App icon` and `App name`.\n\n![](https://i.ibb.co/HqS9bhk/Screen-Shot-2023-09-11-at-5-47-31-PM.png)\n\n6. Click `Test and publish` -> `Submit for review` and fill in the details require to publish your app. After your app is approved, then we can enable the white labeling.\n\n![](https://i.ibb.co/Cm0xWBF/Screen-Shot-2023-09-11-at-5-51-09-PM.png)\n\n\n## Synchronization\n\nSyncs are triggered when end-users add or remove pages via the Intercom OAuth flow. You can use the `resync_file` API endpoint to programmatically resync specific Intercom files.\n\nIn addition, we have a 24-hour batch sync running in the background. You can request us via Slack to run more frequent batch syncs.\n\n# Notion\n\nThe Carbon Connect `enabledIntegrations` value for Notion is `NOTION`.\n\n## Authorization Type\n\nCarbon uses **[OAuth 2.0](https://developers.notion.com/docs/authorization)** to connect to Notion workspaces.\n\n## Authorization Flow\n\n![](https://files.readme.io/0fa801d-image.png)\n\n![](https://files.readme.io/f72df4f-image.png)\n\n## Functionality\n\nCarbon enables end-users to select top-level pages for synchronization and automatically syncs all sub-pages. For instance, a top-level Company page may contain sub-pages for **`Company Benefits`** and **`PTO Policy`**. Once the end-user selects the Company page in the Authorization flow, Carbon automatically includes the sub-pages **`Company Benefits`** or **`PTO Policy`** to be synced.\n\n## Synchronization\n\nSyncs are triggered when end-users add or remove pages via the Notion OAuth flow. You can use the `resync_file` API endpoint to programmatically resync specific Notion files.\n\nIn addition, we have a 24-hour batch sync running in the background. You can request us via Slack to run more frequent batch syncs. \n\nWhen a user adds a nested page or database record under a selected Notion page, we auto-sync those documents as well.\n\n# OneDrive\n\nThe Carbon Connect `enabledIntegrations` value for OneDrive is `ONEDRIVE`.\n\n## Authorization Type\n\nCarbon uses **[OAuth 2.0](https://learn.microsoft.com/en-us/onedrive/developer/rest-api/getting-started/msa-oauth?view=odsp-graph-online)** to connect to OneDrive.\n\n## Authorization Flow\n\nLog into your Microsoft account.\n![](https://i.ibb.co/86FPknL/Screen-Shot-2023-08-31-at-4-41-48-PM.png)\n\nClick the \"Confirm\" button to grant us permission to access OneDrive.\n![](https://i.ibb.co/BqxmsJG/2880x1628.png)\n\nClick the \"Select Files from OneDrive\" button to open up the OneDrive file selector.\n![](https://i.ibb.co/Sm90PHL/Screen-Shot-2023-08-31-at-4-32-37-PM.png)\n\nClick \"Select\" after selecting files to grant Carbon access to files.\n![](https://i.ibb.co/t4Kchcv/Screen-Shot-2023-08-31-at-4-35-33-PM.png)\n\n## Configuration\n\n### Custom OAuth Credentials\n\n#### Setting up the OAuth App\n\n1. Create or log into your [Microsoft Azure](https://portal.azure.com/) Account.\n\n2. Under `Azure Services`, select `App Registration` -> `New registration`.\n\n![](https://i.ibb.co/SPR4ztF/Screen-Shot-2023-09-08-at-2-52-56-PM.png)\n\n3. Select `Accounts in any organizational directory (Any Microsoft Entra ID tenant - Multitenant) and personal Microsoft accounts (e.g. Skype, Xbox)` as the `Supported account types`.\n\n![](https://i.ibb.co/qBLpg1r/Screen-Shot-2023-09-12-at-11-09-28-PM.png)\n\n4. Add https://api.carbon.ai/integrations/onedrive as the `Redirect URI` and select `Web` under the `Select a platform` dropdown. You can also opt to use a custom CNAME record pointing to https://api.carbon.ai. The domain path must still be `/integrations/onedrive`.\n\n![](https://i.ibb.co/9NTZycz/Screen-Shot-2023-09-08-at-2-59-16-PM.png)\n\n5. Under `Manage` -> `API permissions` add the permissions `Files.Read.All`, `offline_access`, `openid`, and `User.Read`.\n\n![](https://i.ibb.co/VTGK90Z/Onedrive-1.png)\n\n6. Under `Client credentials`, click `Add a certificate or secret` -> `New Client Secret`. Then copy the client secret’s `Value` and share it with us via Slack.\n\n![](https://i.ibb.co/0tghs0p/Screen-Shot-2023-09-08-at-3-13-30-PM.png)\n\n7. Navigate to the `Overview` tab then copy the `Application (client) ID` and share it with us via Slack.\n\n![](https://i.ibb.co/KGWzr1H/Screen-Shot-2023-09-12-at-11-14-08-PM.png)\n\n8. Customize your app branding under `Manage` -> `Branding & properties`.\n\n![](https://i.ibb.co/HrS9Cxj/Screen-Shot-2023-09-08-at-3-24-16-PM.png)\n\n#### Setting up the File Picker UI\n\n1. Under `Azure Services`, select `App Registration` -> `New registration`.\n\n![](https://i.ibb.co/qBLpg1r/Screen-Shot-2023-09-12-at-11-09-28-PM.png)\n\n2. Select `Accounts in any organizational directory (Any Microsoft Entra ID tenant - Multitenant) and personal Microsoft accounts (e.g. Skype, Xbox)` as the `Supported account types`.\n\n![](https://i.ibb.co/SPR4ztF/Screen-Shot-2023-09-08-at-2-52-56-PM.png)\n\n3. Under the `Authentication` tab, select `Add a Platform` -> `Single Page Application`. \n\n![](https://i.ibb.co/nLDdQfP/Screen-Shot-2023-09-13-at-3-03-00-PM.png)\n\n4. For the `Redirect URI` of the `Single Page Application`, you can use https://api.carbon.ai/static/loading.html or add a custom CNAME record pointing to https://api.carbon.ai. The domain path must still be `/static/loading.html`.\n\n![](https://i.ibb.co/0X5Nkz7/Screen-Shot-2023-09-13-at-3-13-53-PM.png)\n\n5. Under the `Authentciation`'s `Implicit grant and hybrid flows` section, check `Access tokens (used for implicit flows)` and `ID tokens (used for implicit and hybrid flows)`.\n\n![](https://i.ibb.co/ckVKZgV/Screen-Shot-2023-09-13-at-3-17-44-PM.png)\n\n6. Under `Manage` -> `API permissions` add the permissions `Files.Read.All`, `Sites.Read.All`, `User.Read`, `AllSites.Read`, and `MyFiles.Read`.\n\n![](https://i.ibb.co/xjtvKTg/Screen-Shot-2023-09-13-at-3-22-12-PM.png)\n\n7. Under `Client credentials`, click `Add a certificate or secret` -> `New Client Secret`. Then copy the client secret’s `Value` and share it with us via Slack.\n\n![](https://i.ibb.co/0tghs0p/Screen-Shot-2023-09-08-at-3-13-30-PM.png)\n\n8. Navigate to the `Overview` tab then copy the `Application (client) ID` and share it with us via Slack.\n\n## Functionality\n\nCarbon allows users to upload `pdf`, `docx`, `pptx`,`txt`,`csv`, `png`, `rtf`, `tsv`, `xlsx`, `jpeg` and `md` files directly from OneDrive.\n\n## Synchronization\n\nSyncs are triggered when end-users select files to upload via the OneDrive file selector UI. You can also use the `resync_file` API endpoint to programmatically resync specific OneDrive files. To delete OneDrive files from Carbon, you can use the `deletefile` endpoint directly.\n\nWe do not run our 24-hour batch sync for OneDrive by default. If you'd like us to enable batch syncs to run in the background, you can request this via Slack.\n\n# SharePoint\n\nThe Carbon Connect `enabledIntegrations` value for SharePoint is `SHAREPOINT`.\n\n## Authorization Type\n\nCarbon uses **[OAuth 2.0](https://learn.microsoft.com/en-us/onedrive/developer/rest-api/getting-started/msa-oauth?view=odsp-graph-online)** to connect to SharePoint.\n\n## Authorization Flow\n\nEnter your Sharepoint `tenant` and `site name`. For example, if the SharePoint site URL is `https://jasoncarbon.sharepoint.com/sites/carbon-dev`, `jasoncarbon` is the tenant and `carbon-dev` is the site name.\n\n![](https://i.ibb.co/sgW9vfQ/Screen-Shot-2023-10-24-at-11-45-21-AM.png)\n\nLog into your Microsoft SharePoint account.\n![](https://i.ibb.co/86FPknL/Screen-Shot-2023-08-31-at-4-41-48-PM.png)\n\nClick the \"Confirm\" button to grant us permission to access SharePoint.\n![](https://i.ibb.co/x6L7knS/Screen-Shot-2023-10-24-at-11-45-27-AM.png)\n\nOnce clicking \"Confirm\", you will be taken through a flow to grant permissions.\n![](https://i.ibb.co/HTqCBVR/Screen-Shot-2023-10-24-at-1-00-08-PM.png)\n\nClick the \"Select Files from SharePoint\" button to open up the SharePoint file selector.\n![](https://i.ibb.co/6tn24b3/Screen-Shot-2023-10-24-at-1-00-20-PM.png)\n\nClick \"Select\" after selecting files to grant Carbon access to files.\n![](https://i.ibb.co/WVTwT9P/Screen-Shot-2023-10-24-at-11-45-39-AM.png)\n\nYou'll see a screen confirming that your files have been added.\n![](https://i.ibb.co/nwSRcSS/Screen-Shot-2023-10-24-at-11-45-11-AM.png)\n\n## Configuration\n\n### Custom OAuth Credentials\n\n#### Setting up the OAuth App\n\n1. Create or log into your [Microsoft Azure](https://portal.azure.com/) Account.\n\n2. Under `Azure Services`, select `App Registration` -> `New registration`.\n\n![](https://i.ibb.co/SPR4ztF/Screen-Shot-2023-09-08-at-2-52-56-PM.png)\n\n3. Select `Accounts in any organizational directory (Any Microsoft Entra ID tenant - Multitenant) and personal Microsoft accounts (e.g. Skype, Xbox)` as the `Supported account types`.\n\n![](https://i.ibb.co/qBLpg1r/Screen-Shot-2023-09-12-at-11-09-28-PM.png)\n\n4. Add https://api.carbon.ai/integrations/onedrive and https://api.carbon.ai/integrations/sharepoint to `Redirect URI` and select `Web` under the `Select a platform` dropdown. You can also opt to use a custom CNAME record pointing to https://api.carbon.ai. The domain paths must still be `/integrations/onedrive` and `/integrations/sharepoint`.\n\n![](https://i.ibb.co/9NTZycz/Screen-Shot-2023-09-08-at-2-59-16-PM.png)\n\n5. Under `Manage` -> `API permissions` add the permissions `Files.Read.All`, `offline_access`, `openid`, and `User.Read`.\n\n![](https://i.ibb.co/VTGK90Z/Onedrive-1.png)\n\n6. Under `Client credentials`, click `Add a certificate or secret` -> `New Client Secret`. Then copy the client secret’s `Value` and share it with us via Slack.\n\n![](https://i.ibb.co/0tghs0p/Screen-Shot-2023-09-08-at-3-13-30-PM.png)\n\n7. Navigate to the `Overview` tab then copy the `Application (client) ID` and share it with us via Slack.\n\n![](https://i.ibb.co/KGWzr1H/Screen-Shot-2023-09-12-at-11-14-08-PM.png)\n\n8. Customize your app branding under `Manage` -> `Branding & properties`.\n\n![](https://i.ibb.co/HrS9Cxj/Screen-Shot-2023-09-08-at-3-24-16-PM.png)\n\n#### Setting up the File Picker UI\n\n1. Under `Azure Services`, select `App Registration` -> `New registration`.\n\n![](https://i.ibb.co/qBLpg1r/Screen-Shot-2023-09-12-at-11-09-28-PM.png)\n\n2. Select `Accounts in any organizational directory (Any Microsoft Entra ID tenant - Multitenant) and personal Microsoft accounts (e.g. Skype, Xbox)` as the `Supported account types`.\n\n![](https://i.ibb.co/SPR4ztF/Screen-Shot-2023-09-08-at-2-52-56-PM.png)\n\n3. Under the `Authentication` tab, select `Add a Platform` -> `Single Page Application`. \n\n![](https://i.ibb.co/nLDdQfP/Screen-Shot-2023-09-13-at-3-03-00-PM.png)\n\n4. For the `Redirect URI` of the `Single Page Application`, you can use https://api.carbon.ai/static/loading.html or add a custom CNAME record pointing to https://api.carbon.ai. The domain path must still be `/static/loading.html`.\n\n![](https://i.ibb.co/0X5Nkz7/Screen-Shot-2023-09-13-at-3-13-53-PM.png)\n\n5. Under the `Authentciation`'s `Implicit grant and hybrid flows` section, check `Access tokens (used for implicit flows)` and `ID tokens (used for implicit and hybrid flows)`.\n\n![](https://i.ibb.co/ckVKZgV/Screen-Shot-2023-09-13-at-3-17-44-PM.png)\n\n6. Under `Manage` -> `API permissions` add the permissions `Files.Read.All`, `Sites.Read.All`, `User.Read`, `AllSites.Read`, and `MyFiles.Read`.\n\n![](https://i.ibb.co/xjtvKTg/Screen-Shot-2023-09-13-at-3-22-12-PM.png)\n\n7. Under `Client credentials`, click `Add a certificate or secret` -> `New Client Secret`. Then copy the client secret’s `Value` and share it with us via Slack.\n\n![](https://i.ibb.co/0tghs0p/Screen-Shot-2023-09-08-at-3-13-30-PM.png)\n\n8. Navigate to the `Overview` tab then copy the `Application (client) ID` and share it with us via Slack.\n\n## Functionality\n\nCarbon allows users to upload `pdf`, `docx`, `pptx`,`txt`,`csv`, `png`, `rtf`, `tsv`, `xlsx`, `jpeg` and `md` files directly from SharePoint.\n\n## Synchronization\n\nSyncs are triggered when end-users select files to upload via the SharePoint file selector UI. You can also use the `resync_file` API endpoint to programmatically resync specific SharePoint files. To delete SharePoint files from Carbon, you can use the `deletefile` endpoint directly.\n\nWe do not run our 24-hour batch sync for SharePoint by default. If you'd like us to enable batch syncs to run in the background, you can request this via Slack.\n\n# Zotero\n\nThe Carbon Connect `enabledIntegrations` value for ZOTERO is `ZOTERO`.\n\n## Authorization Type\n\nCarbon uses **[OAuth 1.0](https://www.zotero.org/support/dev/web_api/v2/oauth)** to connect to Zotero.\n\n## Authorization Flow\n\nLog into your Zotero account. \n![](https://i.ibb.co/sgnb9xC/Screen-Shot-2023-11-06-at-12-45-31-PM.png)\n\nClick the \"Accept Defaults\" button to grant us permission to access Zotero.\n![](https://i.ibb.co/sJbyWX7/Screen-Shot-2023-11-06-at-12-43-09-PM.png)\n\nOnce clicking \"Accept Defaults\", all Zotero files are synced and you should see the following confirmation:\n![](https://i.ibb.co/HLvPWK8/Screen-Shot-2023-11-06-at-12-42-42-PM.png)\n\n## Configuration\n\n### Custom OAuth Credentials\n\n#### Setting up the OAuth App\n\n1. Create or log into your [Zotero](https://www.zotero.org/) Account.\n\n2. Click [here](https://www.zotero.org/oauth/apps) to set up your OAuth app.\n\n![](https://i.ibb.co/rs41H7N/Screen-Shot-2023-11-06-at-2-41-13-PM.png)\n\n3. Click \"Register a New Application\" and fill out the info below. Add https://api.carbon.ai/integrations/zotero as the `Callback URL`. You can also opt to use a custom CNAME record pointing to https://api.carbon.ai. The domain path must still be `/integrations/zotero`.\n\n![](https://i.ibb.co/5nBwgWT/Screen-Shot-2023-11-06-at-12-51-59-PM.png)\n\n4. Copy and share the Client Key and Client Secret with Carbon.\n\n![](https://i.ibb.co/cTkv51s/Screen-Shot-2023-11-06-at-2-46-20-PM.png)\n\n## Functionality\n\nCarbon allows users to upload `pdf`, `docx`, `pptx`,`txt`,`csv`, `png`, `rtf`, `tsv`, `xlsx`, `jpeg` and `md` files directly from Zotero.\n\n## Synchronization\n\nBy default, Carbon syncs all attachments from your Zotero library along with the accompanying info as metadata.\n\nYou can use the `resync_file` API endpoint to programmatically resync specific Zotero files. To delete Zotero files from Carbon, you can use the `deletefile` endpoint directly.\n\nWe do not run our 24-hour batch sync for Zotero by default. If you'd like us to enable batch syncs to run in the background, you can request this via Slack.\n\n# Box\n\nThe Carbon Connect `enabledIntegrations` value for Box is `BOX`.\n\n## Authorization Type\n\nCarbon uses **[OAuth 2.0](https://developer.box.com/guides/authentication/oauth2/)** to connect to Box.\n\n## Authorization Flow\n\nLog into your Box account.\n\n![](https://i.ibb.co/8gGpBdg/Screen-Shot-2023-09-08-at-1-34-42-PM.png)\n\nClick the \"Select Files from Box\" button to open up the Box file selector.\n![](https://i.ibb.co/K55H1rp/Screen-Shot-2023-09-08-at-1-38-15-PM.png)\n\nClick the checkmark after selecting files to grant Carbon access to files.\n\n*Limitations*: You can currently only upload individual file(s) via Box's file selector. If you'd like the ability the upload entire folders, please reach out to us on Slack. \n\n![](https://i.ibb.co/Zz2pDPm/Screen-Shot-2023-09-08-at-1-33-30-PM.png)\n\nYou'll receive a confirmation that your file(s) has been uploaded.\n\n![](https://i.ibb.co/ZTZQw03/Screen-Shot-2023-09-08-at-2-03-48-PM.png)\n\n\n## Configuration\n\n### Custom OAuth Credentials\n\n1. Sign up for an account under [Box Developer](https://developer.box.com/).\n\n2. Go to `My Apps`, then `Create New App` -> `Choose Custom App`.\n\n![](https://i.ibb.co/cQw41M9/Screen-Shot-2023-09-08-at-2-12-34-PM.png)\n\n2. Fill out the app details in the modal that opens.\n\n![](https://i.ibb.co/TPJpqny/Screen-Shot-2023-09-08-at-2-14-32-PM.png)\n\n3. Select User Auth with OAuth 2.0 in the following step.\n\n![](https://i.ibb.co/Hr3SJJ8/Screen-Shot-2023-09-08-at-2-20-26-PM.png)\n\n4. In the `Configuration` tab copy and paste the `Client ID` and `Client Secret` and share it with us.\n\n![](https://i.ibb.co/1mm1PWM/Screen-Shot-2023-09-08-at-2-22-53-PM.png)\n\n5. Add https://api.carbon.ai/integrations/box as a `Redirect URIs` and https://api.carbon.ai as a `CORS Domains`\n\n![](https://i.ibb.co/374946D/Screen-Shot-2023-09-08-at-2-30-28-PM.png)\n![](https://i.ibb.co/HdtDqfd/Screen-Shot-2023-09-08-at-2-31-14-PM.png)\n\n7. For scopes, select `Read all files and folders stored in Box` and `Write all files and folders stored in Box`.\n\n![](https://i.ibb.co/9wRrqKX/Screen-Shot-2023-09-08-at-2-27-44-PM.png)\n\n8. In the `App Center` tab, you can edit your branding.\n\n![](https://i.ibb.co/GsHQq2g/Screen-Shot-2023-09-08-at-2-34-26-PM.png)\n\n9. Once you're ready, you can also submit your app for approval.\n\n![](https://i.ibb.co/XVg2skh/Screen-Shot-2023-09-08-at-2-37-05-PM.png)\n\n## Functionality\n\nCarbon allows users to upload `pdf`, `docx`, `pptx`,`txt`,`csv`, `png`, `rtf`, `tsv`, `xlsx`, `jpeg` and `md` files directly from Box.\n\n## Synchronization\n\nSyncs are triggered when end-users select files to upload via the Box file selector UI. You can also use the `resync_file` API endpoint to programmatically resync specific Box files. To delete Box files from Carbon, you can use the `deletefile` endpoint directly.\n\nWe do not run our 24-hour batch sync for Box by default. If you'd like us to enable batch syncs to run in the background, you can request this via Slack.\n\n\n# Zendesk\nThe Carbon Connect `enabledIntegrations` value for Zendesk is `ZENDESK`.\n\n## Authorization Type\n\nCarbon uses **[OAuth 2.0](https://developers.Zendesk.com/building-apps/docs/setting-up-oauth)** to connect to Zendesk workspaces.\n\n## Authorization Flow\n\n![](https://i.ibb.co/Zc1sh5Q/Screen-Shot-2023-09-14-at-5-25-02-PM.png)\n\n![](https://i.ibb.co/DKqsbFC/Screen-Shot-2023-09-14-at-10-40-28-AM.png)\n\n![](https://i.ibb.co/Vw6bF82/Screen-Shot-2023-09-14-at-10-37-47-AM.png)\n\n## Functionality\n\nCarbon syncs all `Published` articles under a single Zendesk workspace. Any `Draft` article won't be synced. We currently support only having a single Zendesk workspace connected per `customer_id`.\n\n## Configuration\n\n### Custom OAuth Credentials\n\n1. In Admin Center, click the `Apps and integrations` icon and then in the sidebar, select `APIs` > `Zendesk` APIs.\n\n![](https://i.ibb.co/3cXNwRj/Screen-Shot-2023-09-14-at-9-05-14-AM.png)\n\n![](https://i.ibb.co/wzvZ9jS/Screen-Shot-2023-09-13-at-5-08-26-PM.png)\n\n2. Click the `OAuth Clients` tab on the Zendesk API page, and then click `Add OAuth client` on the right side of the OAuth client list.\n\n![](https://i.ibb.co/djnzwcx/Screen-Shot-2023-09-13-at-5-06-46-PM.png)\n\n3. Complete the following fields to create a client:\n- Client Name - Enter a name for your app. This is the name that users will see when asked to grant access to your application, and when they check the list of third-party apps that have access to their Zendesk.\nDescription - Optional. This is a short description of your app that users will see when asked to grant access to it.\n- Company - Optional. This is the company name that users will see when asked to grant access to your application. The information can help them understand who they're granting access to.\n- Logo - Optional. This is the logo that users will see when asked to grant access to your application. The image can be a JPG, GIF, or PNG. For best results, upload a square image. It will be resized for the authorization page.\n- Unique Identifier - The field is auto-populated with a reformatted version of the name you entered for your app. You can change it if you want.\n- Redirect URLs - Enter https://api.carbon.ai/integrations/zendesk here. You can also opt to use a custom CNAME record pointing to https://api.carbon.ai. The domain path must still be `/integrations/zendesk`.\n\n![](https://i.ibb.co/yPqPzbD/Screen-Shot-2023-09-13-at-5-15-35-PM.png)\n\n4. Click Save. After the page refreshes, a new pre-populated Secret field appears on the lower side. This is the `client_secret` value specified in the OAuth2 spec. Send us the `client_secret` value over Slack.\n6. Copy the Secret value to your clipboard and save it somewhere safe. Note: The characters may extend past the width of the text box, so make sure to select everything before copying.\n\n![](https://i.ibb.co/Db8TQDJ/Screen-Shot-2023-09-13-at-5-21-34-PM.png)\n\n7. Copy the `Unique Identifier` of the OAuth app and share that value over Slack as well.\n8. In order for us to white-label your OAuth app, you need to request approval first to convert the app from a **local OAuth client** to **global OAuth client**. You can follow the instructions [here](https://developer.zendesk.com/documentation/marketplace/building-a-marketplace-app/set-up-a-global-oauth-client) to do so.\n\n## Synchronization\n\nSyncs are triggered when end-users add or remove pages via the Zendesk OAuth flow. You can use the `resync_file` API endpoint to programmatically resync specific Zendesk files.\n\nIn addition, we have a 24-hour batch sync running in the background. You can request us via Slack to run more frequent batch syncs.\n\n# Slack\n# Confluence\n",
      "name": "Data Sources"
    },
    {
      "description": "\n---\nUse this endpoint to check the status of the API. A `200` response indicates that the Carbon API is up.\n\nYou can also check for the health of our services on our [Status Page](https://status.carbon.ai/).\n",
      "name": "Health"
    },
    {
      "name": "Organizations"
    },
    {
      "description": "\n---\n\n![](http://cdn.mcauto-images-production.sendgrid.net/3b277c940596d872/33ed03b3-3f38-485c-a51c-8925f14a7441/1780x1252.png)\n\n## What is Carbon?\n\nCarbon provides a comprehensive framework designed to streamline the process of connecting external data sources to Large Language Models (LLMs). \n\nThe Carbon search model is purpose-built for Large Language Models (LLMs) because of its fully neural architecture, enabling natural language querying across indexed documents from external data sources. In cases where vector (or neural) search isn't optimal, Carbon also supports keyword-based searches.\n\nCarbon simplifies the process of **retrieval augmented generation** (RAG), allowing you to spend more time using your data, and less time trying to ingest it.\n\n## How Carbon Works\n\nUse **[Carbon Connect](https://api.carbon.ai/redoc#tag/Carbon-Connect)** to connect to your users' data sources and then our **Universal API** to retrieve the data to use with LLMs. Carbon has native integrations with 10+ data sources and supports more than 20+ file formats, encompassing text, audio, and visual data.\n\nDepending on your use case and in-house infrastructure, you can retrieve user data from Carbon in several formats: \n\n- Parsed plaintext files\n- Embeddings (and chunks) to store in your vector store\n- Direct semantic and keyword search against Carbon's managed vector database\n\n## Products\n\n### 🔗 Connect\n\nA client-side component for users to connect data sources such as Notion, Google Drive, Dropbox, OneDrive, websites, and file uploads. Available as a React component, JavaScript SDK, and soon as a magic link. \n\nCarbon handles OAuth flows for 10+ sources, transforms the source data, and automates data synchronization.\n\n### 🗄️ Store\n\nChoose between Carbon's managed vector database (hosted on Qdrant Cloud) or your storage solution. The database updates as users modify connected sources and manage chunks alongside embeddings.\n\n### 🔌 Universal API\n\nAccess and manage data (documents, chunks, vectors, etc.) from any source using our flexible API suite. Apply custom metadata filters to objects for tailored data retrieval.\n\n## Setup\n\n---\n\n### 🔑 Getting a Carbon API Key\n\nCarbon is free to use up to the first 20 million characters. \nBook a 15 minute onboarding to get an API key [here](https://cal.com/carbon-ai/15min).\n\n### 🔗 Helpful Links\nTo get started with Carbon, follow our guides:\n\n- [Installing Carbon Connect](https://api.carbon.ai/redoc#tag/Carbon-Connect)\n- [Integrating Data Sources](https://api.carbon.ai/redoc#tag/Data-Sources)\n\n",
      "name": "Getting Started"
    },
    {
      "description": "\n\n---\n\nUse Connect to connect to your users' accounts with the Carbon API.\n\nCarbon Connect is the client-side component that your users will interact with in order upload their content to Carbon and grant you access via the Carbon API.\n\nCarbon Connect handles credential validation, content upload, and success/error handling for each connector that Carbon supports. We support 10+ integrations (Google Drive, Notion, etc), local file uploads (images, audio and text), and public webpages.\n\nCarbon is currently supported via a Javascript SDK, as well as via React Native and mobile webviews.\n\n![](http://cdn.mcauto-images-production.sendgrid.net/3b277c940596d872/17a00fb4-f6d8-49fd-86e1-1a82dd8e64f1/680x1089.gif)\n\n# Javascript SDK\n\n---\n\nCarbon Connect JS is a vanilla JS wrapper and a headless offering to integrate Carbon API into your product.\n\nYou can reference this example repo showcasing our JS SDK [here](https://github.com/hubbleai/sdk-example).\n\n## Installation\n\n---\n\nUse the package manager [npm](https://www.npmjs.com/) to install carbon-connect-js.\n\n```bash\nnpm install carbon-connect-js\n```\n\n## Usage\n\n---\n\n```javascript\nimport * as Carbon from 'carbon-connect-js';\n\n// Note: Access token generation should happen prior to other function calls!\n\n// Generate Access Token\nconst accessTokenResponse = await Carbon.generateAccessToken(\n  'api_key',\n  'customer_id'\n);\nconsole.log(accessTokenResponse.data.access_token);\n\n// Get White Label data\nconst whiteLabelResponse = Carbon.getWhiteLabelData('ACCESS_TOKEN');\nconsole.log(whiteLabelResponse.data);\n```\n\n## Methods\n\n---\n\n### 1. generateAccessToken()\n\n- **Description**: This method is used to generate an access token required for authentication. The access token will be valid for 10 hours.\n\n- **Parameters**: The `generateAccessToken()` method accepts an object with the following properties:\n\n  - `apiKey` (string): Your API key.\n  - `customerId` (string): The customer's unique ID.\n\n- **Returns**: A promise that resolves to an `AccessTokenResponse` object:\n\n  - `status` (number): The HTTP status code of the response.\n  - `data` (object or null): The response data containing the access token, if the request was successful. Otherwise, null.\n  - `error` (string or null): Error message if there was an issue generating the token. Otherwise, null.\n\n- **Usage**: Here's how you can use the `generateAccessToken()` method\n\n  ```javascript\n  const Carbon = require('carbon-connect-js');\n\n  async function fetchAccessToken() {\n    try {\n      const response = await Carbon.generateAccessToken({\n        apiKey: 'your_api_key',\n        customerId: 'your_customer_id',\n      });\n\n      if (response.status === 200) {\n        console.log('Access token:', response.data);\n      } else {\n        console.error('Error:', response.error);\n      }\n    } catch (err) {\n      console.error('Unexpected error:', err);\n    }\n  }\n\n  fetchAccessToken();\n  ```\n\n- **Note** : It is ideal to call this method from your backend code and return it to your frontend. This is to avoid exposing your API key to the frontend.\n\n### 2. getWhiteLabelData()\n\n- **Description**: This method retrieves the white label data of the organization, which can be useful for custom branding and theming.\n- **Parameters**: The `getWhiteLabelData()` method accepts an object with the following properties:\n\n  - `accessToken` (string): The access token obtained from the authentication process.\n\n- **Returns**: A promise that resolves to an `WhiteLabelDataResponse` object:\n\n  - `status` (number): The HTTP status code of the response.\n  - `data` (object): The response data containing details of the white label settings.\n\n- **Usage**: Here's how you can use the `getWhiteLabelData()` method\n\n  ```javascript\n  import * as Carbon from 'carbon-connect-js';\n\n  async function fetchWhiteLabelDetails() {\n    try {\n      const response = await Carbon.getWhiteLabelData({\n        accessToken: 'ACCESS_TOKEN',\n      });\n\n      if (response.status === 200) {\n        console.log('White Label Data:', response.data);\n      } else {\n        console.error(\n          'Failed to fetch white label data. Status:',\n          response.status\n        );\n      }\n    } catch (err) {\n      console.error('Unexpected error:', err.message);\n    }\n  }\n\n  // Call the function to fetch the data.\n  fetchWhiteLabelDetails();\n  ```\n\n### 3. getUserConnections()\n\n- **Description**: Retrieve all the active integrations or connections associated with a user.\n- **Parameters**: The `getUserConnections()` method accepts an object with the following properties:\n\n  - `accessToken` (string): The access token obtained from the authentication process.\n\n- **Returns**: A promise that resolves to a `UserConnectionsResponse` object:\n\n  - `status` (number): The HTTP status code of the response.\n  - `connections` (array): List of active integrations or connections associated with the user.\n  - `error` (object or null): Contains error details if any issues arise while fetching user connections.\n\n- **Usage**:\n\n```javascript\nimport * as Carbon from 'carbon-connect-js';\n\nasync function fetchUserIntegrations() {\n  try {\n    const response = await Carbon.getUserConnections({\n      accessToken: 'ACCESS_TOKEN',\n    });\n\n    if (response.status === 200) {\n      console.log('User Connections:', response.connections);\n    } else {\n      console.error('Error:', response.error.message);\n    }\n  } catch (err) {\n    console.error('Unexpected error:', err.message);\n  }\n}\n\n// Initiate the call to fetch user integrations.\nfetchUserIntegrations();\n```\n\n### 4. generateOauthurl()\n\n- **Description**: Generate an OAuth URL to facilitate users in connecting a third-party account.\n\n- **Parameters**: The `generateOauthurl()` method accepts an object with the following properties:\n\n  - `accessToken` (string): The access token obtained through authentication.\n  - `integrationName` (string): Name of the third-party service you want to integrate.\n  - `chunkSize` (number, optional): Defines the chunk size. Defaults to 1500.\n  - `chunkOverlap` (number, optional): Defines the chunk overlap. Defaults to 20.\n  - `skipEmbeddingGeneration` (boolean, optional): If set to true, embedding generation will be skipped. Defaults to false.\n  - `tags` (object, optional): Tags that can be passed for additional information. Defaults to an empty object.\n\n- **Returns**: A promise that resolves to a `GenerateOAuthURLResponse` object:\n\n  - `status` (number): The HTTP status code of the response.\n  - `data` (object): Contains details like the generated OAuth URL, integration name, chunk size, chunk overlap, and other specified parameters.\n  - `error` (string or null): Contains error message if there's any issue generating the OAuth URL.\n\n- **Usage**:\n\n  ```javascript\n  import * as Carbon from 'carbon-connect-js';\n\n  async function generateIntegrationOAuthURL() {\n    try {\n      const response = await Carbon.generateOauthurl({\n        accessToken: 'YOUR_ACCESS_TOKEN',\n        integrationName: 'SERVICE_NAME',\n        // Accepted values are: NOTION, GOOGLE_DRIVE, ONEDRIVE, INTERCOM, DROPBOX, ZENDESK, BOX\n      });\n\n      if (response.status === 200) {\n        console.log('Generated OAuth URL:', response.data.oauth_url);\n      } else {\n        console.error('Error:', response.error);\n      }\n    } catch (err) {\n      console.error('Unexpected error:', err.message);\n    }\n  }\n\n  generateIntegrationOAuthURL();\n  ```\n\n### 5. uploadFiles()\n\n- **Description**: Upload one or multiple files to Carbon, with options to control chunk size, chunk overlap, and embedding generation.\n\n- **Parameters**: The `uploadFiles()` method accepts an object with the following properties:\n\n  - `accessToken` (string): The access token obtained through authentication.\n  - `files` (Array<File>): An array of files you want to upload.\n  - `chunkSize` (number, optional): Defines the chunk size. Defaults to 1500.\n  - `chunkOverlap` (number, optional): Defines the chunk overlap. Defaults to 20.\n  - `skipEmbeddingGeneration` (boolean, optional): If set to true, embedding generation will be skipped. Defaults to false.\n\n- **Returns**: A promise that resolves to an UploadFilesResponse object:\n\n  - `status` (number): The HTTP status code of the response.\n  - `data` (object): Contains details of the uploaded files, including count and array of successful uploads.\n  - `error` (object or null): Contains error details if there's an issue during file upload.\n\n- **Usage**:\n\n  ```javascript\n  import * as Carbon from 'carbon-connect-js';\n\n  async function uploadFilesToPlatform() {\n    try {\n      const response = await Carbon.uploadFilesToCarbon({\n        accessToken: 'YOUR_ACCESS_TOKEN',\n        files: filesToUploadArray,\n        // You can also specify other parameters here if needed.\n      });\n\n      if (response.status === 200) {\n        console.log('Uploaded Files:', response.data.successfulUploads);\n        if (response.error) {\n          console.warn('Failed Uploads:', response.error.failedUploads);\n        }\n      } else {\n        console.error('Error:', response.error.message);\n      }\n    } catch (err) {\n      console.error('Unexpected error:', err.message);\n    }\n  }\n\n  uploadFilesToPlatform();\n  ```\n\n### 6. updateTags()\n\n- **Description**: Updates or appends tags to a specified file in Carbon.\n\n- **Parameters**:\n\n  - `accessToken` (string): The access token obtained through authentication.\n  - `fileId` (int): The ID of the file you want to update tags for.\n  - `tags` (object): The tags you want to add or update for the specified file.\n\n- **Returns**: A promise that resolves to an `UpdateTagsResponse` object:\n\n  - `status` (number): The HTTP status code of the response.\n  - `data` (object): Contains details of the updated file, including the file ID and updated tags.\n  - `error` (object or null): Contains error details if there's an issue updating the tags.\n\n- **Usage**:\n\n  ```javascript\n  import * as Carbon from 'carbon-connect-js';\n\n  async function updateFileTags() {\n    const fileId = 'YOUR_FILE_ID'; // Replace with your actual file ID\n    const tagsToUpdate = {\n      category: 'document',\n      type: 'pdf',\n      // ... add more tags as needed\n    };\n\n    try {\n      const response = await Carbon.updateTags({\n        accessToken: 'YOUR_ACCESS_TOKEN',\n        fileId: fileId,\n        tags: tagsToUpdate,\n      });\n\n      if (response.status === 200) {\n        console.log('Updated Tags:', response.data);\n      } else {\n        console.error('Error:', response.error);\n      }\n    } catch (err) {\n      console.error('Unexpected error:', err.message);\n    }\n  }\n\n  updateFileTags();\n  ```\n\n### 7. processSitemapUrl()\n\n- **Description**: Fetches and processes the URLs present in a specified sitemap.\n\n- **Parameters**: The `processSitemapUrl()` method accepts an object with the following properties:\n\n  - `accessToken` (string): The access token obtained through authentication.\n  - `sitemapUrl` (string): The URL of the sitemap to be fetched.\n\n- **Returns**: A promise that resolves to a `ProcessSitemapUrlResponse` object:\n\n  - `status` (number): The HTTP status code of the response.\n  - `data` (object): Contains details of the fetched URLs.\n    - `urls` (array): An array of URLs retrieved from the sitemap.\n    - `count` (number): Total number of URLs retrieved from the sitemap.\n  - `error` (string or null): Error message if there's an issue fetching the sitemap.\n\n- **Usage**:\n\n  ```javascript\n  import * as Carbon from 'carbon-connect-js';\n\n  async function fetchSitemapUrls() {\n    const sitemap = 'YOUR_SITEMAP_URL'; // Replace with your actual sitemap URL\n\n    try {\n      const response = await Carbon.handleFetchSitemapUrls({\n        accessToken: 'ACCESS_TOKEN',\n        sitemapUrl: sitemap,\n      });\n\n      if (response.status === 200) {\n        console.log('Retrieved URLs:', response.data.urls);\n        console.log('Total URLs:', response.data.count);\n      } else {\n        console.error('Error:', response.error);\n      }\n    } catch (err) {\n      console.error('Unexpected error:', err.message);\n    }\n  }\n\n  fetchSitemapUrls();\n  ```\n\n### 8. submitScrapeRequest()\n\n- **Description**: Initiates a scraping request for specified URLs. This function supports batch scraping and can take multiple URLs in a single request.\n\n- **Parameters**: The `submitScrapeRequest()` method accepts an object with the following properties:\n\n  - `accessToken` (string): The access token obtained through authentication.\n  - `urls` (array of strings): An array of URLs you want to scrape.\n  - `tags` (object, optional): Tags associated with the scraping request. Defaults to an empty object.\n  - `recursionDepth` (number, optional): Specifies the depth of scraping for linked pages. Defaults to 1.\n  - `maxPagesToScrape` (number, optional): Maximum number of pages to scrape per URL. Defaults to 1.\n  - `chunkSize` (number, optional): Size of data chunks. Defaults to 1500.\n  - `chunkOverlap` (number, optional): Overlapping size between chunks. Defaults to 20.\n  - `skipEmbeddingGeneration` (boolean, optional): Indicates whether to skip embedding generation during scraping. Defaults to false.\n\n- **Returns**: A promise that resolves to a `SubmitScrapeRequestResponse` object:\n\n  - `status` (number): The HTTP status code of the response.\n  - `data` (object): Contains details of the scraping response.\n    - `files` (array): An array of objects, each representing a file resulting from the scraping process.\n  - `error` (string or null): Error message if there's an issue initiating the scraping.\n\n- **Usage**:\n\n  ```javascript\n  import * as Carbon from 'carbon-connect-js';\n\n  async function initiateScraping() {\n    const urlsToScrape = ['URL_1', 'URL_2']; // Replace with your actual URLs\n\n    try {\n      const response = await Carbon.submitScrapeRequest({\n        accessToken: 'YOUR_ACCESS_TOKEN',\n        urls: urlsToScrape,\n        recursionDepth: 2,\n        maxPagesToScrape: 5,\n      });\n\n      if (response.status === 200) {\n        console.log('Scraping result:', response.data.files);\n      } else {\n        console.error('Error:', response.error);\n      }\n    } catch (err) {\n      console.error('Unexpected error:', err.message);\n    }\n  }\n\n  initiateScraping();\n  ```\n\n### 9. getCarbonHealth()\n\n- **Description**: This function retrieves the health status of the Carbon service.\n\n- **Parameters**: The `getCarbonHealth()` method does not require any parameters.\n\n- **Returns**: A promise that resolves to a `getCarbonHealthResponse` object:\n\n  - status (number): An HTTP status code indicating the health status. A status code of 200 indicates that the service is in a healthy state.\n\n- **Usage**: Below is an example of how to utilize the `getCarbonHealth()` method\n\n  ```javascript\n  import * as Carbon from 'carbon-connect-js';\n\n  async function fetchCarbonHealth() {\n    try {\n      const response = await Carbon.getCarbonHealth();\n\n      if (response.status === 200) {\n        console.log('Carbon service is healthy.');\n      } else {\n        console.error(\n          'Carbon service is currently unavailable:',\n          response.status\n        );\n      }\n    } catch (err) {\n      console.error(\n        'Unexpected error while checking Carbon health:',\n        err.message\n      );\n    }\n  }\n\n  fetchCarbonHealth();\n  ```\n\n### 10. uploadFileFromUrl()\n\n- **Description**: This function allows you to upload a file to the Carbon service by fetching it from a specified URL.\n\n- **Parameters**: The `uploadFileFromUrl()` method requires an object with the following properties:\n\n  - `accessToken` (string): The access token obtained through authentication.\n  - `url` (string): The URL from which the file should be retrieved and uploaded.\n  - `fileName` (string, optional): A custom name for the file. If not specified, the original filename from the URL will be used.\n  - `chunkSize` (number, optional): The size of data chunks during the upload process. Default is set to 1500.\n  - `chunkOverlap` (number, optional): The overlap size between chunks. Default is set to 20.\n  - `skipEmbeddingGeneration` (boolean, optional): Indicates whether to skip embedding generation during the upload. Default is set to false.\n\n- **Returns**: A promise that resolves to an `UploadFileFromUrlResponse` object with the following properties:\n\n  - `status` (number): The HTTP status code of the response.\n  - `data` (object or null): Contains details of the uploaded file.\n    - `file` (object): Represents the uploaded file and all its properties.\n  - `error` (string or null): An error message, if there's an issue with the upload.\n\n- **Usage**: Below is an example of how to use the `uploadFileFromUrl()` method\n\n  ```javascript\n  import * as Carbon from 'carbon-connect-js';\n\n  async function uploadFromUrl() {\n    const fileUrl = 'URL_TO_THE_FILE'; // Replace with the actual URL\n\n    try {\n      const response = await Carbon.uploadFileFromUrl({\n        accessToken: 'YOUR_ACCESS_TOKEN',\n        url: fileUrl,\n        fileName: 'custom_file_name.ext',\n      });\n\n      if (response.status === 200) {\n        console.log('Uploaded file details:', response.data.file);\n      } else {\n        console.error('Error:', response.error);\n      }\n    } catch (err) {\n      console.error('Unexpected error during upload:', err.message);\n    }\n  }\n\n  uploadFromUrl();\n  ```\n\n### 11. uploadText()\n\n- **Description**: This function enables the uploading of textual content to the Carbon service.\n\n- **Parameters**: The `uploadText()` method requires an object with the following properties:\n\n  - `accessToken` (string): The access token obtained through authentication.\n  - `contents` (string): The text content you wish to upload.\n  - `fileName` (string, optional): A custom name for the file. If not specified, a random name will be used.\n  - `chunkSize` (number, optional): The size of data chunks during the upload process. The default value is 1500.\n  - `chunkOverlap` (number, optional): The overlapping size between chunks. The default value is 20.\n  - `skipEmbeddingGeneration` (boolean, optional): An indicator of whether to skip embedding generation during the upload. The default is set to false.\n  - `overWriteFileId` (number or null, optional): If provided, the uploaded content will overwrite an existing file with the specified ID.\n\n- **Returns**: A promise that resolves to an `UploadTextResponse` object containing the following properties:\n\n  - `status` (number): The HTTP status code of the response.\n  - `data` (object or null): Contains details of the uploaded file.\n    - `file` (object): Represents the uploaded file along with its properties.\n  - `error` (string or null): An error message in case of an issue during the upload.\n\n- **Usage**: Below is an example of how to utilize the `uploadText()` method\n\n  ```javascript\n  import * as Carbon from 'carbon-connect-js';\n\n  async function uploadCustomText() {\n    const textContent = 'This is a sample text content for upload.';\n\n    try {\n      const response = await Carbon.uploadText({\n        accessToken: 'YOUR_ACCESS_TOKEN',\n        contents: textContent,\n        fileName: 'sample_text.txt',\n      });\n\n      if (response.status === 200) {\n        console.log('Uploaded file details:', response.data.file);\n      } else {\n        console.error('Error:', response.error);\n      }\n    } catch (err) {\n      console.error('Unexpected error during upload:', err.message);\n    }\n  }\n\n  uploadCustomText();\n  ```\n\n### 12. deleteFile()\n\n- **Description**: This function allows for the removal of a specified file from the Carbon service.\n\n- **Parameters**: The `deleteFile()` method requires an object with the following properties:\n\n  - `accessToken` (string): The access token obtained through authentication.\n  - `fileId` (string): The ID of the file you intend to delete.\n\n- **Returns**: A promise that resolves to an `DeleteFileResponse` object containing the following properties:\n\n  - `status` (number): The HTTP status code of the response.\n  - `data` (object or null): Contains details of the deleted file or any additional response data.\n  - `error` (string or null): An error message in case there is an issue with the file deletion.\n\n- **Usage**:\n\n  ```javascript\n  import * as Carbon from 'carbon-connect-js';\n\n  async function removeFile() {\n    const targetFileId = 'YOUR_FILE_ID_HERE';\n\n    try {\n      const response = await Carbon.deleteFile({\n        accessToken: 'YOUR_ACCESS_TOKEN',\n        fileId: targetFileId,\n      });\n\n      if (response.status === 200) {\n        console.log('File successfully deleted:', response.data);\n      } else {\n        console.error('Error:', response.error);\n      }\n    } catch (err) {\n      console.error('Unexpected error during file deletion:', err.message);\n    }\n  }\n\n  removeFile();\n  ```\n\n### 13. resyncFile()\n\n- **Description**: This function triggers a resynchronization of a specified file with the Carbon service. This can be valuable in scenarios where a file's internal data changes or if there are discrepancies in the data on the server.\n\n- **Parameters**: The `resyncFile()` method requires an object with the following properties:\n\n  - `accessToken` (string): The access token obtained through authentication.\n  - `fileId` (string): The ID of the file you wish to resynchronize.\n  - `chunkSize` (number, optional, default 1500): Specifies the chunk size when processing the file.\n  - `chunkOverlap` (number, optional, default 20): Specifies the overlap size between each chunk.\n\n- **Returns**: A promise that resolves to an `ResyncFileResponse` object with the following properties:\n\n  - `status` (number): The HTTP status code of the response.\n  - `data` (object or null): The response data, containing the access token if the request was successful; otherwise, it is null.\n  - `error` (string or null): An error message if there was an issue generating the token, otherwise null.\n\n- **Usage**:\n\n  ```javascript\n  import * as Carbon from 'carbon-connect-js';\n\n  async function resynchronizeFile() {\n    const targetFileId = 'YOUR_FILE_ID_HERE';\n\n    try {\n      const response = await Carbon.resyncFile({\n        accessToken: 'YOUR_ACCESS_TOKEN',\n        fileId: targetFileId,\n        chunkSize: 1600, // Optional. Default is 1500.\n        chunkOverlap: 25, // Optional. Default is 20.\n      });\n\n      if (response.status === 200) {\n        console.log('File successfully resynced:', response.data);\n      } else {\n        console.error('Error:', response.error);\n      }\n    } catch (err) {\n      console.error('Unexpected error during file resync:', err.message);\n    }\n  }\n\n  resynchronizeFile();\n  ```\n\n### 14. getRawFilePresignedUrl()\n\n- **Description**: This function retrieves a presigned URL that can be utilized to directly access the unprocessed content of a file stored within the Carbon service.\n\n- **Parameters**: The `getRawFilePresignedUrl()` method requires an object with the following properties:\n\n  - `accessToken` (string): The access token obtained through authentication.\n  - `fileId` (string): The ID of the file for which you seek to obtain the presigned URL.\n\n- **Returns**: A promise that resolves to an `GetRawFilePresignedUrlResponse` object comprising the following properties:\n\n  - `status` (number): The HTTP status code of the response.\n  - `data` (object or null):\n    - `presigned_url` (string): The presigned URL that can be used to access the raw file content.\n  - `error` (string or null): An error message if there is an issue with fetching the presigned URL.\n\n- **Usage**:\n\n  ```javascript\n  import * as Carbon from 'carbon-connect-js';\n\n  async function fetchPresignedUrl() {\n    const targetFileId = 'YOUR_FILE_ID_HERE';\n\n    try {\n      const response = await Carbon.getRawFilePresignedUrl({\n        accessToken: 'YOUR_ACCESS_TOKEN',\n        fileId: targetFileId,\n      });\n\n      if (response.status === 200) {\n        console.log('Presigned URL:', response.data.presigned_url);\n      } else {\n        console.error('Error:', response.error);\n      }\n    } catch (err) {\n      console.error('Unexpected error fetching presigned URL:', err.message);\n    }\n  }\n\n  fetchPresignedUrl();\n  ```\n\n### 15. getParsedFilePresignedUrl()\n\n- **Description**: This function retrieves a presigned URL that can be employed to directly access the parsed content of a file stored within the Carbon service.\n\n- **Parameters**: The `getParsedFilePresignedUrl()` method requires an object with the following properties:\n\n  - `accessToken` (string): The access token obtained through authentication.\n  - `fileId` (string): The ID of the file for which you desire the presigned URL.\n\n- **Returns**: A promise that resolves to an `GetParsedFilePresignedUrlResponse` object containing the following properties:\n\n  - `status` (number): The HTTP status code of the response.\n  - `data` (object or null):\n    - `presigned_url` (string): The presigned URL that enables access to the parsed file content.\n  - `error` (string or null): An error message in the event of any issues with obtaining the presigned URL.\n\n- **Usage**:\n\n  ```javascript\n  import * as Carbon from 'carbon-connect-js';\n\n  async function fetchParsedPresignedUrl() {\n    const targetFileId = 'YOUR_FILE_ID_HERE';\n\n    try {\n      const response = await Carbon.getParsedFilePresignedUrl({\n        accessToken: 'YOUR_ACCESS_TOKEN',\n        fileId: targetFileId,\n      });\n\n      if (response.status === 200) {\n        console.log(\n          'Presigned URL for parsed content:',\n          response.data.presigned_url\n        );\n      } else {\n        console.error('Error:', response.error);\n      }\n    } catch (err) {\n      console.error(\n        'Unexpected error fetching presigned URL for parsed content:',\n        err.message\n      );\n    }\n  }\n\n  fetchParsedPresignedUrl();\n  ```\n\n### 16. getUserFiles()\n\n- **Description**: This function retrieves a list of user files from the Carbon service based on specified filters.\n\n- **Parameters**: The `getUserFiles()` method accepts an object with the following properties:\n\n  - `accessToken` (string): The access token obtained through authentication.\n  - `limit` (number, optional, default = 10): The maximum number of files to be returned.\n  - `offset` (number, optional, default = 0): The starting point from which to fetch files.\n  - `order_by` (string, optional, default = 'updated_at'): The attribute by which the returned files are ordered.\n  - `order_dir` (string, optional, default = 'asc'):The direction in which the files are ordered. Options are 'asc' or 'desc'.\n  - `filters` (Record<string, any>, optional, default = {}): An object of filters to apply to the file list query.\n  - `include_raw_file` (boolean, optional, default = false): If set to true, includes the presigned URL for the raw file in the response.\n  - `include_parsed_file` (boolean, optional, default = false): If set to true, includes the presigned URL for the parsed file in the response.\n\n- **Returns**: A promise that resolves to an `GetUserFilesResponse` object with the following properties:\n\n  - status (number): The HTTP status code of the response.\n  - data (object or null):\n    - files (any[]): An array of user file data objects.\n  - error (string or null): An error message if there are issues with fetching user files.\n\n- **Usage**:\n\n  ```javascript\n  import * as Carbon from 'carbon-connect-js';\n\n  async function fetchUserFiles() {\n    const params = {\n      accessToken: 'YOUR_ACCESS_TOKEN',\n      limit: 5,\n      order_by: 'created_at',\n      order_dir: 'desc',\n    };\n\n    try {\n      const response = await Carbon.getUserFiles(params);\n\n      if (response.status === 200) {\n        console.log('Fetched user files:', response.data.files);\n      } else {\n        console.error('Error:', response.error);\n      }\n    } catch (err) {\n      console.error('Unexpected error fetching user files:', err.message);\n    }\n  }\n\n  fetchUserFiles();\n  ```\n\n### 17. deleteTags()\n\n- **Description**: This function removes specified tags from a user file within the given organization. The method sends a request to the Carbon service to delete the provided tags from the file associated with the `organizationUserFileId`.\n\n- **Parameters**: The `deleteTags()` method requires an object with the following properties:\n\n  - `accessToken` (string): The access token obtained through authentication.\n  - `organizationUserFileId` (number): The unique identifier of the user file within the organization.\n  - `tags` (string[]): An array of tag names to be deleted from the user file.\n\n- **Returns**: A promise that resolves to an `DeleteTagsResponse` object with the following properties:\n\n  - `status` (number): The HTTP status code of the response.\n  - `data` (object or null): The response data received from the Carbon service after the tags have been deleted.\n  - `error` (string or null): An error message in case there are issues with the deletion of tags from the user file.\n\n- **Usage**: Below is an example of how to use the `generateAccessToken()` method\n\n  ```javascript\n  const Carbon = require('carbon-connect-js');\n\n  async function fetchAccessToken() {\n    try {\n      const response = await Carbon.generateAccessToken({\n        apiKey: 'your_api_key',\n        customerId: 'your_customer_id',\n      });\n\n      if (response.status === 200) {\n        console.log('Access token:', response.data);\n      } else {\n        console.error('Error:', response.error);\n      }\n    } catch (err) {\n      console.error('Unexpected error:', err);\n    }\n  }\n\n  fetchAccessToken();\n  ```\n\n### 18. fetchUrls()\n\n- **Description**: This method retrieves all URLs from a specified web page. It initiates a GET request to the Carbon service with the target URL as a parameter. The Carbon service will then access the content of the specified web page and parse it to extract all the URLs.\n\n- **Parameters**: The `fetchUrls()` method requires an object with the following properties:\n\n  - `accessToken` (string): The access token obtained through authentication.\n  - `url` (string): The URL of the web page from which the links should be fetched.\n\n- **Returns**: A promise that resolves to an `AccessTokenResponse` object comprising the following properties:\n\n  - status (number): The HTTP status code of the response.\n  - data (object or null): The response data object containing the extracted URLs and potentially the raw HTML content.\n    - urls (string[]): A list of URLs extracted from the web page.\n    - html_content (string or null): The raw HTML content of the fetched web page (if provided by the Carbon service).\n  - error (string or null): An error message in case there are issues with fetching the URLs.\n\n- **Usage**:\n\n  ```javascript\n  import * as Carbon from 'carbon-connect-js';\n\n  async function retrieveUrls() {\n    const params = {\n      accessToken: 'YOUR_ACCESS_TOKEN',\n      url: 'https://www.example.com', // replace with actual URL\n    };\n\n    try {\n      const response = await Carbon.fetchUrls(params);\n\n      if (response.status === 200) {\n        console.log('Fetched URLs successfully:', response.data.urls);\n      } else {\n        console.error('Error:', response.error);\n      }\n    } catch (err) {\n      console.error('Unexpected error fetching URLs:', err.message);\n    }\n  }\n\n  retrieveUrls();\n  ```\n\n### 19. searchUrls()\n\n- **Description**: This method conducts a search for URLs based on the provided query string.\n\n  As an illustration, when you perform a search for “content related to MRNA,” you will receive a list of links such as the following:\n\n  - https://tomrenz.substack.com/p/mrna-and-why-it-matters\n  - https://www.statnews.com/2020/11/10/the-story-of-mrna-how-a-once-dismissed-idea-became-a-leading-technology-in-the-covid-vaccine-race/\n  - https://www.statnews.com/2022/11/16/covid-19-vaccines-were-a-success-but-mrna-still-has-a-delivery-problem/\n  - https://joomi.substack.com/p/were-still-being-misled-about-how\n\n  Subsequently, you can submit these links to the `web_scrape` endpoint in order to retrieve the content of the respective web pages.\n\n- **Parameters**: The `searchUrls()` method accepts an object with the following properties:\n\n  - `accessToken` (string): The access token obtained through authentication.\n  - `query` (string): The search term or query for which URLs are to be discovered.\n\n- **Returns**: A promise that resolves to an `SearchUrlsForQueryResponse` object with the following properties:\n\n  - `status` (number): The HTTP status code of the response.\n  - `data` (object or null): The response data object containing the discovered URLs.\n    - `urls` (string[]): A list of URLs associated with the search query.\n    - `html_content` (null): A null value is returned.\n  - `error` (string or null): An error message if there are any issues with the URL search.\n\n- **Usage**:\n\n  ```javascript\n  import * as Carbon from 'carbon-connect-js';\n\n  async function retrieveSearchResults() {\n    const params = {\n      accessToken: 'YOUR_ACCESS_TOKEN',\n      query: 'example search term', // replace with actual query\n    };\n\n    try {\n      const response = await Carbon.searchUrls(params);\n\n      if (response.status === 200) {\n        console.log('Search results:', response.data.urls);\n      } else {\n        console.error('Error:', response.error);\n      }\n    } catch (err) {\n      console.error('Unexpected error during search:', err.message);\n    }\n  }\n\n  retrieveSearchResults();\n  ```\n\n### 20. fetchYoutubeTranscript()\n\n- **Description**: This method retrieves the transcript for a specific YouTube video.\n\n  **Example:** In the URL https://www.youtube.com/watch?v=_Nq2m5LRQ3g&t=1080s, the video id is `_Nq2m5LRQ3`\n\n- **Parameters**: The `fetchYoutubeTranscript()` method accepts an object with the following properties:\n\n  - `accessToken` (string): The access token obtained through authentication.\n  - `videoId` (string): The unique identifier of the YouTube video.\n  - `raw` (boolean, optional): A flag indicating whether to fetch the raw transcript (default is false, indicating that only the processed transcript is fetched).\n\n- **Returns**: A promise that resolves to an `FetchYoutubeTranscriptsResponse` object with the following properties:\n\n  - `status` (number): The HTTP status code of the response.\n  - `data` (object or null): The response data object containing the transcript information.\n  - `error` (string or null): An error message if there are any issues with fetching the transcript.\n\n- **Usage**:\n\n  ```javascript\n  import * as Carbon from 'carbon-connect-js';\n\n  async function retrieveTranscript() {\n    const params = {\n      accessToken: 'YOUR_ACCESS_TOKEN',\n      videoId: 'YOUR_YOUTUBE_VIDEO_ID',\n      raw: true,\n    };\n\n    try {\n      const response = await Carbon.fetchYoutubeTranscript(params);\n\n      if (response.status === 200) {\n        console.log('Transcript data:', response.data);\n      } else {\n        console.error('Error:', response.error);\n      }\n    } catch (err) {\n      console.error('Unexpected error during transcript fetch:', err.message);\n    }\n  }\n\n  retrieveTranscript();\n  ```\n\n### 21. getEmbeddingsfetchUrls()\n\n- **Description**: This method is utilized to retrieve embeddings based on a provided query.\n\n- **Parameters**: The `getEmbeddings()` method accepts an object with the following properties:\n\n  - `accessToken` (string): The access token obtained through authentication.\n  - `query` (string): The search query.\n  - `queryVector` (number[] or null, optional): The query vector.\n  - `k` (number): The number of nearest embeddings to retrieve.\n  - `filesIds` (number[] or null, optional): An array of file IDs.\n  - `parentFileIds` (number[] or null, optional): An array of parent file IDs.\n  - `tags` (Record<string, any> or null, optional): Tags associated with the embeddings.\n  - `includeTags` (boolean or null, optional): A flag to include tags.\n  - `includeVectors` (boolean or null, optional): A flag to include vectors.\n  - `includeRawFile` (boolean or null, optional): A flag to include raw file.\n  - `hybridSearch` (boolean or null, optional): A flag to indicate hybrid search.\n  - `hybridSearchTuningParameters` (HybridSearchParams or null, optional): Parameters for fine-tuning hybrid search. The following properties are available:\n    - `weightA`\n    - `weightB`\n\n- **Returns**: A promise that resolves to an `GetEmbeddingsResponse` object with the following properties:\n\n  - `status` (number): The HTTP status code of the response.\n  - `data` (object or null): The response data containing the embeddings information.\n  - `error` (string or null): An error message if there's an issue fetching the embeddings.\n\n- **Usage**:\n\n  ```javascript\n  import * as Carbon from 'carbon-connect-js';\n\n  async function retrieveEmbeddings() {\n    const params = {\n      accessToken: 'YOUR_ACCESS_TOKEN',\n      query: 'YOUR_SEARCH_QUERY',\n      k: 5, // Example: retrieve 5 nearest embeddings.\n      // Add other parameters as needed\n    };\n\n    try {\n      const response = await Carbon.getEmbeddings(params);\n\n      if (response.status === 200) {\n        console.log('Embeddings data:', response.data);\n      } else {\n        console.error('Error:', response.error);\n      }\n    } catch (err) {\n      console.error('Unexpected error during embeddings fetch:', err.message);\n    }\n  }\n\n  retrieveEmbeddings();\n  ```\n\n### 22. getTextChunks()\n\n- **Description**: This method fetches text chunks based on the specified user file ID and other optional parameters.\n\n- **Parameters**: The `getTextChunks()` method accepts an object with the following properties:\n\n  - `accessToken` (string): The access token obtained through authentication.\n  - `userFileId` (number): ID of the user file for which text chunks are being fetched.\n  - `limit` (number, optional): Maximum number of text chunks to retrieve. Defaults to 10.\n  - `offset` (number, optional): The number to start the fetch from. Useful for pagination. Defaults to 0.\n  - `orderBy` (string, optional): The column name to order the results by. Defaults to 'updated_at'.\n  - `orderDir` (string, optional): Direction of the order ('asc' or 'desc'). Defaults to 'asc'.\n  - `includeVectors` (boolean, optional): Flag to indicate whether to include vectors in the response. Defaults to false.\n\n- **Returns**: A promise that resolves to an `GetTextChunksResponse` object with the following properties:\n\n  - `status` (number): The HTTP status code of the response.\n  - `data` (object or null): The response data containing the text chunks information.\n  - `error` (string or null): Error message if there's an issue fetching the text chunks.\n\n- **Usage**:\n\n  ```javascript\n  import * as Carbon from 'carbon-connect-js';\n\n  async function retrieveTextChunks() {\n    const params = {\n      accessToken: 'YOUR_ACCESS_TOKEN',\n      userFileId: 12345, // Replace with actual user file ID.\n      limit: 5, // Example: retrieve 5 text chunks.\n      // Add other parameters as needed\n    };\n\n    try {\n      const response = await Carbon.getTextChunks(params);\n\n      if (response.status === 200) {\n        console.log('Text chunks data:', response.data);\n      } else {\n        console.error('Error:', response.error);\n      }\n    } catch (err) {\n      console.error('Unexpected error during text chunks fetch:', err.message);\n    }\n  }\n\n  retrieveTextChunks();\n  ```\n\n### 23. getUserDataSources()\n\n- **Description**: This method retrieves user data sources based on the provided parameters.\n\n- **Parameters**: The `getUserDataSources()` method accepts an object with the following properties:\n\n  - `accessToken` (string): The access token obtained through authentication.\n  - `limit` (number, optional): The maximum number of data sources to retrieve. Defaults to 10.\n  - `offset` (number, optional): The starting point for the fetch, useful for pagination. Defaults to 0.\n  - `orderBy` (string, optional): The column name to order the results by. Defaults to 'updated_at'.\n  - `orderDir` (string, optional): The direction of the order ('asc' or 'desc'). Defaults to 'asc'.\n  - `sourceType` (string, optional): The type of data source to filter the results by.\n  - `sourceIds` (number[] or null, optional): An array of specific data source IDs to retrieve.\n  - `revokedAccess` (boolean or null, optional): A flag to filter data sources based on revoked access.\n\n- **Returns**: A promise that resolves to an `AccessTokenResponse` object with the following properties:\n\n  - status (number): The HTTP status code of the response.\n  - data (object or null): The response data containing user data sources information.\n  - error (string or null): An error message if there's an issue fetching the user data sources.\n\n- **Usage**:\n\n  ```javascript\n  import * as Carbon from 'carbon-connect-js';\n\n  async function retrieveUserDataSources() {\n    const params = {\n      accessToken: 'YOUR_ACCESS_TOKEN',\n      limit: 5, // Example: retrieve 5 data sources.\n      // Add other parameters as needed\n    };\n\n    try {\n      const response = await Carbon.getUserDataSources(params);\n\n      if (response.status === 200) {\n        console.log('User data sources data:', response.data);\n      } else {\n        console.error('Error:', response.error);\n      }\n    } catch (err) {\n      console.error(\n        'Unexpected error during user data sources fetch:',\n        err.message\n      );\n    }\n  }\n\n  retrieveUserDataSources();\n  ```\n\n### 24. revokeAccessToDataSource()\n\n- **Description**: This method revokes user access to a specified data source. The user will need to re-authenticate after access is revoked.\n\n- **Parameters**: The `revokeAccessToDataSource()` method accepts an object with the following properties:\n\n  - `accessToken` (string): The access token obtained through authentication.\n  - `dataSourceId` (number): The ID of the data source for which access should be revoked.\n\n- **Returns**: A promise that resolves to an `RevokeAccessToDataSourceResponse` object with the following properties:\n\n  - `status` (number): The HTTP status code of the response.\n  - `data` (object or null): The response data indicating the outcome of the access revocation request.\n  - `error` (string or null): An error message if there are any issues with revoking access to the data source.\n\n- **Usage**:\n\n  ```javascript\n  import * as Carbon from 'carbon-connect-js';\n\n  async function revokeDataSourceAccess() {\n    const params = {\n      accessToken: 'YOUR_ACCESS_TOKEN',\n      dataSourceId: 12345, // Example: data source ID to revoke access to.\n    };\n\n    try {\n      const response = await Carbon.revokeAccessToDataSource(params);\n\n      if (response.status === 200) {\n        console.log('Successfully revoked access:', response.data);\n      } else {\n        console.error('Error:', response.error);\n      }\n    } catch (err) {\n      console.error('Unexpected error during access revocation:', err.message);\n    }\n  }\n\n  revokeDataSourceAccess();\n  ```\n\n# Prebuilt Component\n\n---\n\n## Installation\n\n---\n\nTo install Carbon Connect as a prebuilt React component, use npm as follows:\n\n```bash\nnpm install carbon-connect\n```\n\n## Prerequisites\n\n---\n\nThe package expects the following npm packages to be installed in your project:\n\n1. `@radix-ui/react-dialog`\n2. `\"lodash\": \"^4.17.21`\n3. `react`\n4. `react-dom`\n5. `react-drag-drop-files`\n6. `react-icons`\n7. `react-toastify`\n8. `tailwindcss`\n\nPlease check for the versions from `package.json` if you encounter a version mismatch error.\n\n## Component Properties\n\n---\n\nThe `CarbonConnect` component accepts the following properties:\n\n| Property                   | Type            | Required? | Description                                                                                                             |\n| -------------------------- | --------------- | --------- | ----------------------------------------------------------------------------------------------------------------------- |\n| `brandIcon`                | String          | Yes       | A URL or a local path to your organization's brand icon.                                                                |\n| `orgName`                  | String          | Yes       | The name of your organization. This is displayed in the initial announcement modal view.                                |\n| `tokenFetcher`             | Function        | Yes       | A function that returns a promise which resolves with the access and refresh tokens.                                    |\n| `onSuccess`                | Function        | No        | A callback function that will be called after the file upload is successful.                                            |\n| `onError`                  | Function        | No        | A callback function that will be called if there is any error in the file upload.                                       |\n| `children`                 | React Node(JSX) | No        | You can pass any valid React node that will be used as a trigger to open the component.                                 |\n| `entryPoint`               | String          | No        | The initial active step when the component loads. Default entry point is 'LOCAL_FILES'. More integrations are upcoming. |\n| `maxFileSize`              | Number          | No        | Maximum file size in bytes that is allowed to be uploaded. Defaults to 10 MB                                            |\n| `tags`                     | Object          | No        | Any additional data you want to associate with the component's state, such as an app ID.                                |\n| `enabledIntegrations`      | dict            | No        | Let's you choose which 3rd party integrations to show. See below for more details about this prop                       |\n| `primaryBackgroundColor`   | String          | No        | The primary background color of the component. Defaults to `#000000`.                                                   |\n| `primaryTextColor`         | String          | No        | The primary text color of the component. Defaults to `#FFFFFF`.                                                         |\n| `secondaryBackgroundColor` | String          | No        | The secondary background color of the component. Defaults to `#FFFFFF`.                                                 |\n| `secondaryTextColor`       | String          | No        | The secondary text color of the component. Defaults to `#000000`.                                                       |\n| `allowMultipleFiles`       | Boolean         | No        | Whether or not to allow multiple files to be uploaded at once. Defaults to `false`.                                     |\n| `chunkSize`                | Number          | No        | The no.of tokens per chunk. Defaults to 1500.                                                                           |\n| `overlapSize`              | Number          | No        | The no.of tokens to overlap between chunks. Defaults to 20.                                                             |\n| `open`                     | Boolean         | No        | Whether or not to open the component. Defaults to `false`.                                                              |\n| `setOpen`                  | Function        | No        | A function that will be called to set the open state of the component. Defaults to `None`.                              |\n| `alwaysOpen`               | Boolean         | No        | Whether or not to always keep the component open. Defaults to `false`.                                                  |\n| `tosURL`                   | String          | No        | A URL to your organization's terms of service. Defaults to `https://carbon.ai/terms`.                                   |\n| `privacyPolicyURL`         | String          | No        | A URL to your organization's privacy policy. Defaults to `https://carbon.ai/privacy`.                                   |\n| `navigateBackURL`          | String          | No        | A URL to your intended destination. Defaults to `None`.                                                                 |\n| `backButtonText`           | String          | No        | The label that you want to show on the back button. Defaults to `Go back`                                               |\n\nWhen you do not pass `open` or `setOpen`, CC will manage the open state internally. If you pass `open` and `setOpen`, you will have to manage the open state yourself.\n\n### Note about Google Drive\n\nOur oAuth app is in approval phase. your users will see a warning message when they try to connect their Google account. Please ignore the warning and proceed to connect your account. We will update this section once our app is approved.\n\n## Usage\n\n---\n\nThis section demonstrates how to integrate the CarbonConnect component within a Next.js project.\n\n### Client Side Configuration\n\n1. Import necessary libraries and components:\n\n```jsx\nimport { CarbonConnect } from 'carbon-connect';\nimport axios from 'axios';\n```\n\n2. Token Retrieval:\n  The tokenFetcher function is set up to request access tokens from Carbon directly via your backend:\n\n```js\nconst tokenFetcher = async () => {\n  const response = await axios.get('/api/auth/fetchCarbonTokens', {\n    params: { customer_id: 'your_customer_id' },\n  });\n  return response.data; // Must return data containing access_token\n};\n```\n  In the example above, tokenFetcher is a helper function that retrieves the necessary tokens for authentication. This function should be implemented in your client-side code and is designed to make a request to an API on your backend server. The API then requests tokens from the Carbon token creation endpoint. The Carbon token creation endpoint is a secure endpoint that requires a valid API key and customer ID. The customer ID is a unique identifier for your end-user, and you can pass any string as the customer ID. The API key is a secret key provided to you by Carbon. Please contact us to obtain your API key.\n\n3. Implement CarbonConnect Component:\n   Here's a concise usage example. Customize according to your requirements:\n\n```jsx\n<CarbonConnect\n  orgName=\"Your Organization\"\n  brandIcon=\"path/to/your/brand/icon\"\n  tokenFetcher={tokenFetcher}\n  tags={{\n    tag1: 'tag1_value',\n    tag2: 'tag2_value',\n    tag3: 'tag3_value',\n  }}\n  maxFileSize={10000000}\n  enabledIntegrations={[\n    {\n      id: 'LOCAL_FILES',\n      chunkSize: 100,\n      overlapSize: 10,\n      maxFileSize: 20000000,\n      allowMultipleFiles: true,\n      maxFilesCount: 5,\n      allowedFileTypes: [\n        {\n          extension: 'csv',\n          chunkSize: 1200,\n          overlapSize: 120,\n        },\n        {\n          extension: 'txt',\n          chunkSize: 1599,\n          overlapSize: 210,\n        },\n        {\n          extension: 'pdf',\n        },\n      ],\n    },\n    {\n      id: 'NOTION',\n      chunkSize: 1500,\n      overlapSize: 20,\n    },\n    {\n      id: 'WEB_SCRAPER',\n      chunkSize: 1500,\n      overlapSize: 20,\n    },\n    {\n      id: 'GOOGLE_DRIVE',\n      chunkSize: 1000,\n      overlapSize: 20,\n    },\n  ]}\n  onSuccess={(data) => console.log('Data on Success: ', data)}\n  onError={(error) => console.log('Data on Error: ', error)}\n  primaryBackgroundColor=\"#F2F2F2\"\n  primaryTextColor=\"#555555\"\n  secondaryBackgroundColor=\"#f2f2f2\"\n  secondaryTextColor=\"#000000\"\n  allowMultipleFiles={true}\n  open={true}\n  chunkSize={1500}\n  overlapSize={20}\n  // entryPoint=\"LOCAL_FILES\"\n></CarbonConnect>\n```\n\n### Server Side Configuration\n\nYour backend should handle token requests like this:\n\n```js\nconst response = await axios.get('https://api.carbon.ai/auth/v1/access_token', {\n  headers: {\n    'Content-Type': 'application/json',\n    'customer-id': '<YOUR_USER_UNIQUE_IDENTIFIER>',\n    authorization: 'Bearer <YOUR_API_KEY>',\n  },\n});\nif (response.status === 200 && response.data) {\n  res.status(200).json(response.data);\n}\n```\n\n### Return Value Expectation:\n\nEnsure that your tokenFetcher returns an object structured as:\n\n```js\n{\n  access_token: string;\n}\n```\n\n## Enable Data Sources\n\n---\n\nAnother important prop is enabledIntegrations. This prop lets you choose which integrations to show in the component. You can also pass additional configuration for each integration. We have provided an example in the above code snippet. Here is the list of all the integrations that you can enable:\n\n1. `LOCAL_FILES`: This integration lets you upload files from your local machine. You can pass the following configuration for this integration:\n\n   - `chunkSize`: This is the no.of tokens per chunk. Defaults to 1500.\n   - `overlapSize`: This is the size of the overlap in tokens. Defaults to 20.\n   - `maxFileSize`: This is the maximum file size in bytes that is allowed to be uploaded. Defaults to 10 MB.\n   - `allowMultipleFiles`: Whether or not to allow multiple files to be uploaded at once. Defaults to `false`.\n   - `maxFilesCount`: This is the maximum no.of files that can be uploaded at once. Defaults to 10.\n   - `skipEmbeddingGeneration`: Whether or not to skip embeddings generation. Defaults to `false`.\n   - `allowedFileTypes`: This is an array of objects. Each object represents a file type that is allowed to be uploaded. Each object can have the following properties:\n     - `extension`: The file extension of the file type. This is a required property.\n     - `chunkSize`: This is the no.of tokens per chunk. Defaults to 1500.\n     - `overlapSize`: This is the size of the overlap in tokens. Defaults to 20.\n     - `skipEmbeddingGeneration`: Whether or not to skip embeddings generation. Defaults to `false`.\n\n2. `NOTION`: This integration lets you upload files from your notion account. You can pass the following configuration for this integration\n\n   - `chunkSize`: This is the no.of tokens per chunk. Defaults to 1500.\n   - `overlapSize`: This is the size of the overlap in tokens. Defaults to 20.\n   - `skipEmbeddingGeneration`: Whether or not to skip embeddings generation. Defaults to `false`.\n\n3. `WEB_SCRAPER`: This integration lets you scrape URLs. You can pass the following configuration for this integration:\n\n   - `chunkSize`: This is the no.of tokens per chunk. Defaults to 1500.\n   - `overlapSize`: This is the size of the overlap in tokens. Defaults to 20.\n    - `recursionDepth`: This is the depth of recursion. Defaults to 3. If you do not want recursion to happen, please pass 1. Passing 0 will scrape recursively until the maxPagesToScrape limit is reached.\n    - `maxPagesToScrape`: This is the maximum no.of pages to scrape. Defaults to 100.\n    - `skipEmbeddingGeneration`: Whether or not to skip embeddings generation. Defaults to `false`.\n\n4. `GOOGLE_DRIVE`: This integration lets you upload files from your Google Drive. You can pass the following configuration for this integration:\n   - `chunkSize`: This is the no.of tokens per chunk. Defaults to 1500.\n   - `overlapSize`: This is the size of the overlap in tokens. Defaults to 20.\n   - `skipEmbeddingGeneration`: Whether or not to skip embeddings generation. Defaults to `false`.\n\n5. `INTERCOM`: This integration lets you select pages from your Intercom. You can pass the following configuration for this integration:\n\n   - `chunkSize`: This is the no.of tokens per chunk. Defaults to 1500.\n   - `overlapSize`: This is the size of the overlap in tokens. Defaults to 20.\n   - `skipEmbeddingGeneration`: Whether or not to skip embeddings generation. Defaults to `false`.\n\n6. `DROPBOX`: This integration lets you upload files from your Dropbox. You can pass the following configuration for this integration:\n   - `chunkSize`: This is the no.of tokens per chunk. Defaults to 1500.\n   - `overlapSize`: This is the size of the overlap in tokens. Defaults to 20.\n   - `skipEmbeddingGeneration`: Whether or not to skip embeddings generation. Defaults to `false`.\n\n7. `ONEDRIVE`: This integration lets you upload files from your Onedrive. You can pass the following configuration for this integration:\n   - `chunkSize`: This is the no.of tokens per chunk. Defaults to 1500.\n   - `overlapSize`: This is the size of the overlap in tokens. Defaults to 20.\n   - `skipEmbeddingGeneration`: Whether or not to skip embeddings generation. Defaults to `false`.\n\n## Callback Function Props\n\n---\n\n1.  `onError`: CC will also call another call back method if there is an error while uploading file. This function will pass data in the following format:\n\n```js\n{\n  status: 400,\n  action: 'UPDATE',\n  event: 'UPDATE',\n  integration: `<INTEGRATION_NAME>`, // 'LOCAL_FILES' or 'WEB_SCRAPER',\n  data: `<data_object>`, // This field will be present only if the error is related to a file or web scraper\n}\n```\n\n2. `onSuccess`: You can let CC trigger a callback function upon successful file upload, 3rd party account connection and file selection, Webscraping request initiation.\n\n  ### `onSuccess`` Event Types\n\n  1. `INITIATE`: This event type is triggered when a user enters the integration flow (either for auth or file selection)\n  2. `ADD`: This event type is triggered when a user authenticates an account under an integration.\n  3. `UPDATE`: This event type is triggered when a user adds or removes files for an integration. We’ll list the files added or removed.\n  4. `CANCEL`: This event type is triggered when when a user exits the integration flow without taking any action.\n\n\n  ### Data passed to `onSuccess` callback\n\n  The data passed to the onSuccess callback prop will be:\n\n  1. For `LOCAL_FILES`: \n\n  ```js\n  {\n    status: 200,\n    data: {\n      \"data_source_external_id\": null, // This field is not applicable for local files\n      \"sync_status\": null, // This is not applicable for local files\n      \"files\": <Array of objects corresponding to the files uploaded>, (Refer to the file object format below)\n    },\n    action: 'UPDATE'\n    event: 'UPDATE'\n    integration: 'LOCAL_FILES',\n  }\n  ```\n\n  2. For `WEB_SCRAPER`: An array containing only one object in the following format\n\n  ```js\n  {\n    status: 200,\n    data: {\n      \"data_source_external_id\": null, // This field is not applicable for webscrapers\n      \"sync_status\": null, // This is not applicable for webscrapers\n      \"files\": <Array of objects corresponding to the parent URLs submitted>, (Refer to the file object format below)\n    },\n    action: 'UPDATE'\n    event: 'UPDATE'\n    integration: 'WEB_SCRAPER',\n  }\n\n  ```\n\n  3. For third party integrations: An array of objects. Each object will be in the following format:\n\n  ```js\n  {\n    status: 200,\n    data: {\n      \"data_source_external_id\": <Unique ID for the data source>,\n      \"sync_status\": <SYNC_STATUS>,\n      \"files\": <Array of objects corresponding to the files / pages selected>,\n    } or null,\n    action: <ACTION_TYPE>, // `ACTION_TYPE` can be one of the following: `INITIATE`, `ADD`, `UPDATE`, `CANCEL`\n    event: <EVENT_TYPE>, // `EVENT_TYPE` can be one of the following: `INITIATE`, `ADD`, `UPDATE`, `CANCEL`\n    integration: <INTEGRATION_NAME>, // `INTEGRATION_NAME` can be one of the following: `LOCAL_FILES`, `NOTION`, `WEB_SCRAPER`, `GOOGLE_DRIVE`, `INTERCOM`, `DROPBOX`, `ONEDRIVE`\n  }\n  ```\n\n  Each file object will be in the following format:\n\n  ```js\n  {\n      \"id\": `Unique ID for the file, can be used for resyncing, deleting, updating tags etc.`,\n      \"source\": `<integration_name>`, // One among `LOCAL_FILES`, `NOTION`, `WEB_SCRAPER`, `GOOGLE_DRIVE`, `INTERCOM`, `DROPBOX`, `ONEDRIVE`\n      \"organization_id\": `<organization_id>`, // This is your unique organization id in carbon\n      \"organization_supplied_user_id\": `<organization_supplied_user_id>`, // This is the unique user id that you pass to CC\n      \"organization_user_data_source_id\": `<organization_user_data_source_id>`, // This is the unique user data source id that CC creates for each user for each integration\n      \"external_file_id\": `<external_file_id>`, // This is the unique file id in the 3rd party integration\n      \"external_url\": `<external_url>`, // This is the unique url of the file in the 3rd party integration\n      \"sync_status\": `<sync_status>`, // This is the sync status of the file. It can be one of the following: `READY`, `QUEUED_FOR_SYNCING`, `SYNCING`, `SYNC_ERROR`\n      \"last_sync\": `<last_sync>`, // This is the timestamp of the last sync\n      \"tags\": `<tags>`, // These are the tags passed in to CC\n      \"file_statistics\": `<file_statistics>`, // This is the file statistics object\n      \"file_metadata\": `<file_metadata>`, // This is the file metadata object\n      \"chunk_size\":   `<chunk_size>`, // This is the chunk size used for the file\n      \"chunk_overlap\": `<chunk_overlap>`, // This is the chunk overlap used for the file\n      \"name\": `<name>`, // This is the name of the file\n      \"enable_auto_sync\": `<enable_auto_sync>`, // This is the auto sync status of the file. This is a boolean flag\n      \"presigned_url\": `<presigned_url>`, // This is the presigned url of the file\n      \"parsed_text_url\": `<parsed_text_url>`, // This is the parsed text url of the file\n      \"skip_embedding_generation\": `<skip_embedding_generation>`, // This is the skip embedding generation status of the file. This is a boolean flag\n      \"created_at\": `<created_at>`, // This is the timestamp of the file creation\n      \"updated_at\": `<updated_at>`, // This is the timestamp of the file updation\n      \"action\": `<action>`, // This is the action type. It can be one of the following: `ADD`, `UPDATE`, `REMOVE`\n  }\n  ```\n",
      "name": "Carbon Connect"
    },
    {
      "description": "\n---\n### 💬 We're here to help!\n\nIt’s our mandate to deliver a delightful experience and answer any questions you might have. This documentation is meant to help get you started but isn't the only resource you have! \n\nPlease don't hesitate to email us at [support@carbon.ai](mailto:support@carbon.ai) or reach out directly to your account manager.\n\nOur terms of service can be found here: [terms of service](https://carbon.ai/terms)\n\nWe're excited you're here!\n",
      "name": "Contact Us"
    }
  ],
  "paths": {
    "/integrations/oauth_url": {
      "post": {
        "tags": [
          "Integrations"
        ],
        "summary": "Get Oauth Url",
        "operationId": "Integrations_getOauthUrl",
        "security": [
          {
            "apiKey": [
            ],
            "customerId": [
            ]
          },
          {
            "accessToken": [
            ]
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/OAuthURLRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IntegrationsGetOauthUrlResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/integrations/items/sync": {
      "post": {
        "tags": [
          "Integrations"
        ],
        "summary": "Sync Data Source Items",
        "operationId": "Integrations_syncDataSourceItems",
        "security": [
          {
            "apiKey": [
            ],
            "customerId": [
            ]
          },
          {
            "accessToken": [
            ]
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SyncDirectoryRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/OrganizationUserDataSourceAPI"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/integrations/items/list": {
      "post": {
        "tags": [
          "Integrations"
        ],
        "summary": "List Data Source Items",
        "operationId": "Integrations_listDataSourceItems",
        "security": [
          {
            "apiKey": [
            ],
            "customerId": [
            ]
          },
          {
            "accessToken": [
            ]
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListDataSourceItemsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListDataSourceItemsResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/integrations/files/sync": {
      "post": {
        "tags": [
          "Integrations"
        ],
        "summary": "Sync Files",
        "operationId": "Integrations_syncFiles",
        "security": [
          {
            "apiKey": [
            ],
            "customerId": [
            ]
          },
          {
            "accessToken": [
            ]
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SyncFilesRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GenericSuccessResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/integrations/confluence/list": {
      "post": {
        "tags": [
          "Integrations"
        ],
        "summary": "Confluence List",
        "operationId": "Integrations_listConfluencePages",
        "security": [
          {
            "apiKey": [
            ],
            "customerId": [
            ]
          },
          {
            "accessToken": [
            ]
          }
        ],
        "description": "To begin listing a user's Confluence pages, at least a `data_source_id` of a connected\nConfluence account must be specified. This base request returns a list of root pages for\nevery space the user has access to in a Confluence instance. To traverse further down\nthe user's page directory, additional requests to this endpoint can be made with the same\n`data_source_id` and with `parent_id` set to the id of page from a previous request. For\nconvenience, the `has_children` property in each directory item in the response list will\nflag which pages will return non-empty lists of pages when set as the `parent_id`.",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/integrations/confluence/sync": {
      "post": {
        "tags": [
          "Integrations"
        ],
        "summary": "Confluence Sync",
        "operationId": "Integrations_syncConfluence",
        "security": [
          {
            "apiKey": [
            ],
            "customerId": [
            ]
          },
          {
            "accessToken": [
            ]
          }
        ],
        "description": "After listing pages in a user's Confluence account, the set of selected page `ids` and the\nconnected account's `data_source_id` can be passed into this endpoint to sync them into\nCarbon. Additional parameters listed below can be used to associate data to the selected\npages or alter the behavior of the sync.",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SyncFilesRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GenericSuccessResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/integrations/s3": {
      "post": {
        "tags": [
          "Integrations"
        ],
        "summary": "S3 Auth",
        "operationId": "Integrations_createAwsIamUser",
        "security": [
          {
            "apiKey": [
            ],
            "customerId": [
            ]
          },
          {
            "accessToken": [
            ]
          }
        ],
        "description": "Create a new IAM user with permissions to:\n<ol>\n<li>List all buckets.</li>\n<li>Read from the specific buckets and objects to sync with Carbon. Ensure any future buckets or objects carry \nthe same permissions.</li>\n</ol>\nOnce created, generate an access key for this user and share the credentials with us. We recommend testing this key beforehand.",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/S3AuthRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/OrganizationUserDataSourceAPI"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/integrations/s3/files": {
      "post": {
        "tags": [
          "Integrations"
        ],
        "summary": "S3 Files",
        "operationId": "Integrations_syncS3Files",
        "security": [
          {
            "apiKey": [
            ],
            "customerId": [
            ]
          },
          {
            "accessToken": [
            ]
          }
        ],
        "description": "After optionally loading the items via /integrations/items/sync and integrations/items/list, use the bucket name \nand object key as the ID in this endpoint to sync them into Carbon. Additional parameters below can associate \ndata with the selected items or modify the sync behavior",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/S3FileSyncInput"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GenericSuccessResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/integrations/gmail/sync": {
      "post": {
        "tags": [
          "Integrations"
        ],
        "summary": "Gmail Sync",
        "operationId": "Integrations_syncGmail",
        "security": [
          {
            "apiKey": [
            ],
            "customerId": [
            ]
          },
          {
            "accessToken": [
            ]
          }
        ],
        "description": "Once you have successfully connected your gmail account, you can choose which emails to sync with us\nusing the filters parameter. Filters is a JSON object with key value pairs. It also supports AND and OR operations.\nFor now, we support a limited set of keys listed below.\n\n<b>label</b>: Inbuilt Gmail labels, for example \"Important\" or a custom label you created.  \n<b>after</b> or <b>before</b>: A date in YYYY/mm/dd format (example 2023/12/31). Gets emails after/before a certain date.\nYou can also use them in combination to get emails from a certain period.  \n<b>is</b>: Can have the following values - starred, important, snoozed, and unread  \n\nUsing keys or values outside of the specified values can lead to unexpected behaviour.\n\nAn example of a basic query with filters can be\n```json\n{\n    \"filters\": {\n            \"key\": \"label\",\n            \"value\": \"Test\"\n        }\n}\n```\nWhich will list all emails that have the label \"Test\".\n\nYou can use AND and OR operation in the following way:\n```json\n{\n    \"filters\": {\n        \"AND\": [\n            {\n                \"key\": \"after\",\n                \"value\": \"2024/01/07\"\n            },\n            {\n                \"OR\": [\n                    {\n                        \"key\": \"label\",\n                        \"value\": \"Personal\"\n                    },\n                    {\n                        \"key\": \"is\",\n                        \"value\": \"starred\"\n                    }\n                ]\n            }\n        ]\n    }\n}\n```\nThis will return emails after 7th of Jan that are either starred or have the label \"Personal\". \nNote that this is the highest level of nesting we support, i.e. you can't add more AND/OR filters within the OR filter\nin the above example.",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GmailSyncInput"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GenericSuccessResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/integrations/rss_feed": {
      "post": {
        "tags": [
          "Integrations"
        ],
        "summary": "Rss Feed",
        "operationId": "Integrations_syncRssFeed",
        "security": [
          {
            "apiKey": [
            ],
            "customerId": [
            ]
          },
          {
            "accessToken": [
            ]
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RSSFeedInput"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GenericSuccessResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/integrations/outlook/sync": {
      "post": {
        "tags": [
          "Integrations"
        ],
        "summary": "Outlook Sync",
        "operationId": "Integrations_syncOutlook",
        "security": [
          {
            "apiKey": [
            ],
            "customerId": [
            ]
          },
          {
            "accessToken": [
            ]
          }
        ],
        "description": "Once you have successfully connected your Outlook account, you can choose which emails to sync with us\nusing the filters and folder parameter. \"folder\" should be the folder you want to sync from Outlook. By default\nwe get messages from your inbox folder.  \nFilters is a JSON object with key value pairs. It also supports AND and OR operations.\nFor now, we support a limited set of keys listed below.\n\n<b>category</b>: Custom categories that you created in Outlook.  \n<b>after</b> or <b>before</b>: A date in YYYY/mm/dd format (example 2023/12/31). Gets emails after/before a certain date. You can also use them in combination to get emails from a certain period.    \n<b>is</b>: Can have the following values: flagged   \n\nAn example of a basic query with filters can be\n```json\n{\n    \"filters\": {\n            \"key\": \"category\",\n            \"value\": \"Test\"\n        }\n}\n```\nWhich will list all emails that have the category \"Test\".  \n\nSpecifying a custom folder in the same query\n```json\n{\n    \"folder\": \"Folder Name\",\n    \"filters\": {\n            \"key\": \"category\",\n            \"value\": \"Test\"\n        }\n}\n```\n\nYou can use AND and OR operation in the following way:\n```json\n{\n    \"filters\": {\n        \"AND\": [\n            {\n                \"key\": \"after\",\n                \"value\": \"2024/01/07\"\n            },\n            {\n                \"OR\": [\n                    {\n                        \"key\": \"category\",\n                        \"value\": \"Personal\"\n                    },\n                    {\n                        \"key\": \"category\",\n                        \"value\": \"Test\"\n                    },\n                ]\n            }\n        ]\n    }\n}\n```\nThis will return emails after 7th of Jan that have either Personal or Test as category. \nNote that this is the highest level of nesting we support, i.e. you can't add more AND/OR filters within the OR filter\nin the above example.",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/OutlookSyncInput"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GenericSuccessResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/integrations/freshdesk": {
      "post": {
        "tags": [
          "Integrations"
        ],
        "summary": "Freshdesk Connect",
        "operationId": "Integrations_connectFreshdesk",
        "security": [
          {
            "apiKey": [
            ],
            "customerId": [
            ]
          },
          {
            "accessToken": [
            ]
          }
        ],
        "description": "Refer this article to obtain an API key https://support.freshdesk.com/en/support/solutions/articles/215517.\nMake sure that your API key has the permission to read solutions from your account and you are on a <b>paid</b> plan.\nOnce you have an API key, you can make a request to this endpoint along with your freshdesk domain. This will \ntrigger an automatic sync of the articles in your \"solutions\" tab. Additional parameters below can be used to associate \ndata with the synced articles or modify the sync behavior.",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FreshDeskConnectRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GenericSuccessResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/integrations/outlook/user_folders": {
      "get": {
        "tags": [
          "Integrations"
        ],
        "summary": "Outlook Folders",
        "operationId": "Integrations_listFolders",
        "security": [
          {
            "apiKey": [
            ],
            "customerId": [
            ]
          },
          {
            "accessToken": [
            ]
          }
        ],
        "description": "After connecting your Outlook account, you can use this endpoint to list all of your folders on outlook. This includes \nboth system folders like \"inbox\" and user created folders.",
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IntegrationsListFoldersResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/integrations/gmail/user_labels": {
      "get": {
        "tags": [
          "Integrations"
        ],
        "summary": "Gmail Labels",
        "operationId": "Integrations_listLabels",
        "security": [
          {
            "apiKey": [
            ],
            "customerId": [
            ]
          },
          {
            "accessToken": [
            ]
          }
        ],
        "description": "After connecting your Gmail account, you can use this endpoint to list all of your labels. User created labels\nwill have the type \"user\" and Gmail's default labels will have the type \"system\"",
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IntegrationsListLabelsResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/integrations/gitbook": {
      "post": {
        "tags": [
          "Integrations"
        ],
        "summary": "Gitbook Connect",
        "operationId": "Integrations_connectGitbook",
        "security": [
          {
            "apiKey": [
            ],
            "customerId": [
            ]
          },
          {
            "accessToken": [
            ]
          }
        ],
        "description": "You will need an access token to connect your Gitbook account. Note that the permissions will be defined by the user \ngenerating access token so make sure you have the permission to access spaces you will be syncing. \nRefer this article for more details https://developer.gitbook.com/gitbook-api/authentication. Additionally, you\nneed to specify the name of organization you will be syncing data from.",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GitbookConnectRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GenericSuccessResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/integrations/gitbook/spaces": {
      "get": {
        "tags": [
          "Integrations"
        ],
        "summary": "Gitbook Spaces",
        "operationId": "Integrations_listGitbookSpaces",
        "security": [
          {
            "apiKey": [
            ],
            "customerId": [
            ]
          },
          {
            "accessToken": [
            ]
          }
        ],
        "description": "After connecting your Gitbook account, you can use this endpoint to list all of your spaces under current organization.",
        "parameters": [
          {
            "name": "data_source_id",
            "in": "query",
            "required": true,
            "schema": {
              "title": "Data Source Id",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IntegrationsListGitbookSpacesResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/integrations/gitbook/sync": {
      "post": {
        "tags": [
          "Integrations"
        ],
        "summary": "Gitbook Sync",
        "operationId": "Integrations_syncGitbook",
        "security": [
          {
            "apiKey": [
            ],
            "customerId": [
            ]
          },
          {
            "accessToken": [
            ]
          }
        ],
        "description": "You can sync upto 20 Gitbook spaces at a time using this endpoint. Additional parameters below can be used to associate \ndata with the synced pages or modify the sync behavior.",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GitbookSyncRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IntegrationsSyncGitbookResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/auth/v1/access_token": {
      "get": {
        "tags": [
          "Auth"
        ],
        "summary": "Get Access Token",
        "operationId": "Auth_getAccessToken",
        "security": [
          {
            "apiKey": [
            ],
            "customerId": [
            ]
          },
          {
            "accessToken": [
            ]
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TokenResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/auth/v1/white_labeling": {
      "get": {
        "tags": [
          "Auth"
        ],
        "summary": "Get White Labeling",
        "operationId": "Auth_getWhiteLabeling",
        "security": [
          {
            "accessToken": [
            ]
          }
        ],
        "description": "Returns whether or not the organization is white labeled and which integrations are white labeled\n\n:param current_user: the current user\n:param db: the database session\n:return: a WhiteLabelingResponse",
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/WhiteLabelingResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/embeddings": {
      "post": {
        "tags": [
          "Embeddings"
        ],
        "summary": "Embeddings",
        "operationId": "Embeddings_getDocuments",
        "security": [
          {
            "apiKey": [
            ],
            "customerId": [
            ]
          },
          {
            "accessToken": [
            ]
          }
        ],
        "description": "For pre-filtering documents, using `tags_v2` is preferred to using `tags` (which is now deprecated). If both `tags_v2`\nand `tags` are specified, `tags` is ignored. `tags_v2` enables\nbuilding complex filters through the use of \"AND\", \"OR\", and negation logic. Take the below input as an example:\n```json\n{\n    \"OR\": [\n        {\n            \"key\": \"subject\",\n            \"value\": \"holy-bible\",\n            \"negate\": false\n        },\n        {\n            \"key\": \"person-of-interest\",\n            \"value\": \"jesus christ\",\n            \"negate\": false\n        },\n        {\n            \"key\": \"genre\",\n            \"value\": \"religion\",\n            \"negate\": true\n        }\n        {\n            \"AND\": [\n                {\n                    \"key\": \"subject\",\n                    \"value\": \"tao-te-ching\",\n                    \"negate\": false\n                },\n                {\n                    \"key\": \"author\",\n                    \"value\": \"lao-tzu\",\n                    \"negate\": false\n                }\n            ]\n        }\n    ]\n}\n```\nIn this case, files will be filtered such that:\n1. \"subject\" = \"holy-bible\" OR\n2. \"person-of-interest\" = \"jesus christ\" OR\n3. \"genre\" != \"religion\" OR\n4. \"subject\" = \"tao-te-ching\" AND \"author\" = \"lao-tzu\"\n\nNote that the top level of the query must be either an \"OR\" or \"AND\" array. Currently, nesting is limited to 3.\nFor tag blocks (those with \"key\", \"value\", and \"negate\" keys), the following typing rules apply:\n1. \"key\" isn't optional and must be a `string`\n2. \"value\" isn't optional and can be `any` or list[`any`]\n3. \"negate\" is optional and must be `true` or `false`. If present and `true`, then the filter block is negated in\nthe resulting query. It is `false` by default.\n\n\nWhen querying embeddings, you can optionally specify the `media_type` parameter in your request. By default (if\nnot set), it is equal to \"TEXT\". This means that the query will be performed over files that have\nbeen parsed as text (for now, this covers all files except image files). If it is equal to \"IMAGE\",\nthe query will be performed over image files (for now, `.jpg` and `.png` files). You can think of this\nfield as an additional filter on top of any filters set in `file_ids` and\n\n\nWhen `hybrid_search` is set to true, a combination of keyword search and semantic search are used to rank\nand select candidate embeddings during information retrieval. By default, these search methods are weighted\nequally during the ranking process. To adjust the weight (or \"importance\") of each search method, you can use\nthe `hybrid_search_tuning_parameters` property. The description for the different tuning parameters are:\n- `weight_a`: weight to assign to semantic search\n- `weight_b`: weight to assign to keyword search\n\nYou must ensure that `sum(weight_a, weight_b,..., weight_n)` for all *n* weights is equal to 1. The equality\nhas an error tolerance of 0.001 to account for possible floating point issues.\n\nIn order to use hybrid search for a customer across a set of documents, two flags need to be enabled:\n1. Use the `/modify_user_configuration` endpoint to to enable `sparse_vectors` for the customer. The payload\nbody for this request is below:\n```\n{\n  \"configuration_key_name\": \"sparse_vectors\",\n  \"value\": {\n    \"enabled\": true\n  }\n}\n```\n2. Make sure hybrid search is enabled for the documents across which you want to perform the search. For the\n`/uploadfile` endpoint, this can be done by setting the following query parameter: `generate_sparse_vectors=true`\n\n\nCarbon supports multiple models for use in generating embeddings for files. For images, we support Vertex AI's\nmultimodal model; for text, we support OpenAI's `text-embedding-ada-002` and Cohere's embed-multilingual-v3.0.\nThe model can be specified via the `embedding_model` parameter (in the POST body for `/embeddings`, and a query \nparameter in `/uploadfile`). If no model is supplied, the `text-embedding-ada-002` is used by default. When performing\nembedding queries, embeddings from files that used the specified model will be considered in the query.\nFor example, if files A and B have embeddings generated with `OPENAI`, and files C and D have embeddings generated with\n`COHERE_MULTILINGUAL_V3`, then by default, queries will only consider files A and B. If `COHERE_MULTILINGUAL_V3` is\nspecified as the `embedding_model` in `/embeddings`, then only files C and D will be considered. Make sure that\nthe set of all files you want considered for a query have embeddings generated via the same model. For now, **do not**\nset `VERTEX_MULTIMODAL` as an `embedding_model`. This model is used automatically by Carbon when it detects an image file.",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetEmbeddingDocumentsBody"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DocumentResponseList"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/text_chunks": {
      "post": {
        "tags": [
          "Embeddings"
        ],
        "summary": "Retrieve Embeddings And Content",
        "operationId": "Embeddings_getEmbeddingsAndChunks",
        "security": [
          {
            "apiKey": [
            ],
            "customerId": [
            ]
          },
          {
            "accessToken": [
            ]
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/EmbeddingsAndChunksQueryInput"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EmbeddingsAndChunksResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/upload_chunks_and_embeddings": {
      "post": {
        "tags": [
          "Embeddings"
        ],
        "summary": "Upload Chunks And Embeddings",
        "operationId": "Embeddings_uploadChunksAndEmbeddings",
        "security": [
          {
            "apiKey": [
            ],
            "customerId": [
            ]
          },
          {
            "accessToken": [
            ]
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ChunksAndEmbeddingsUploadInput"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GenericSuccessResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/organization": {
      "get": {
        "tags": [
          "Organizations"
        ],
        "summary": "Get Organization",
        "operationId": "Organizations_get",
        "security": [
          {
            "accessToken": [
            ]
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/OrganizationResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/user": {
      "post": {
        "tags": [
          "Users"
        ],
        "summary": "User Endpoint",
        "operationId": "Users_get",
        "security": [
          {
            "accessToken": [
            ]
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UserRequestContent"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UserResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/modify_user_configuration": {
      "post": {
        "tags": [
          "Users"
        ],
        "summary": "Toggle User Features",
        "operationId": "Users_toggleUserFeatures",
        "security": [
          {
            "apiKey": [
            ],
            "customerId": [
            ]
          },
          {
            "accessToken": [
            ]
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ModifyUserConfigurationInput"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GenericSuccessResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/uploadfile": {
      "post": {
        "tags": [
          "Files"
        ],
        "summary": "Create Upload File",
        "operationId": "Files_upload",
        "security": [
          {
            "apiKey": [
            ],
            "customerId": [
            ]
          },
          {
            "accessToken": [
            ]
          }
        ],
        "description": "This endpoint is used to directly upload local files to Carbon. The `POST` request should be a multipart form request.\nNote that the `set_page_as_boundary` query parameter is applicable only to PDFs for now. When this value is set,\nPDF chunks are at most one page long. Additional information can be retrieved for each chunk, however, namely the coordinates\nof the bounding box around the chunk (this can be used for things like text highlighting). Following is a description\nof all possible query parameters:\n- `chunk_size`: the chunk size (in tokens) applied when splitting the document\n- `chunk_overlap`: the chunk overlap (in tokens) applied when splitting the document\n- `skip_embedding_generation`: whether or not to skip the generation of chunks and embeddings\n- `set_page_as_boundary`: described above\n- `embedding_model`: the model used to generate embeddings for the document chunks\n- `use_ocr`: whether or not to use OCR as a preprocessing step prior to generating chunks (only valid for PDFs currently)\n- `generate_sparse_vectors`: whether or not to generate sparse vectors for the file. Required for hybrid search.\n- `prepend_filename_to_chunks`: whether or not to prepend the filename to the chunk text\n\n\nCarbon supports multiple models for use in generating embeddings for files. For images, we support Vertex AI's\nmultimodal model; for text, we support OpenAI's `text-embedding-ada-002` and Cohere's embed-multilingual-v3.0.\nThe model can be specified via the `embedding_model` parameter (in the POST body for `/embeddings`, and a query \nparameter in `/uploadfile`). If no model is supplied, the `text-embedding-ada-002` is used by default. When performing\nembedding queries, embeddings from files that used the specified model will be considered in the query.\nFor example, if files A and B have embeddings generated with `OPENAI`, and files C and D have embeddings generated with\n`COHERE_MULTILINGUAL_V3`, then by default, queries will only consider files A and B. If `COHERE_MULTILINGUAL_V3` is\nspecified as the `embedding_model` in `/embeddings`, then only files C and D will be considered. Make sure that\nthe set of all files you want considered for a query have embeddings generated via the same model. For now, **do not**\nset `VERTEX_MULTIMODAL` as an `embedding_model`. This model is used automatically by Carbon when it detects an image file.",
        "parameters": [
          {
            "description": "Chunk size in tiktoken tokens to be used when processing file.",
            "name": "chunk_size",
            "in": "query",
            "required": false,
            "schema": {
              "title": "Chunk Size",
              "description": "Chunk size in tiktoken tokens to be used when processing file.",
              "type": "integer",
              "nullable": true
            }
          },
          {
            "description": "Chunk overlap in tiktoken tokens to be used when processing file.",
            "name": "chunk_overlap",
            "in": "query",
            "required": false,
            "schema": {
              "title": "Chunk Overlap",
              "description": "Chunk overlap in tiktoken tokens to be used when processing file.",
              "type": "integer",
              "nullable": true
            }
          },
          {
            "description": "Flag to control whether or not embeddings should be generated and stored\n            when processing file.",
            "name": "skip_embedding_generation",
            "in": "query",
            "required": false,
            "schema": {
              "title": "Skip Embedding Generation",
              "description": "Flag to control whether or not embeddings should be generated and stored\n            when processing file.",
              "type": "boolean",
              "default": false
            }
          },
          {
            "description": "Flag to control whether or not to set the a page's worth of content as the maximum\n            amount of content that can appear in a chunk. Only valid for PDFs. See description route description for\n            more information.",
            "name": "set_page_as_boundary",
            "in": "query",
            "required": false,
            "schema": {
              "title": "Set Page As Boundary",
              "description": "Flag to control whether or not to set the a page's worth of content as the maximum\n            amount of content that can appear in a chunk. Only valid for PDFs. See description route description for\n            more information.",
              "type": "boolean",
              "default": false
            }
          },
          {
            "description": "Embedding model that will be used to embed file chunks.",
            "name": "embedding_model",
            "in": "query",
            "required": false,
            "schema": {
              "$ref": "#/components/schemas/TextEmbeddingGenerators"
            }
          },
          {
            "description": "Whether or not to use OCR when processing files. Only valid for PDFs. Useful for documents with\n            tables, images, and/or scanned text.",
            "name": "use_ocr",
            "in": "query",
            "required": false,
            "schema": {
              "title": "Use Ocr",
              "description": "Whether or not to use OCR when processing files. Only valid for PDFs. Useful for documents with\n            tables, images, and/or scanned text.",
              "type": "boolean",
              "default": false
            }
          },
          {
            "description": "Whether or not to generate sparse vectors for the file. This is *required* for the file to be a\n            candidate for hybrid search.",
            "name": "generate_sparse_vectors",
            "in": "query",
            "required": false,
            "schema": {
              "title": "Generate Sparse Vectors",
              "description": "Whether or not to generate sparse vectors for the file. This is *required* for the file to be a\n            candidate for hybrid search.",
              "type": "boolean",
              "default": false
            }
          },
          {
            "description": "Whether or not to prepend the file's name to chunks.",
            "name": "prepend_filename_to_chunks",
            "in": "query",
            "required": false,
            "schema": {
              "title": "Prepend Filename To Chunks",
              "description": "Whether or not to prepend the file's name to chunks.",
              "type": "boolean",
              "default": false
            }
          },
          {
            "description": "Number of objects per chunk. For json files only.",
            "name": "max_items_per_chunk",
            "in": "query",
            "required": false,
            "schema": {
              "title": "Max Items Per Chunk",
              "description": "Number of objects per chunk. For json files only.",
              "type": "integer",
              "nullable": true
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "multipart/form-data": {
              "schema": {
                "$ref": "#/components/schemas/Body_create_upload_file_uploadfile_post"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UserFile"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/upload_file_from_url": {
      "post": {
        "tags": [
          "Files"
        ],
        "summary": "Create Upload File From Url",
        "operationId": "Files_uploadFromUrl",
        "security": [
          {
            "apiKey": [
            ],
            "customerId": [
            ]
          },
          {
            "accessToken": [
            ]
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UploadFileFromUrlInput"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UserFile"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/upload_text": {
      "post": {
        "tags": [
          "Files"
        ],
        "summary": "Create Raw Text",
        "operationId": "Files_uploadText",
        "security": [
          {
            "apiKey": [
            ],
            "customerId": [
            ]
          },
          {
            "accessToken": [
            ]
          }
        ],
        "description": "Carbon supports multiple models for use in generating embeddings for files. For images, we support Vertex AI's\nmultimodal model; for text, we support OpenAI's `text-embedding-ada-002` and Cohere's embed-multilingual-v3.0.\nThe model can be specified via the `embedding_model` parameter (in the POST body for `/embeddings`, and a query \nparameter in `/uploadfile`). If no model is supplied, the `text-embedding-ada-002` is used by default. When performing\nembedding queries, embeddings from files that used the specified model will be considered in the query.\nFor example, if files A and B have embeddings generated with `OPENAI`, and files C and D have embeddings generated with\n`COHERE_MULTILINGUAL_V3`, then by default, queries will only consider files A and B. If `COHERE_MULTILINGUAL_V3` is\nspecified as the `embedding_model` in `/embeddings`, then only files C and D will be considered. Make sure that\nthe set of all files you want considered for a query have embeddings generated via the same model. For now, **do not**\nset `VERTEX_MULTIMODAL` as an `embedding_model`. This model is used automatically by Carbon when it detects an image file.",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RawTextInput"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UserFile"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/deletefile/{file_id}": {
      "delete": {
        "tags": [
          "Files"
        ],
        "summary": "Delete File Endpoint",
        "operationId": "Files_delete",
        "security": [
          {
            "apiKey": [
            ],
            "customerId": [
            ]
          },
          {
            "accessToken": [
            ]
          }
        ],
        "parameters": [
          {
            "name": "file_id",
            "in": "path",
            "required": true,
            "schema": {
              "title": "File Id",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GenericSuccessResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/delete_files": {
      "post": {
        "tags": [
          "Files"
        ],
        "summary": "Delete Files Endpoint",
        "operationId": "Files_deleteMany",
        "security": [
          {
            "apiKey": [
            ],
            "customerId": [
            ]
          },
          {
            "accessToken": [
            ]
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DeleteFilesQueryInput"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GenericSuccessResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/user_files_v2": {
      "post": {
        "tags": [
          "Files"
        ],
        "summary": "User Files V2",
        "operationId": "Files_queryUserFiles",
        "security": [
          {
            "apiKey": [
            ],
            "customerId": [
            ]
          },
          {
            "accessToken": [
            ]
          }
        ],
        "description": "For pre-filtering documents, using `tags_v2` is preferred to using `tags` (which is now deprecated). If both `tags_v2`\nand `tags` are specified, `tags` is ignored. `tags_v2` enables\nbuilding complex filters through the use of \"AND\", \"OR\", and negation logic. Take the below input as an example:\n```json\n{\n    \"OR\": [\n        {\n            \"key\": \"subject\",\n            \"value\": \"holy-bible\",\n            \"negate\": false\n        },\n        {\n            \"key\": \"person-of-interest\",\n            \"value\": \"jesus christ\",\n            \"negate\": false\n        },\n        {\n            \"key\": \"genre\",\n            \"value\": \"religion\",\n            \"negate\": true\n        }\n        {\n            \"AND\": [\n                {\n                    \"key\": \"subject\",\n                    \"value\": \"tao-te-ching\",\n                    \"negate\": false\n                },\n                {\n                    \"key\": \"author\",\n                    \"value\": \"lao-tzu\",\n                    \"negate\": false\n                }\n            ]\n        }\n    ]\n}\n```\nIn this case, files will be filtered such that:\n1. \"subject\" = \"holy-bible\" OR\n2. \"person-of-interest\" = \"jesus christ\" OR\n3. \"genre\" != \"religion\" OR\n4. \"subject\" = \"tao-te-ching\" AND \"author\" = \"lao-tzu\"\n\nNote that the top level of the query must be either an \"OR\" or \"AND\" array. Currently, nesting is limited to 3.\nFor tag blocks (those with \"key\", \"value\", and \"negate\" keys), the following typing rules apply:\n1. \"key\" isn't optional and must be a `string`\n2. \"value\" isn't optional and can be `any` or list[`any`]\n3. \"negate\" is optional and must be `true` or `false`. If present and `true`, then the filter block is negated in\nthe resulting query. It is `false` by default.",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/OrganizationUserFilesToSyncQueryInput"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UserFilesV2"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/create_user_file_tags": {
      "post": {
        "tags": [
          "Files"
        ],
        "summary": "Create File Tags",
        "operationId": "Files_createUserFileTags",
        "security": [
          {
            "apiKey": [
            ],
            "customerId": [
            ]
          },
          {
            "accessToken": [
            ]
          }
        ],
        "description": "A tag is a key-value pair that can be added to a file. This pair can then be used\nfor searches (e.g. embedding searches) in order to narrow down the scope of the search.\nA file can have any number of tags. The following are reserved keys that cannot be used:\n- db_embedding_id\n- organization_id\n- user_id\n- organization_user_file_id\n\nCarbon currently supports two data types for tag values - `string` and `list<string>`.\nKeys can only be `string`. If values other than `string` and `list<string>` are used,\nthey're automatically converted to strings (e.g. 4 will become \"4\").",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/OrganizationUserFileTagCreate"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UserFile"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/delete_user_file_tags": {
      "post": {
        "tags": [
          "Files"
        ],
        "summary": "Delete File Tags",
        "operationId": "Files_deleteFileTags",
        "security": [
          {
            "apiKey": [
            ],
            "customerId": [
            ]
          },
          {
            "accessToken": [
            ]
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/OrganizationUserFileTagsRemove"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UserFile"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/resync_file": {
      "post": {
        "tags": [
          "Files"
        ],
        "summary": "Resync File",
        "operationId": "Files_resync",
        "security": [
          {
            "apiKey": [
            ],
            "customerId": [
            ]
          },
          {
            "accessToken": [
            ]
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ResyncFileQueryInput"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UserFile"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/raw_file/{file_id}": {
      "get": {
        "tags": [
          "Files"
        ],
        "summary": "Raw File",
        "operationId": "Files_getRawFile",
        "security": [
          {
            "apiKey": [
            ],
            "customerId": [
            ]
          },
          {
            "accessToken": [
            ]
          }
        ],
        "description": "This route is deprecated. Use `/user_files_v2` instead.",
        "parameters": [
          {
            "name": "file_id",
            "in": "path",
            "required": true,
            "schema": {
              "title": "File Id",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PresignedURLResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "deprecated": true
      }
    },
    "/parsed_file/{file_id}": {
      "get": {
        "tags": [
          "Files"
        ],
        "summary": "Parsed File",
        "operationId": "Files_getParsedFile",
        "security": [
          {
            "apiKey": [
            ],
            "customerId": [
            ]
          },
          {
            "accessToken": [
            ]
          }
        ],
        "description": "This route is deprecated. Use `/user_files_v2` instead.",
        "parameters": [
          {
            "name": "file_id",
            "in": "path",
            "required": true,
            "schema": {
              "title": "File Id",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PresignedURLResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "deprecated": true
      }
    },
    "/user_files": {
      "post": {
        "tags": [
          "Files"
        ],
        "summary": "User Files",
        "operationId": "Files_queryUserFilesDeprecated",
        "security": [
          {
            "apiKey": [
            ],
            "customerId": [
            ]
          },
          {
            "accessToken": [
            ]
          }
        ],
        "description": "This route is deprecated. Use `/user_files_v2` instead.",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/OrganizationUserFilesToSyncQueryInput"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FilesQueryUserFilesDeprecatedResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "deprecated": true
      }
    },
    "/webhooks": {
      "post": {
        "tags": [
          "Webhooks"
        ],
        "summary": "Webhook Urls",
        "operationId": "Webhooks_urls",
        "security": [
          {
            "accessToken": [
            ]
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/WebhookQueryInput"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/WebhookQueryResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/add_webhook": {
      "post": {
        "tags": [
          "Webhooks"
        ],
        "summary": "Add Webhook Url",
        "operationId": "Webhooks_addUrl",
        "security": [
          {
            "accessToken": [
            ]
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AddWebhookProps"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Webhook"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/delete_webhook/{webhook_id}": {
      "delete": {
        "tags": [
          "Webhooks"
        ],
        "summary": "Delete Webhook Url",
        "operationId": "Webhooks_deleteUrl",
        "security": [
          {
            "accessToken": [
            ]
          }
        ],
        "parameters": [
          {
            "name": "webhook_id",
            "in": "path",
            "required": true,
            "schema": {
              "title": "Webhook Id",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GenericSuccessResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/user_data_sources": {
      "post": {
        "tags": [
          "Data Sources"
        ],
        "summary": "User Data Sources",
        "operationId": "DataSources_queryUserDataSources",
        "security": [
          {
            "apiKey": [
            ],
            "customerId": [
            ]
          },
          {
            "accessToken": [
            ]
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/OrganizationUserDataSourceQueryInput"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/OrganizationUserDataSourceResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/revoke_access_token": {
      "post": {
        "tags": [
          "Data Sources"
        ],
        "summary": "Revoke Access Token",
        "operationId": "DataSources_revokeAccessToken",
        "security": [
          {
            "apiKey": [
            ],
            "customerId": [
            ]
          },
          {
            "accessToken": [
            ]
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RevokeAccessTokenInput"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GenericSuccessResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/web_scrape": {
      "post": {
        "tags": [
          "Utilities"
        ],
        "summary": "Web Scrape",
        "operationId": "Utilities_scrapeWeb",
        "security": [
          {
            "apiKey": [
            ],
            "customerId": [
            ]
          },
          {
            "accessToken": [
            ]
          }
        ],
        "description": "Conduct a web scrape on a given webpage URL. Our web scraper is fully compatible with JavaScript and supports recursion depth, enabling you to efficiently extract all content from the target website.\n\n<!--Args:\n    scraping_requests (List[WebscrapeRequest]): A list of WebscrapeRequest objects.\n    \nReturns:\n    dict: A response object with the status of the scraping job message.-->",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UtilitiesScrapeWebRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UtilitiesScrapeWebResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/process_sitemap": {
      "get": {
        "tags": [
          "Utilities"
        ],
        "summary": "Sitemap",
        "operationId": "Utilities_processSitemap",
        "security": [
          {
            "apiKey": [
            ],
            "customerId": [
            ]
          },
          {
            "accessToken": [
            ]
          }
        ],
        "description": "Retrieves all URLs from a sitemap, which can subsequently be utilized with our `web_scrape` endpoint.\n\n<!--Args:\n    url (str): URL of the sitemap\n\nReturns:\n    dict: A dictionary with a list of URLs extracted from the sitemap.-->",
        "parameters": [
          {
            "name": "url",
            "in": "query",
            "required": true,
            "schema": {
              "title": "Url",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UtilitiesProcessSitemapResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/scrape_sitemap": {
      "post": {
        "tags": [
          "Utilities"
        ],
        "summary": "Scrape Sitemap",
        "operationId": "Utilities_scrapeSitemap",
        "security": [
          {
            "apiKey": [
            ],
            "customerId": [
            ]
          },
          {
            "accessToken": [
            ]
          }
        ],
        "description": "Extracts all URLs from a sitemap and performs a web scrape on each of them.\n\nArgs:\n    sitemap_url (str): URL of the sitemap\n\nReturns:\n    dict: A response object with the status of the scraping job message.-->",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SitemapScrapeRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UtilitiesScrapeSitemapResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/fetch_urls": {
      "get": {
        "tags": [
          "Utilities"
        ],
        "summary": "Fetch Urls",
        "operationId": "Utilities_fetchUrls",
        "security": [
          {
            "apiKey": [
            ],
            "customerId": [
            ]
          },
          {
            "accessToken": [
            ]
          }
        ],
        "description": "Extracts all URLs from a webpage. \n\nArgs:\n    url (str): URL of the webpage\n\nReturns:\n    FetchURLsResponse: A response object with a list of URLs extracted from the webpage and the webpage content.",
        "parameters": [
          {
            "name": "url",
            "in": "query",
            "required": true,
            "schema": {
              "title": "Url",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FetchURLsResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/search_urls": {
      "get": {
        "tags": [
          "Utilities"
        ],
        "summary": "Search Urls",
        "operationId": "Utilities_searchUrls",
        "security": [
          {
            "apiKey": [
            ],
            "customerId": [
            ]
          },
          {
            "accessToken": [
            ]
          }
        ],
        "description": "Perform a web search and obtain a list of relevant URLs.\n\nAs an illustration, when you perform a search for “content related to MRNA,” you will receive a list of links such as the following:\n\n    - https://tomrenz.substack.com/p/mrna-and-why-it-matters\n\n    - https://www.statnews.com/2020/11/10/the-story-of-mrna-how-a-once-dismissed-idea-became-a-leading-technology-in-the-covid-vaccine-race/\n\n    - https://www.statnews.com/2022/11/16/covid-19-vaccines-were-a-success-but-mrna-still-has-a-delivery-problem/\n    \n    - https://joomi.substack.com/p/were-still-being-misled-about-how\n\nSubsequently, you can submit these links to the web_scrape endpoint in order to retrieve the content of the respective web pages.\n\nArgs:\n    query (str): Query to search for\n\nReturns:\n    FetchURLsResponse: A response object with a list of URLs for a given search query.",
        "parameters": [
          {
            "name": "query",
            "in": "query",
            "required": true,
            "schema": {
              "title": "Query",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FetchURLsResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/fetch_youtube_transcript": {
      "get": {
        "tags": [
          "Utilities"
        ],
        "summary": "Fetch Youtube Transcripts",
        "operationId": "Utilities_fetchYoutubeTranscripts",
        "security": [
          {
            "apiKey": [
            ],
            "customerId": [
            ]
          },
          {
            "accessToken": [
            ]
          }
        ],
        "description": "Fetches english transcripts from YouTube videos.\n\nArgs:\n    id (str): The ID of the YouTube video. \n    raw (bool): Whether to return the raw transcript or not. Defaults to False.\n\nReturns:\n    dict: A dictionary with the transcript of the YouTube video.",
        "parameters": [
          {
            "name": "id",
            "in": "query",
            "required": true,
            "schema": {
              "title": "Id",
              "type": "string"
            }
          },
          {
            "name": "raw",
            "in": "query",
            "required": false,
            "schema": {
              "title": "Raw",
              "type": "boolean",
              "default": false
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/YoutubeTranscriptResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/health": {
      "get": {
        "tags": [
          "Health"
        ],
        "summary": "Health",
        "operationId": "Health_check",
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HealthCheckResponse"
                }
              }
            }
          }
        }
      }
    }
  },
  "components": {
    "schemas": {
      "AddWebhookProps": {
        "title": "AddWebhookProps",
        "properties": {
          "url": {
            "title": "Url",
            "type": "string"
          }
        },
        "type": "object",
        "required": [
          "url"
        ]
      },
      "Body_create_upload_file_uploadfile_post": {
        "title": "Body_create_upload_file_uploadfile_post",
        "properties": {
          "file": {
            "title": "File",
            "type": "string",
            "format": "binary"
          }
        },
        "type": "object",
        "required": [
          "file"
        ]
      },
      "ChunkProperties": {
        "title": "ChunkProperties",
        "properties": {
          "set_page_as_boundary": {
            "title": "Set Page As Boundary",
            "type": "boolean",
            "default": false
          },
          "prepend_filename_to_chunks": {
            "title": "Prepend Filename To Chunks",
            "type": "boolean",
            "default": false
          },
          "max_items_per_chunk": {
            "title": "Max Items Per Chunk",
            "type": "integer",
            "nullable": true
          }
        },
        "type": "object",
        "required": [
          "set_page_as_boundary",
          "prepend_filename_to_chunks",
          "max_items_per_chunk"
        ]
      },
      "ChunksAndEmbeddings": {
        "title": "ChunksAndEmbeddings",
        "properties": {
          "chunk_number": {
            "title": "Chunk Number",
            "type": "integer",
            "nullable": true
          },
          "chunk": {
            "title": "Chunk",
            "type": "string"
          },
          "embedding": {
            "title": "Embedding",
            "items": {
              "type": "number"
            },
            "type": "array"
          }
        },
        "type": "object",
        "required": [
          "chunk_number",
          "chunk",
          "embedding"
        ]
      },
      "ChunksAndEmbeddingsUploadInput": {
        "title": "ChunksAndEmbeddingsUploadInput",
        "properties": {
          "embedding_model": {
            "$ref": "#/components/schemas/EmbeddingGenerators"
          },
          "chunks_and_embeddings": {
            "title": "Chunks And Embeddings",
            "items": {
              "$ref": "#/components/schemas/SingleChunksAndEmbeddingsUploadInput"
            },
            "type": "array"
          },
          "overwrite_existing": {
            "title": "Overwrite Existing",
            "type": "boolean",
            "default": false
          }
        },
        "type": "object",
        "required": [
          "embedding_model",
          "chunks_and_embeddings"
        ]
      },
      "ConfigurationKeys": {
        "title": "ConfigurationKeys",
        "type": "string",
        "const": "sparse_vectors"
      },
      "DataSourceLastSyncActions": {
        "title": "DataSourceLastSyncActions",
        "type": "string",
        "enum": [
          "ADD",
          "UPDATE",
          "CANCEL",
          "REVOKE"
        ]
      },
      "DataSourceSyncStatuses": {
        "title": "DataSourceSyncStatuses",
        "type": "string",
        "enum": [
          "QUEUED_FOR_SYNCING",
          "SYNCING",
          "READY",
          "SYNC_ERROR"
        ]
      },
      "DataSourceType": {
        "title": "DataSourceType",
        "type": "string",
        "enum": [
          "GOOGLE_DRIVE",
          "NOTION",
          "NOTION_DATABASE",
          "INTERCOM",
          "DROPBOX",
          "ONEDRIVE",
          "SHAREPOINT",
          "CONFLUENCE",
          "BOX",
          "ZENDESK",
          "ZOTERO",
          "S3",
          "GMAIL",
          "OUTLOOK",
          "TEXT",
          "CSV",
          "TSV",
          "PDF",
          "DOCX",
          "PPTX",
          "XLSX",
          "MD",
          "RTF",
          "JSON",
          "RAW_TEXT",
          "WEB_SCRAPE",
          "RSS_FEED",
          "FRESHDESK",
          "GITBOOK",
          "JPG",
          "PNG",
          "MP3",
          "MP4",
          "MP2",
          "AAC",
          "WAV",
          "FLAC",
          "PCM",
          "M4A",
          "OGG",
          "OPUS",
          "WEBM"
        ]
      },
      "DeleteFilesQueryInput": {
        "title": "DeleteFilesQueryInput",
        "properties": {
          "file_ids": {
            "title": "File Ids",
            "items": {
              "type": "integer"
            },
            "type": "array",
            "nullable": true
          },
          "sync_statuses": {
            "title": "Sync Statuses",
            "items": {
              "$ref": "#/components/schemas/ExternalFileSyncStatuses"
            },
            "type": "array",
            "nullable": true
          },
          "delete_non_synced_only": {
            "title": "Delete Non Synced Only",
            "type": "boolean",
            "default": false
          },
          "send_webhook": {
            "title": "Send Webhook",
            "type": "boolean",
            "default": false
          }
        },
        "type": "object"
      },
      "DirectoryItem": {
        "title": "DirectoryItem",
        "properties": {
          "id": {
            "title": "Id",
            "type": "string"
          },
          "name": {
            "title": "Name",
            "type": "string"
          },
          "is_synced": {
            "title": "Is Synced",
            "type": "boolean",
            "default": false
          },
          "has_children": {
            "title": "Has Children",
            "type": "boolean",
            "default": false
          }
        },
        "type": "object",
        "required": [
          "id",
          "name",
          "is_synced",
          "has_children"
        ]
      },
      "DocumentResponse": {
        "title": "DocumentResponse",
        "properties": {
          "tags": {
            "title": "Tags",
            "additionalProperties": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "number"
                },
                {
                  "type": "integer"
                },
                {
                  "type": "boolean"
                },
                {
                  "items": {
                    "type": "string"
                  },
                  "type": "array"
                },
                {
                  "items": {
                    "type": "number"
                  },
                  "type": "array"
                },
                {
                  "items": {
                    "type": "integer"
                  },
                  "type": "array"
                },
                {
                  "items": {
                    "type": "boolean"
                  },
                  "type": "array"
                }
              ]
            },
            "type": "object",
            "nullable": true
          },
          "content": {
            "title": "Content",
            "type": "string"
          },
          "file_id": {
            "title": "File Id",
            "type": "integer"
          },
          "source": {
            "title": "Source",
            "type": "string",
            "nullable": true
          },
          "source_url": {
            "title": "Source Url",
            "type": "string",
            "nullable": true
          },
          "source_type": {
            "$ref": "#/components/schemas/DataSourceTypeNullable"
          },
          "presigned_url": {
            "title": "Presigned Url",
            "type": "string",
            "nullable": true
          },
          "vector": {
            "title": "Vector",
            "items": {
              "type": "number"
            },
            "type": "array",
            "nullable": true
          },
          "score": {
            "title": "Score",
            "type": "number",
            "nullable": true
          },
          "rank": {
            "title": "Rank",
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "integer"
              }
            ],
            "nullable": true
          },
          "content_metadata": {
            "title": "Content Metadata",
            "type": "object",
            "nullable": true
          }
        },
        "type": "object",
        "required": [
          "content",
          "file_id",
          "source",
          "source_url",
          "source_type",
          "presigned_url",
          "tags",
          "vector",
          "score",
          "rank",
          "content_metadata"
        ]
      },
      "DocumentResponseList": {
        "title": "DocumentResponseList",
        "properties": {
          "documents": {
            "title": "Documents",
            "items": {
              "$ref": "#/components/schemas/DocumentResponse"
            },
            "type": "array"
          }
        },
        "type": "object",
        "required": [
          "documents"
        ]
      },
      "EmbeddingAndChunk": {
        "title": "EmbeddingAndChunk",
        "properties": {
          "user_file_id": {
            "title": "User File Id",
            "type": "integer"
          },
          "chunk_index": {
            "title": "Chunk Index",
            "type": "integer",
            "nullable": true
          },
          "source_content": {
            "title": "Source Content",
            "type": "string"
          },
          "embedding": {
            "title": "Embedding",
            "items": {
              "type": "number"
            },
            "type": "array",
            "nullable": true
          }
        },
        "type": "object",
        "required": [
          "user_file_id",
          "chunk_index",
          "source_content",
          "embedding"
        ]
      },
      "EmbeddingGenerators": {
        "title": "EmbeddingGenerators",
        "type": "string",
        "enum": [
          "OPENAI",
          "AZURE_OPENAI",
          "COHERE_MULTILINGUAL_V3",
          "VERTEX_MULTIMODAL",
          "OPENAI_ADA_LARGE_256",
          "OPENAI_ADA_LARGE_1024",
          "OPENAI_ADA_LARGE_3072",
          "OPENAI_ADA_SMALL_512",
          "OPENAI_ADA_SMALL_1536"
        ]
      },
      "EmbeddingProperties": {
        "title": "EmbeddingProperties",
        "properties": {
          "chunk_size": {
            "title": "Chunk Size",
            "type": "integer",
            "nullable": true
          },
          "chunk_overlap": {
            "title": "Chunk Overlap",
            "type": "integer",
            "nullable": true
          }
        },
        "type": "object",
        "required": [
          "chunk_size",
          "chunk_overlap"
        ]
      },
      "EmbeddingsAndChunksFilters": {
        "title": "EmbeddingsAndChunksFilters",
        "properties": {
          "user_file_id": {
            "title": "User File Id",
            "type": "integer"
          },
          "embedding_model": {
            "$ref": "#/components/schemas/EmbeddingGeneratorsNullable"
          }
        },
        "type": "object",
        "required": [
          "user_file_id"
        ]
      },
      "EmbeddingsAndChunksOrderByColumns": {
        "title": "EmbeddingsAndChunksOrderByColumns",
        "type": "string",
        "enum": [
          "created_at",
          "updated_at",
          "chunk_index"
        ]
      },
      "EmbeddingsAndChunksQueryInput": {
        "title": "EmbeddingsAndChunksQueryInput",
        "properties": {
          "pagination": {
            "$ref": "#/components/schemas/Pagination"
          },
          "order_by": {
            "$ref": "#/components/schemas/EmbeddingsAndChunksOrderByColumns"
          },
          "order_dir": {
            "$ref": "#/components/schemas/OrderDir"
          },
          "filters": {
            "$ref": "#/components/schemas/EmbeddingsAndChunksFilters"
          },
          "include_vectors": {
            "title": "Include Vectors",
            "type": "boolean",
            "default": false
          }
        },
        "type": "object",
        "required": [
          "filters"
        ],
        "x-konfig-properties": {
          "pagination": {
            "default": {
              "limit": 10,
              "offset": 0
            }
          },
          "order_by": {
            "default": "updated_at"
          },
          "order_dir": {
            "default": "asc"
          }
        }
      },
      "EmbeddingsAndChunksResponse": {
        "title": "EmbeddingsAndChunksResponse",
        "properties": {
          "results": {
            "title": "Results",
            "items": {
              "$ref": "#/components/schemas/EmbeddingAndChunk"
            },
            "type": "array"
          },
          "count": {
            "title": "Count",
            "type": "integer"
          }
        },
        "type": "object",
        "required": [
          "results",
          "count"
        ]
      },
      "ExternalFileSyncStatuses": {
        "title": "ExternalFileSyncStatuses",
        "type": "string",
        "enum": [
          "DELAYED",
          "QUEUED_FOR_SYNC",
          "SYNCING",
          "READY",
          "SYNC_ERROR",
          "EVALUATING_RESYNC",
          "RATE_LIMITED",
          "SYNC_ABORTED",
          "QUEUED_FOR_OCR"
        ]
      },
      "ExternalSourceItem": {
        "title": "ExternalSourceItem",
        "properties": {
          "id": {
            "title": "Id",
            "type": "integer"
          },
          "external_id": {
            "title": "External Id",
            "type": "string"
          },
          "source": {
            "$ref": "#/components/schemas/DataSourceType"
          },
          "name": {
            "title": "Name",
            "type": "string"
          },
          "synced_at": {
            "title": "Synced At",
            "type": "string",
            "format": "date-time"
          },
          "is_selectable": {
            "title": "Is Selectable",
            "type": "boolean",
            "nullable": true
          },
          "is_expandable": {
            "title": "Is Expandable",
            "type": "boolean",
            "nullable": true
          },
          "organization_id": {
            "title": "Organization Id",
            "type": "integer"
          },
          "organization_supplied_user_id": {
            "title": "Organization Supplied User Id",
            "type": "string"
          },
          "organization_user_id": {
            "title": "Organization User Id",
            "type": "integer"
          },
          "organization_user_data_source_id": {
            "title": "Organization User Data Source Id",
            "type": "integer"
          },
          "organization_user_file_to_sync_id": {
            "title": "Organization User File To Sync Id",
            "type": "integer",
            "nullable": true
          },
          "parent_external_id": {
            "title": "Parent External Id",
            "type": "string",
            "nullable": true
          },
          "item_type": {
            "title": "Item Type",
            "type": "string",
            "nullable": true
          },
          "root_external_id": {
            "title": "Root External Id",
            "type": "string",
            "nullable": true
          },
          "created_at": {
            "title": "Created At",
            "type": "string",
            "format": "date-time"
          },
          "updated_at": {
            "title": "Updated At",
            "type": "string",
            "format": "date-time"
          }
        },
        "type": "object",
        "required": [
          "id",
          "external_id",
          "source",
          "name",
          "synced_at",
          "is_selectable",
          "is_expandable",
          "organization_id",
          "organization_supplied_user_id",
          "organization_user_id",
          "organization_user_data_source_id",
          "organization_user_file_to_sync_id",
          "parent_external_id",
          "item_type",
          "root_external_id",
          "created_at",
          "updated_at"
        ]
      },
      "FetchURLsResponse": {
        "title": "FetchURLsResponse",
        "properties": {
          "urls": {
            "title": "Urls",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "html_content": {
            "title": "Html Content",
            "type": "string"
          }
        },
        "type": "object",
        "required": [
          "urls",
          "html_content"
        ]
      },
      "FileContentTypes": {
        "title": "FileContentTypes",
        "type": "string",
        "enum": [
          "TEXT",
          "IMAGE"
        ]
      },
      "FileFormats": {
        "title": "FileFormats",
        "type": "string",
        "enum": [
          "TXT",
          "CSV",
          "TSV",
          "PDF",
          "DOCX",
          "PPTX",
          "XLSX",
          "MD",
          "RTF",
          "JSON",
          "NOTION",
          "GOOGLE_DRIVE",
          "GOOGLE_DOCS",
          "GOOGLE_SHEETS",
          "GOOGLE_SLIDES",
          "INTERCOM",
          "DROPBOX",
          "ONEDRIVE",
          "SHAREPOINT",
          "CONFLUENCE",
          "RSS_FEED",
          "GMAIL",
          "OUTLOOK",
          "BOX",
          "ZENDESK",
          "FRESHDESK",
          "WEB_SCRAPE",
          "GITBOOK",
          "JPG",
          "JPG",
          "PNG",
          "MP3",
          "MP4",
          "MP2",
          "AAC",
          "WAV",
          "FLAC",
          "PCM",
          "M4A",
          "OGG",
          "OPUS",
          "WEBM"
        ]
      },
      "FileStatistics": {
        "title": "FileStatistics",
        "properties": {
          "file_format": {
            "$ref": "#/components/schemas/FileFormatsNullable"
          },
          "file_size": {
            "title": "File Size",
            "type": "integer",
            "nullable": true
          },
          "num_characters": {
            "title": "Num Characters",
            "type": "integer",
            "nullable": true
          },
          "num_tokens": {
            "title": "Num Tokens",
            "type": "integer",
            "nullable": true
          },
          "num_embeddings": {
            "title": "Num Embeddings",
            "type": "integer",
            "nullable": true
          }
        },
        "type": "object",
        "required": [
          "file_format",
          "file_size",
          "num_characters",
          "num_tokens",
          "num_embeddings"
        ]
      },
      "FreshDeskConnectRequest": {
        "title": "FreshDeskConnectRequest",
        "properties": {
          "tags": {
            "title": "Tags",
            "default": {
            },
            "type": "object",
            "nullable": true
          },
          "domain": {
            "title": "Domain",
            "type": "string"
          },
          "api_key": {
            "title": "Api Key",
            "type": "string"
          },
          "chunk_size": {
            "title": "Chunk Size",
            "default": 1500,
            "type": "integer",
            "nullable": true
          },
          "chunk_overlap": {
            "title": "Chunk Overlap",
            "default": 20,
            "type": "integer",
            "nullable": true
          },
          "skip_embedding_generation": {
            "title": "Skip Embedding Generation",
            "default": false,
            "type": "boolean",
            "nullable": true
          },
          "embedding_model": {
            "$ref": "#/components/schemas/EmbeddingGeneratorsNullable"
          },
          "generate_sparse_vectors": {
            "title": "Generate Sparse Vectors",
            "default": false,
            "type": "boolean",
            "nullable": true
          },
          "prepend_filename_to_chunks": {
            "title": "Prepend Filename To Chunks",
            "default": false,
            "type": "boolean",
            "nullable": true
          }
        },
        "type": "object",
        "required": [
          "domain",
          "api_key"
        ]
      },
      "GenericSuccessResponse": {
        "title": "GenericSuccessResponse",
        "properties": {
          "success": {
            "title": "Success",
            "type": "boolean"
          }
        },
        "type": "object",
        "required": [
          "success"
        ]
      },
      "GetEmbeddingDocumentsBody": {
        "title": "GetEmbeddingDocumentsBody",
        "properties": {
          "tags": {
            "title": "Tags",
            "description": "A set of tags to limit the search to. Deprecated and may be removed in the future.",
            "additionalProperties": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "integer"
                },
                {
                  "type": "boolean"
                },
                {
                  "items": {
                    "type": "string"
                  },
                  "type": "array"
                },
                {
                  "items": {
                    "type": "integer"
                  },
                  "type": "array"
                },
                {
                  "items": {
                    "type": "boolean"
                  },
                  "type": "array"
                }
              ]
            },
            "type": "object",
            "nullable": true
          },
          "query": {
            "title": "Query",
            "description": "Query for which to get related chunks and embeddings.",
            "type": "string",
            "minLength": 1
          },
          "query_vector": {
            "title": "Query Vector",
            "description": "Optional query vector for which to get related chunks and embeddings. It must have been\n        generated by the same model used to generate the embeddings across which the search is being conducted. Cannot\n        provide both `query` and `query_vector`.",
            "items": {
              "type": "number"
            },
            "type": "array",
            "nullable": true
          },
          "k": {
            "title": "K",
            "description": "Number of related chunks to return.",
            "type": "integer",
            "minimum": 1
          },
          "file_ids": {
            "title": "File Ids",
            "description": "Optional list of file IDs to limit the search to",
            "items": {
              "type": "integer"
            },
            "type": "array",
            "nullable": true
          },
          "parent_file_ids": {
            "title": "Parent File Ids",
            "description": "Optional list of parent file IDs to limit the search to. A parent file describes a file to which\n        another file belongs (e.g. a folder)",
            "items": {
              "type": "integer"
            },
            "type": "array",
            "nullable": true
          },
          "tags_v2": {
            "title": "Tags V2",
            "description": "A set of tags to limit the search to. Use this instead of `tags`, which is deprecated.",
            "type": "object",
            "nullable": true,
            "example": {
              "OR": [
                {
                  "key": "subject",
                  "negate": false,
                  "value": "holy-bible"
                },
                {
                  "key": "person-of-interest",
                  "negate": false,
                  "value": "jesus christ"
                },
                {
                  "key": "genre",
                  "negate": true,
                  "value": "fiction"
                },
                {
                  "AND": [
                    {
                      "key": "subject",
                      "negate": true,
                      "value": "tao-te-ching"
                    },
                    {
                      "key": "author",
                      "negate": false,
                      "value": "lao-tzu"
                    }
                  ]
                }
              ]
            },
            "x-examples": [
              {
                "OR": [
                  {
                    "key": "subject",
                    "negate": false,
                    "value": "holy-bible"
                  },
                  {
                    "key": "person-of-interest",
                    "negate": false,
                    "value": "jesus christ"
                  },
                  {
                    "key": "genre",
                    "negate": true,
                    "value": "fiction"
                  },
                  {
                    "AND": [
                      {
                        "key": "subject",
                        "negate": true,
                        "value": "tao-te-ching"
                      },
                      {
                        "key": "author",
                        "negate": false,
                        "value": "lao-tzu"
                      }
                    ]
                  }
                ]
              }
            ]
          },
          "include_tags": {
            "title": "Include Tags",
            "description": "Flag to control whether or not to include tags for each chunk in the response.",
            "type": "boolean",
            "nullable": true
          },
          "include_vectors": {
            "title": "Include Vectors",
            "description": "Flag to control whether or not to include embedding vectors in the response.",
            "type": "boolean",
            "nullable": true
          },
          "include_raw_file": {
            "title": "Include Raw File",
            "description": "Flag to control whether or not to include a signed URL to the raw file containing each chunk\n        in the response.",
            "type": "boolean",
            "nullable": true
          },
          "hybrid_search": {
            "title": "Hybrid Search",
            "description": "Flag to control whether or not to perform hybrid search.",
            "type": "boolean",
            "nullable": true
          },
          "hybrid_search_tuning_parameters": {
            "$ref": "#/components/schemas/HybridSearchTuningParamsNullable"
          },
          "media_type": {
            "$ref": "#/components/schemas/FileContentTypesNullable"
          },
          "embedding_model": {
            "$ref": "#/components/schemas/EmbeddingGeneratorsNullable"
          }
        },
        "type": "object",
        "required": [
          "query",
          "k"
        ]
      },
      "GitbookConnectRequest": {
        "title": "GitbookConnectRequest",
        "properties": {
          "organization": {
            "title": "Organization",
            "type": "string"
          },
          "access_token": {
            "title": "Access Token",
            "type": "string"
          }
        },
        "type": "object",
        "required": [
          "organization",
          "access_token"
        ]
      },
      "GitbookSyncRequest": {
        "title": "GitbookSyncRequest",
        "properties": {
          "tags": {
            "title": "Tags",
            "default": {
            },
            "type": "object",
            "nullable": true
          },
          "space_ids": {
            "title": "Space Ids",
            "items": {
              "type": "string"
            },
            "type": "array",
            "maxItems": 20
          },
          "data_source_id": {
            "title": "Data Source Id",
            "type": "integer"
          },
          "chunk_size": {
            "title": "Chunk Size",
            "default": 1500,
            "type": "integer",
            "nullable": true
          },
          "chunk_overlap": {
            "title": "Chunk Overlap",
            "default": 20,
            "type": "integer",
            "nullable": true
          },
          "skip_embedding_generation": {
            "title": "Skip Embedding Generation",
            "default": false,
            "type": "boolean",
            "nullable": true
          },
          "embedding_model": {
            "$ref": "#/components/schemas/EmbeddingGenerators"
          },
          "generate_sparse_vectors": {
            "title": "Generate Sparse Vectors",
            "default": false,
            "type": "boolean",
            "nullable": true
          },
          "prepend_filename_to_chunks": {
            "title": "Prepend Filename To Chunks",
            "default": false,
            "type": "boolean",
            "nullable": true
          }
        },
        "type": "object",
        "required": [
          "space_ids",
          "data_source_id"
        ],
        "x-konfig-properties": {
          "embedding_model": {
            "default": "OPENAI"
          }
        }
      },
      "GmailSyncInput": {
        "title": "GmailSyncInput",
        "properties": {
          "tags": {
            "title": "Tags",
            "default": {
            },
            "type": "object",
            "nullable": true
          },
          "filters": {
            "title": "Filters",
            "type": "object"
          },
          "chunk_size": {
            "title": "Chunk Size",
            "default": 1500,
            "type": "integer",
            "nullable": true
          },
          "chunk_overlap": {
            "title": "Chunk Overlap",
            "default": 20,
            "type": "integer",
            "nullable": true
          },
          "skip_embedding_generation": {
            "title": "Skip Embedding Generation",
            "default": false,
            "type": "boolean",
            "nullable": true
          },
          "embedding_model": {
            "$ref": "#/components/schemas/EmbeddingGenerators"
          },
          "generate_sparse_vectors": {
            "title": "Generate Sparse Vectors",
            "default": false,
            "type": "boolean",
            "nullable": true
          },
          "prepend_filename_to_chunks": {
            "title": "Prepend Filename To Chunks",
            "default": false,
            "type": "boolean",
            "nullable": true
          }
        },
        "type": "object",
        "required": [
          "filters"
        ],
        "x-konfig-properties": {
          "embedding_model": {
            "default": "OPENAI"
          }
        }
      },
      "HTTPValidationError": {
        "title": "HTTPValidationError",
        "properties": {
          "detail": {
            "title": "Detail",
            "items": {
              "$ref": "#/components/schemas/ValidationError"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "HybridSearchTuningParams": {
        "title": "HybridSearchTuningParams",
        "properties": {
          "weight_a": {
            "title": "Weight A",
            "type": "number"
          },
          "weight_b": {
            "title": "Weight B",
            "type": "number"
          }
        },
        "type": "object",
        "required": [
          "weight_a",
          "weight_b"
        ]
      },
      "ListDataSourceItemsRequest": {
        "title": "ListDataSourceItemsRequest",
        "properties": {
          "data_source_id": {
            "title": "Data Source Id",
            "type": "integer"
          },
          "parent_id": {
            "title": "Parent Id",
            "type": "string",
            "nullable": true
          },
          "pagination": {
            "$ref": "#/components/schemas/Pagination"
          }
        },
        "type": "object",
        "required": [
          "data_source_id"
        ],
        "x-konfig-properties": {
          "pagination": {
            "default": {
              "limit": 10,
              "offset": 0
            }
          }
        }
      },
      "ListDataSourceItemsResponse": {
        "title": "ListDataSourceItemsResponse",
        "properties": {
          "items": {
            "title": "Items",
            "items": {
              "$ref": "#/components/schemas/ExternalSourceItem"
            },
            "type": "array"
          },
          "count": {
            "title": "Count",
            "type": "integer"
          }
        },
        "type": "object",
        "required": [
          "items",
          "count"
        ]
      },
      "ListRequest": {
        "title": "ListRequest",
        "properties": {
          "data_source_id": {
            "title": "Data Source Id",
            "type": "integer"
          },
          "parent_id": {
            "title": "Parent Id",
            "type": "string",
            "nullable": true
          }
        },
        "type": "object",
        "required": [
          "data_source_id"
        ]
      },
      "ListResponse": {
        "title": "ListResponse",
        "properties": {
          "data": {
            "title": "Data",
            "items": {
              "$ref": "#/components/schemas/DirectoryItem"
            },
            "type": "array"
          }
        },
        "type": "object",
        "required": [
          "data"
        ]
      },
      "ModifyUserConfigurationInput": {
        "title": "ModifyUserConfigurationInput",
        "properties": {
          "configuration_key_name": {
            "$ref": "#/components/schemas/ConfigurationKeys"
          },
          "value": {
            "title": "Value",
            "type": "object"
          }
        },
        "type": "object",
        "required": [
          "configuration_key_name",
          "value"
        ]
      },
      "OAuthURLRequest": {
        "title": "OAuthURLRequest",
        "properties": {
          "tags": {
            "title": "Tags",
            "nullable": true
          },
          "scope": {
            "title": "Scope",
            "type": "string",
            "nullable": true
          },
          "service": {
            "$ref": "#/components/schemas/DataSourceType"
          },
          "chunk_size": {
            "title": "Chunk Size",
            "default": 1500,
            "type": "integer",
            "nullable": true
          },
          "chunk_overlap": {
            "title": "Chunk Overlap",
            "default": 20,
            "type": "integer",
            "nullable": true
          },
          "skip_embedding_generation": {
            "title": "Skip Embedding Generation",
            "default": false,
            "type": "boolean",
            "nullable": true
          },
          "embedding_model": {
            "$ref": "#/components/schemas/EmbeddingGeneratorsNullable"
          },
          "zendesk_subdomain": {
            "title": "Zendesk Subdomain",
            "type": "string",
            "nullable": true
          },
          "microsoft_tenant": {
            "title": "Microsoft Tenant",
            "type": "string",
            "nullable": true
          },
          "sharepoint_site_name": {
            "title": "Sharepoint Site Name",
            "type": "string",
            "nullable": true
          },
          "confluence_subdomain": {
            "title": "Confluence Subdomain",
            "type": "string",
            "nullable": true
          },
          "generate_sparse_vectors": {
            "title": "Generate Sparse Vectors",
            "default": false,
            "type": "boolean",
            "nullable": true
          },
          "prepend_filename_to_chunks": {
            "title": "Prepend Filename To Chunks",
            "default": false,
            "type": "boolean",
            "nullable": true
          },
          "max_items_per_chunk": {
            "title": "Max Items Per Chunk",
            "type": "integer",
            "nullable": true
          }
        },
        "type": "object",
        "required": [
          "service"
        ]
      },
      "OrderDir": {
        "title": "OrderDir",
        "type": "string",
        "enum": [
          "desc",
          "asc"
        ]
      },
      "OrganizationResponse": {
        "title": "OrganizationResponse",
        "properties": {
          "id": {
            "title": "Id",
            "type": "integer"
          },
          "name": {
            "title": "Name",
            "type": "string"
          },
          "nickname": {
            "title": "Nickname",
            "type": "string",
            "nullable": true
          },
          "remove_branding": {
            "title": "Remove Branding",
            "type": "boolean"
          },
          "custom_branding": {
            "title": "Custom Branding",
            "type": "object",
            "nullable": true
          },
          "custom_limits": {
            "title": "Custom Limits",
            "type": "object",
            "nullable": true
          },
          "aggregate_file_size": {
            "title": "Aggregate File Size",
            "type": "object"
          },
          "aggregate_num_characters": {
            "title": "Aggregate Num Characters",
            "type": "object"
          },
          "aggregate_num_tokens": {
            "title": "Aggregate Num Tokens",
            "type": "object"
          },
          "aggregate_num_embeddings": {
            "title": "Aggregate Num Embeddings",
            "type": "object"
          },
          "created_at": {
            "title": "Created At",
            "type": "string",
            "format": "date-time"
          },
          "updated_at": {
            "title": "Updated At",
            "type": "string",
            "format": "date-time"
          }
        },
        "type": "object",
        "required": [
          "id",
          "name",
          "nickname",
          "remove_branding",
          "custom_branding",
          "custom_limits",
          "aggregate_file_size",
          "aggregate_num_characters",
          "aggregate_num_tokens",
          "aggregate_num_embeddings",
          "created_at",
          "updated_at"
        ]
      },
      "OrganizationUserDataSourceAPI": {
        "title": "OrganizationUserDataSourceAPI",
        "properties": {
          "id": {
            "title": "Id",
            "type": "integer"
          },
          "data_source_external_id": {
            "title": "Data Source External Id",
            "type": "string",
            "nullable": true
          },
          "data_source_type": {
            "$ref": "#/components/schemas/DataSourceType"
          },
          "sync_status": {
            "$ref": "#/components/schemas/DataSourceSyncStatuses"
          },
          "source_items_synced_at": {
            "title": "Source Items Synced At",
            "type": "string",
            "format": "date-time",
            "nullable": true
          },
          "organization_user_id": {
            "title": "Organization User Id",
            "type": "integer"
          },
          "organization_id": {
            "title": "Organization Id",
            "type": "integer"
          },
          "organization_supplied_user_id": {
            "title": "Organization Supplied User Id",
            "type": "string"
          },
          "revoked_access": {
            "title": "Revoked Access",
            "type": "boolean"
          },
          "last_synced_at": {
            "title": "Last Synced At",
            "type": "string",
            "format": "date-time"
          },
          "last_sync_action": {
            "$ref": "#/components/schemas/DataSourceLastSyncActions"
          },
          "created_at": {
            "title": "Created At",
            "type": "string",
            "format": "date-time"
          },
          "updated_at": {
            "title": "Updated At",
            "type": "string",
            "format": "date-time"
          }
        },
        "type": "object",
        "required": [
          "id",
          "data_source_external_id",
          "data_source_type",
          "sync_status",
          "source_items_synced_at",
          "organization_user_id",
          "organization_id",
          "organization_supplied_user_id",
          "revoked_access",
          "last_synced_at",
          "last_sync_action",
          "created_at",
          "updated_at"
        ]
      },
      "OrganizationUserDataSourceFilters": {
        "title": "OrganizationUserDataSourceFilters",
        "properties": {
          "source": {
            "$ref": "#/components/schemas/DataSourceTypeNullable"
          },
          "ids": {
            "title": "Ids",
            "items": {
              "type": "integer"
            },
            "type": "array",
            "nullable": true
          },
          "revoked_access": {
            "title": "Revoked Access",
            "type": "boolean",
            "nullable": true
          }
        },
        "type": "object"
      },
      "OrganizationUserDataSourceOrderByColumns": {
        "title": "OrganizationUserDataSourceOrderByColumns",
        "type": "string",
        "enum": [
          "created_at",
          "updated_at"
        ]
      },
      "OrganizationUserDataSourceQueryInput": {
        "title": "OrganizationUserDataSourceQueryInput",
        "properties": {
          "pagination": {
            "$ref": "#/components/schemas/Pagination"
          },
          "order_by": {
            "$ref": "#/components/schemas/OrganizationUserDataSourceOrderByColumns"
          },
          "order_dir": {
            "$ref": "#/components/schemas/OrderDir"
          },
          "filters": {
            "$ref": "#/components/schemas/OrganizationUserDataSourceFilters"
          }
        },
        "type": "object",
        "x-konfig-properties": {
          "pagination": {
            "default": {
              "limit": 10,
              "offset": 0
            }
          },
          "order_by": {
            "default": "updated_at"
          },
          "order_dir": {
            "default": "asc"
          },
          "filters": {
            "default": {
            }
          }
        }
      },
      "OrganizationUserDataSourceResponse": {
        "title": "OrganizationUserDataSourceResponse",
        "properties": {
          "results": {
            "title": "Results",
            "items": {
              "$ref": "#/components/schemas/OrganizationUserDataSourceAPI"
            },
            "type": "array"
          },
          "count": {
            "title": "Count",
            "type": "integer"
          }
        },
        "type": "object",
        "required": [
          "results",
          "count"
        ]
      },
      "OrganizationUserFileTagCreate": {
        "title": "OrganizationUserFileTagCreate",
        "properties": {
          "tags": {
            "title": "Tags",
            "additionalProperties": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "integer"
                },
                {
                  "type": "boolean"
                },
                {
                  "items": {
                    "type": "string"
                  },
                  "type": "array"
                },
                {
                  "items": {
                    "type": "integer"
                  },
                  "type": "array"
                },
                {
                  "items": {
                    "type": "boolean"
                  },
                  "type": "array"
                }
              ]
            },
            "type": "object"
          },
          "organization_user_file_id": {
            "title": "Organization User File Id",
            "type": "integer"
          }
        },
        "type": "object",
        "required": [
          "organization_user_file_id",
          "tags"
        ]
      },
      "OrganizationUserFileTagsRemove": {
        "title": "OrganizationUserFileTagsRemove",
        "properties": {
          "tags": {
            "title": "Tags",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "organization_user_file_id": {
            "title": "Organization User File Id",
            "type": "integer"
          }
        },
        "type": "object",
        "required": [
          "organization_user_file_id",
          "tags"
        ]
      },
      "OrganizationUserFilesToSyncFilters": {
        "title": "OrganizationUserFilesToSyncFilters",
        "properties": {
          "tags": {
            "title": "Tags",
            "additionalProperties": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "integer"
                },
                {
                  "type": "boolean"
                },
                {
                  "items": {
                    "type": "string"
                  },
                  "type": "array"
                },
                {
                  "items": {
                    "type": "integer"
                  },
                  "type": "array"
                },
                {
                  "items": {
                    "type": "boolean"
                  },
                  "type": "array"
                }
              ]
            },
            "type": "object",
            "nullable": true
          },
          "source": {
            "title": "Source",
            "anyOf": [
              {
                "$ref": "#/components/schemas/DataSourceType"
              },
              {
                "items": {
                  "$ref": "#/components/schemas/DataSourceType"
                },
                "type": "array"
              }
            ],
            "nullable": true
          },
          "name": {
            "title": "Name",
            "type": "string",
            "nullable": true
          },
          "tags_v2": {
            "title": "Tags V2",
            "type": "object",
            "nullable": true
          },
          "ids": {
            "title": "Ids",
            "items": {
              "type": "integer"
            },
            "type": "array",
            "nullable": true
          },
          "external_file_ids": {
            "title": "External File Ids",
            "items": {
              "type": "string"
            },
            "type": "array",
            "nullable": true
          },
          "sync_statuses": {
            "title": "Sync Statuses",
            "items": {
              "$ref": "#/components/schemas/ExternalFileSyncStatuses"
            },
            "type": "array",
            "nullable": true
          },
          "parent_file_ids": {
            "title": "Parent File Ids",
            "items": {
              "type": "integer"
            },
            "type": "array",
            "nullable": true
          },
          "organization_user_data_source_id": {
            "title": "Organization User Data Source Id",
            "items": {
              "type": "integer"
            },
            "type": "array",
            "nullable": true
          },
          "embedding_generators": {
            "title": "Embedding Generators",
            "items": {
              "$ref": "#/components/schemas/EmbeddingGenerators"
            },
            "type": "array",
            "nullable": true
          },
          "root_files_only": {
            "title": "Root Files Only",
            "type": "boolean",
            "nullable": true
          }
        },
        "type": "object"
      },
      "OrganizationUserFilesToSyncOrderByTypes": {
        "title": "OrganizationUserFilesToSyncOrderByTypes",
        "type": "string",
        "enum": [
          "created_at",
          "updated_at",
          "name",
          "last_sync",
          "file_size"
        ]
      },
      "OrganizationUserFilesToSyncQueryInput": {
        "title": "OrganizationUserFilesToSyncQueryInput",
        "properties": {
          "pagination": {
            "$ref": "#/components/schemas/Pagination"
          },
          "order_by": {
            "$ref": "#/components/schemas/OrganizationUserFilesToSyncOrderByTypes"
          },
          "order_dir": {
            "$ref": "#/components/schemas/OrderDir"
          },
          "filters": {
            "$ref": "#/components/schemas/OrganizationUserFilesToSyncFilters"
          },
          "include_raw_file": {
            "title": "Include Raw File",
            "type": "boolean",
            "nullable": true
          },
          "include_parsed_text_file": {
            "title": "Include Parsed Text File",
            "type": "boolean",
            "nullable": true
          },
          "include_additional_files": {
            "title": "Include Additional Files",
            "type": "boolean",
            "nullable": true
          }
        },
        "type": "object",
        "x-konfig-properties": {
          "pagination": {
            "default": {
              "limit": 10,
              "offset": 0
            }
          },
          "order_by": {
            "default": "updated_at"
          },
          "order_dir": {
            "default": "asc"
          },
          "filters": {
            "default": {
            }
          }
        }
      },
      "OutlookSyncInput": {
        "title": "OutlookSyncInput",
        "properties": {
          "tags": {
            "title": "Tags",
            "default": {
            },
            "type": "object",
            "nullable": true
          },
          "folder": {
            "title": "Folder",
            "default": "Inbox",
            "type": "string",
            "nullable": true
          },
          "filters": {
            "title": "Filters",
            "type": "object"
          },
          "chunk_size": {
            "title": "Chunk Size",
            "default": 1500,
            "type": "integer",
            "nullable": true
          },
          "chunk_overlap": {
            "title": "Chunk Overlap",
            "default": 20,
            "type": "integer",
            "nullable": true
          },
          "skip_embedding_generation": {
            "title": "Skip Embedding Generation",
            "default": false,
            "type": "boolean",
            "nullable": true
          },
          "embedding_model": {
            "$ref": "#/components/schemas/EmbeddingGenerators"
          },
          "generate_sparse_vectors": {
            "title": "Generate Sparse Vectors",
            "default": false,
            "type": "boolean",
            "nullable": true
          },
          "prepend_filename_to_chunks": {
            "title": "Prepend Filename To Chunks",
            "default": false,
            "type": "boolean",
            "nullable": true
          }
        },
        "type": "object",
        "required": [
          "filters"
        ],
        "x-konfig-properties": {
          "embedding_model": {
            "default": "OPENAI"
          }
        }
      },
      "Pagination": {
        "title": "Pagination",
        "properties": {
          "limit": {
            "title": "Limit",
            "type": "integer",
            "default": 10
          },
          "offset": {
            "title": "Offset",
            "type": "integer",
            "default": 0
          }
        },
        "type": "object"
      },
      "PresignedURLResponse": {
        "title": "PresignedURLResponse",
        "properties": {
          "presigned_url": {
            "title": "Presigned Url",
            "type": "string"
          }
        },
        "type": "object",
        "required": [
          "presigned_url"
        ]
      },
      "RSSFeedInput": {
        "title": "RSSFeedInput",
        "properties": {
          "tags": {
            "title": "Tags",
            "default": {
            },
            "type": "object",
            "nullable": true
          },
          "url": {
            "title": "Url",
            "type": "string"
          },
          "chunk_size": {
            "title": "Chunk Size",
            "default": 1500,
            "type": "integer",
            "nullable": true
          },
          "chunk_overlap": {
            "title": "Chunk Overlap",
            "default": 20,
            "type": "integer",
            "nullable": true
          },
          "skip_embedding_generation": {
            "title": "Skip Embedding Generation",
            "default": false,
            "type": "boolean",
            "nullable": true
          },
          "embedding_model": {
            "$ref": "#/components/schemas/EmbeddingGenerators"
          },
          "generate_sparse_vectors": {
            "title": "Generate Sparse Vectors",
            "default": false,
            "type": "boolean",
            "nullable": true
          },
          "prepend_filename_to_chunks": {
            "title": "Prepend Filename To Chunks",
            "default": false,
            "type": "boolean",
            "nullable": true
          }
        },
        "type": "object",
        "required": [
          "url"
        ],
        "x-konfig-properties": {
          "embedding_model": {
            "default": "OPENAI"
          }
        }
      },
      "RawTextInput": {
        "title": "RawTextInput",
        "properties": {
          "contents": {
            "title": "Contents",
            "type": "string"
          },
          "name": {
            "title": "Name",
            "type": "string",
            "nullable": true
          },
          "chunk_size": {
            "title": "Chunk Size",
            "type": "integer",
            "nullable": true
          },
          "chunk_overlap": {
            "title": "Chunk Overlap",
            "type": "integer",
            "nullable": true
          },
          "skip_embedding_generation": {
            "title": "Skip Embedding Generation",
            "type": "boolean",
            "default": false
          },
          "overwrite_file_id": {
            "title": "Overwrite File Id",
            "type": "integer",
            "nullable": true
          },
          "embedding_model": {
            "$ref": "#/components/schemas/EmbeddingGeneratorsNullable"
          },
          "generate_sparse_vectors": {
            "title": "Generate Sparse Vectors",
            "default": false,
            "type": "boolean",
            "nullable": true
          }
        },
        "type": "object",
        "required": [
          "contents"
        ]
      },
      "ResyncFileQueryInput": {
        "title": "ResyncFileQueryInput",
        "properties": {
          "file_id": {
            "title": "File Id",
            "type": "integer"
          },
          "chunk_size": {
            "title": "Chunk Size",
            "type": "integer",
            "nullable": true
          },
          "chunk_overlap": {
            "title": "Chunk Overlap",
            "type": "integer",
            "nullable": true
          }
        },
        "type": "object",
        "required": [
          "file_id"
        ]
      },
      "RevokeAccessTokenInput": {
        "title": "RevokeAccessTokenInput",
        "properties": {
          "data_source_id": {
            "title": "Data Source Id",
            "type": "integer"
          }
        },
        "type": "object",
        "required": [
          "data_source_id"
        ]
      },
      "S3AuthRequest": {
        "title": "S3AuthRequest",
        "properties": {
          "access_key": {
            "title": "Access Key",
            "type": "string"
          },
          "access_key_secret": {
            "title": "Access Key Secret",
            "type": "string"
          }
        },
        "type": "object",
        "required": [
          "access_key",
          "access_key_secret"
        ]
      },
      "S3FileSyncInput": {
        "title": "S3FileSyncInput",
        "properties": {
          "tags": {
            "title": "Tags",
            "default": {
            },
            "type": "object",
            "nullable": true
          },
          "ids": {
            "title": "Ids",
            "items": {
              "$ref": "#/components/schemas/S3GetFileInput"
            },
            "type": "array"
          },
          "chunk_size": {
            "title": "Chunk Size",
            "default": 1500,
            "type": "integer",
            "nullable": true
          },
          "chunk_overlap": {
            "title": "Chunk Overlap",
            "default": 20,
            "type": "integer",
            "nullable": true
          },
          "skip_embedding_generation": {
            "title": "Skip Embedding Generation",
            "default": false,
            "type": "boolean",
            "nullable": true
          },
          "embedding_model": {
            "$ref": "#/components/schemas/EmbeddingGenerators"
          },
          "generate_sparse_vectors": {
            "title": "Generate Sparse Vectors",
            "default": false,
            "type": "boolean",
            "nullable": true
          },
          "prepend_filename_to_chunks": {
            "title": "Prepend Filename To Chunks",
            "default": false,
            "type": "boolean",
            "nullable": true
          },
          "max_items_per_chunk": {
            "title": "Max Items Per Chunk",
            "type": "integer",
            "nullable": true
          }
        },
        "type": "object",
        "required": [
          "ids"
        ],
        "x-konfig-properties": {
          "embedding_model": {
            "default": "OPENAI"
          }
        }
      },
      "S3GetFileInput": {
        "title": "S3GetFileInput",
        "properties": {
          "id": {
            "title": "Id",
            "type": "string",
            "nullable": true
          },
          "bucket": {
            "title": "Bucket",
            "type": "string",
            "nullable": true
          }
        },
        "type": "object"
      },
      "SingleChunksAndEmbeddingsUploadInput": {
        "title": "SingleChunksAndEmbeddingsUploadInput",
        "properties": {
          "file_id": {
            "title": "File Id",
            "type": "integer"
          },
          "chunk_size": {
            "title": "Chunk Size",
            "type": "integer",
            "nullable": true
          },
          "chunk_overlap": {
            "title": "Chunk Overlap",
            "type": "integer",
            "nullable": true
          },
          "chunks_and_embeddings": {
            "title": "Chunks And Embeddings",
            "items": {
              "$ref": "#/components/schemas/ChunksAndEmbeddings"
            },
            "type": "array"
          }
        },
        "type": "object",
        "required": [
          "file_id",
          "chunks_and_embeddings"
        ]
      },
      "SitemapScrapeRequest": {
        "title": "SitemapScrapeRequest",
        "properties": {
          "tags": {
            "title": "Tags",
            "default": {
            },
            "additionalProperties": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "integer"
                },
                {
                  "type": "boolean"
                },
                {
                  "items": {
                    "type": "string"
                  },
                  "type": "array"
                },
                {
                  "items": {
                    "type": "integer"
                  },
                  "type": "array"
                },
                {
                  "items": {
                    "type": "boolean"
                  },
                  "type": "array"
                }
              ]
            },
            "type": "object",
            "nullable": true
          },
          "url": {
            "title": "Url",
            "type": "string"
          },
          "max_pages_to_scrape": {
            "title": "Max Pages To Scrape",
            "type": "integer",
            "nullable": true
          },
          "chunk_size": {
            "title": "Chunk Size",
            "default": 1500,
            "type": "integer",
            "nullable": true
          },
          "chunk_overlap": {
            "title": "Chunk Overlap",
            "default": 20,
            "type": "integer",
            "nullable": true
          },
          "skip_embedding_generation": {
            "title": "Skip Embedding Generation",
            "default": false,
            "type": "boolean",
            "nullable": true
          },
          "enable_auto_sync": {
            "title": "Enable Auto Sync",
            "default": false,
            "type": "boolean",
            "nullable": true
          },
          "generate_sparse_vectors": {
            "title": "Generate Sparse Vectors",
            "default": false,
            "type": "boolean",
            "nullable": true
          },
          "prepend_filename_to_chunks": {
            "title": "Prepend Filename To Chunks",
            "default": false,
            "type": "boolean",
            "nullable": true
          },
          "html_tags_to_skip": {
            "title": "Html Tags To Skip",
            "default": [
            ],
            "items": {
              "type": "string"
            },
            "type": "array",
            "nullable": true
          },
          "css_classes_to_skip": {
            "title": "Css Classes To Skip",
            "default": [
            ],
            "items": {
              "type": "string"
            },
            "type": "array",
            "nullable": true
          },
          "css_selectors_to_skip": {
            "title": "Css Selectors To Skip",
            "default": [
            ],
            "items": {
              "type": "string"
            },
            "type": "array",
            "nullable": true
          },
          "embedding_model": {
            "$ref": "#/components/schemas/EmbeddingGenerators"
          }
        },
        "type": "object",
        "required": [
          "url"
        ],
        "x-konfig-properties": {
          "embedding_model": {
            "default": "OPENAI"
          }
        }
      },
      "SyncDirectoryRequest": {
        "title": "SyncDirectoryRequest",
        "properties": {
          "data_source_id": {
            "title": "Data Source Id",
            "type": "integer"
          }
        },
        "type": "object",
        "required": [
          "data_source_id"
        ]
      },
      "SyncFilesRequest": {
        "title": "SyncFilesRequest",
        "properties": {
          "tags": {
            "title": "Tags",
            "default": {
            },
            "type": "object",
            "nullable": true
          },
          "data_source_id": {
            "title": "Data Source Id",
            "type": "integer"
          },
          "ids": {
            "title": "Ids",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "chunk_size": {
            "title": "Chunk Size",
            "default": 1500,
            "type": "integer",
            "nullable": true
          },
          "chunk_overlap": {
            "title": "Chunk Overlap",
            "default": 20,
            "type": "integer",
            "nullable": true
          },
          "skip_embedding_generation": {
            "title": "Skip Embedding Generation",
            "default": false,
            "type": "boolean",
            "nullable": true
          },
          "embedding_model": {
            "$ref": "#/components/schemas/EmbeddingGeneratorsNullable"
          },
          "generate_sparse_vectors": {
            "title": "Generate Sparse Vectors",
            "default": false,
            "type": "boolean",
            "nullable": true
          },
          "prepend_filename_to_chunks": {
            "title": "Prepend Filename To Chunks",
            "default": false,
            "type": "boolean",
            "nullable": true
          },
          "max_items_per_chunk": {
            "title": "Max Items Per Chunk",
            "type": "integer",
            "nullable": true
          }
        },
        "type": "object",
        "required": [
          "data_source_id",
          "ids"
        ]
      },
      "TextEmbeddingGenerators": {
        "title": "TextEmbeddingGenerators",
        "type": "string",
        "enum": [
          "OPENAI",
          "AZURE_OPENAI",
          "COHERE_MULTILINGUAL_V3",
          "OPENAI_ADA_LARGE_256",
          "OPENAI_ADA_LARGE_1024",
          "OPENAI_ADA_LARGE_3072",
          "OPENAI_ADA_SMALL_512",
          "OPENAI_ADA_SMALL_1536"
        ]
      },
      "TokenResponse": {
        "title": "TokenResponse",
        "properties": {
          "access_token": {
            "title": "Access Token",
            "type": "string"
          },
          "refresh_token": {
            "title": "Refresh Token",
            "type": "string"
          }
        },
        "type": "object",
        "required": [
          "access_token",
          "refresh_token"
        ]
      },
      "UploadFileFromUrlInput": {
        "title": "UploadFileFromUrlInput",
        "properties": {
          "url": {
            "title": "Url",
            "type": "string"
          },
          "file_name": {
            "title": "File Name",
            "type": "string",
            "nullable": true
          },
          "chunk_size": {
            "title": "Chunk Size",
            "type": "integer",
            "nullable": true
          },
          "chunk_overlap": {
            "title": "Chunk Overlap",
            "type": "integer",
            "nullable": true
          },
          "skip_embedding_generation": {
            "title": "Skip Embedding Generation",
            "type": "boolean",
            "default": false
          },
          "set_page_as_boundary": {
            "title": "Set Page As Boundary",
            "type": "boolean",
            "default": false
          },
          "embedding_model": {
            "$ref": "#/components/schemas/EmbeddingGenerators"
          },
          "generate_sparse_vectors": {
            "title": "Generate Sparse Vectors",
            "type": "boolean",
            "default": false
          },
          "use_textract": {
            "title": "Use Textract",
            "type": "boolean",
            "default": false
          },
          "prepend_filename_to_chunks": {
            "title": "Prepend Filename To Chunks",
            "type": "boolean",
            "default": false
          },
          "max_items_per_chunk": {
            "title": "Max Items Per Chunk",
            "type": "integer",
            "nullable": true
          }
        },
        "type": "object",
        "required": [
          "url"
        ],
        "x-konfig-properties": {
          "embedding_model": {
            "default": "OPENAI"
          }
        }
      },
      "UserFile": {
        "title": "UserFile",
        "properties": {
          "tags": {
            "title": "Tags",
            "type": "object",
            "nullable": true
          },
          "id": {
            "title": "Id",
            "type": "integer"
          },
          "source": {
            "$ref": "#/components/schemas/DataSourceType"
          },
          "organization_id": {
            "title": "Organization Id",
            "type": "integer"
          },
          "organization_supplied_user_id": {
            "title": "Organization Supplied User Id",
            "type": "string"
          },
          "organization_user_data_source_id": {
            "title": "Organization User Data Source Id",
            "type": "integer",
            "nullable": true
          },
          "external_file_id": {
            "title": "External File Id",
            "type": "string"
          },
          "external_url": {
            "title": "External Url",
            "type": "string",
            "nullable": true
          },
          "sync_status": {
            "$ref": "#/components/schemas/ExternalFileSyncStatuses"
          },
          "sync_error_message": {
            "title": "Sync Error Message",
            "type": "string",
            "nullable": true
          },
          "last_sync": {
            "title": "Last Sync",
            "type": "string",
            "format": "date-time",
            "nullable": true
          },
          "file_statistics": {
            "$ref": "#/components/schemas/FileStatisticsNullable"
          },
          "file_metadata": {
            "title": "File Metadata",
            "type": "object",
            "nullable": true
          },
          "embedding_properties": {
            "title": "Embedding Properties",
            "additionalProperties": {
              "$ref": "#/components/schemas/EmbeddingProperties"
            },
            "type": "object",
            "nullable": true
          },
          "chunk_size": {
            "title": "Chunk Size",
            "type": "integer",
            "nullable": true
          },
          "chunk_overlap": {
            "title": "Chunk Overlap",
            "type": "integer",
            "nullable": true
          },
          "chunk_properties": {
            "$ref": "#/components/schemas/ChunkPropertiesNullable"
          },
          "name": {
            "title": "Name",
            "type": "string",
            "nullable": true
          },
          "parent_id": {
            "title": "Parent Id",
            "type": "integer",
            "nullable": true
          },
          "enable_auto_sync": {
            "title": "Enable Auto Sync",
            "type": "boolean",
            "nullable": true
          },
          "presigned_url": {
            "title": "Presigned Url",
            "type": "string",
            "nullable": true
          },
          "parsed_text_url": {
            "title": "Parsed Text Url",
            "type": "string",
            "nullable": true
          },
          "additional_presigned_urls": {
            "title": "Additional Presigned Urls",
            "type": "object",
            "nullable": true
          },
          "skip_embedding_generation": {
            "title": "Skip Embedding Generation",
            "type": "boolean"
          },
          "source_created_at": {
            "title": "Source Created At",
            "type": "string",
            "format": "date-time",
            "nullable": true
          },
          "generate_sparse_vectors": {
            "title": "Generate Sparse Vectors",
            "type": "boolean",
            "nullable": true
          },
          "created_at": {
            "title": "Created At",
            "type": "string",
            "format": "date-time"
          },
          "updated_at": {
            "title": "Updated At",
            "type": "string",
            "format": "date-time"
          }
        },
        "type": "object",
        "required": [
          "id",
          "source",
          "organization_id",
          "organization_supplied_user_id",
          "organization_user_data_source_id",
          "external_file_id",
          "external_url",
          "sync_status",
          "sync_error_message",
          "last_sync",
          "tags",
          "file_statistics",
          "file_metadata",
          "embedding_properties",
          "chunk_size",
          "chunk_overlap",
          "chunk_properties",
          "name",
          "parent_id",
          "enable_auto_sync",
          "presigned_url",
          "parsed_text_url",
          "additional_presigned_urls",
          "skip_embedding_generation",
          "source_created_at",
          "generate_sparse_vectors",
          "created_at",
          "updated_at"
        ]
      },
      "UserFilesV2": {
        "title": "UserFilesV2",
        "properties": {
          "results": {
            "title": "Results",
            "items": {
              "$ref": "#/components/schemas/UserFile"
            },
            "type": "array"
          },
          "count": {
            "title": "Count",
            "type": "integer"
          }
        },
        "type": "object",
        "required": [
          "results",
          "count"
        ]
      },
      "UserRequestContent": {
        "title": "UserRequestContent",
        "properties": {
          "customer_id": {
            "title": "Customer Id",
            "type": "string"
          }
        },
        "type": "object",
        "required": [
          "customer_id"
        ]
      },
      "UserResponse": {
        "title": "UserResponse",
        "properties": {
          "id": {
            "title": "Id",
            "type": "integer"
          },
          "organization_id": {
            "title": "Organization Id",
            "type": "integer"
          },
          "organization_supplied_user_id": {
            "title": "Organization Supplied User Id",
            "type": "string"
          },
          "created_at": {
            "title": "Created At",
            "type": "string",
            "format": "date-time"
          },
          "updated_at": {
            "title": "Updated At",
            "type": "string",
            "format": "date-time"
          },
          "deleted_at": {
            "title": "Deleted At",
            "type": "string",
            "format": "date-time",
            "nullable": true
          },
          "num_files_synced": {
            "title": "Num Files Synced",
            "type": "integer"
          },
          "num_characters_synced": {
            "title": "Num Characters Synced",
            "type": "integer"
          },
          "num_tokens_synced": {
            "title": "Num Tokens Synced",
            "type": "integer"
          },
          "unique_file_tags": {
            "title": "Unique File Tags",
            "items": {
              "type": "object"
            },
            "type": "array"
          },
          "enabled_features": {
            "title": "Enabled Features",
            "type": "object",
            "nullable": true
          }
        },
        "type": "object",
        "required": [
          "id",
          "organization_id",
          "organization_supplied_user_id",
          "created_at",
          "updated_at",
          "deleted_at",
          "num_files_synced",
          "num_characters_synced",
          "num_tokens_synced",
          "unique_file_tags",
          "enabled_features"
        ]
      },
      "ValidationError": {
        "title": "ValidationError",
        "properties": {
          "loc": {
            "title": "Location",
            "items": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ]
            },
            "type": "array"
          },
          "msg": {
            "title": "Message",
            "type": "string"
          },
          "type": {
            "title": "Error Type",
            "type": "string"
          }
        },
        "type": "object",
        "required": [
          "loc",
          "msg",
          "type"
        ]
      },
      "Webhook": {
        "title": "Webhook",
        "properties": {
          "id": {
            "title": "Id",
            "type": "integer"
          },
          "organization_id": {
            "title": "Organization Id",
            "type": "integer"
          },
          "url": {
            "title": "Url",
            "type": "string"
          },
          "signing_key": {
            "title": "Signing Key",
            "type": "string"
          },
          "created_at": {
            "title": "Created At",
            "type": "string",
            "format": "date-time"
          },
          "updated_at": {
            "title": "Updated At",
            "type": "string",
            "format": "date-time"
          }
        },
        "type": "object",
        "required": [
          "id",
          "organization_id",
          "url",
          "signing_key",
          "created_at",
          "updated_at"
        ]
      },
      "WebhookFilters": {
        "title": "WebhookFilters",
        "properties": {
          "ids": {
            "title": "Ids",
            "default": [
            ],
            "items": {
              "type": "integer"
            },
            "type": "array",
            "nullable": true
          }
        },
        "type": "object"
      },
      "WebhookNoKey": {
        "title": "WebhookNoKey",
        "properties": {
          "id": {
            "title": "Id",
            "type": "integer"
          },
          "organization_id": {
            "title": "Organization Id",
            "type": "integer"
          },
          "url": {
            "title": "Url",
            "type": "string"
          },
          "created_at": {
            "title": "Created At",
            "type": "string",
            "format": "date-time"
          },
          "updated_at": {
            "title": "Updated At",
            "type": "string",
            "format": "date-time"
          }
        },
        "type": "object",
        "required": [
          "id",
          "organization_id",
          "url",
          "created_at",
          "updated_at"
        ]
      },
      "WebhookOrderByColumns": {
        "title": "WebhookOrderByColumns",
        "type": "string",
        "enum": [
          "created_at",
          "updated_at"
        ]
      },
      "WebhookQueryInput": {
        "title": "WebhookQueryInput",
        "properties": {
          "pagination": {
            "$ref": "#/components/schemas/Pagination"
          },
          "order_by": {
            "$ref": "#/components/schemas/WebhookOrderByColumns"
          },
          "order_dir": {
            "$ref": "#/components/schemas/OrderDir"
          },
          "filters": {
            "$ref": "#/components/schemas/WebhookFilters"
          }
        },
        "type": "object",
        "x-konfig-properties": {
          "pagination": {
            "default": {
              "limit": 10,
              "offset": 0
            }
          },
          "order_by": {
            "default": "updated_at"
          },
          "order_dir": {
            "default": "asc"
          },
          "filters": {
            "default": {
              "ids": [
              ]
            }
          }
        }
      },
      "WebhookQueryResponse": {
        "title": "WebhookQueryResponse",
        "properties": {
          "results": {
            "title": "Results",
            "items": {
              "$ref": "#/components/schemas/WebhookNoKey"
            },
            "type": "array"
          },
          "count": {
            "title": "Count",
            "type": "integer"
          }
        },
        "type": "object",
        "required": [
          "results",
          "count"
        ]
      },
      "WebscrapeRequest": {
        "title": "WebscrapeRequest",
        "properties": {
          "tags": {
            "title": "Tags",
            "default": {
            },
            "additionalProperties": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "integer"
                },
                {
                  "type": "boolean"
                },
                {
                  "items": {
                    "type": "string"
                  },
                  "type": "array"
                },
                {
                  "items": {
                    "type": "integer"
                  },
                  "type": "array"
                },
                {
                  "items": {
                    "type": "boolean"
                  },
                  "type": "array"
                }
              ]
            },
            "type": "object",
            "nullable": true
          },
          "url": {
            "title": "Url",
            "type": "string"
          },
          "recursion_depth": {
            "title": "Recursion Depth",
            "default": 3,
            "type": "integer",
            "nullable": true
          },
          "max_pages_to_scrape": {
            "title": "Max Pages To Scrape",
            "default": 100,
            "type": "integer",
            "nullable": true
          },
          "chunk_size": {
            "title": "Chunk Size",
            "default": 1500,
            "type": "integer",
            "nullable": true
          },
          "chunk_overlap": {
            "title": "Chunk Overlap",
            "default": 20,
            "type": "integer",
            "nullable": true
          },
          "skip_embedding_generation": {
            "title": "Skip Embedding Generation",
            "default": false,
            "type": "boolean",
            "nullable": true
          },
          "enable_auto_sync": {
            "title": "Enable Auto Sync",
            "default": false,
            "type": "boolean",
            "nullable": true
          },
          "generate_sparse_vectors": {
            "title": "Generate Sparse Vectors",
            "default": false,
            "type": "boolean",
            "nullable": true
          },
          "prepend_filename_to_chunks": {
            "title": "Prepend Filename To Chunks",
            "default": false,
            "type": "boolean",
            "nullable": true
          },
          "html_tags_to_skip": {
            "title": "Html Tags To Skip",
            "default": [
            ],
            "items": {
              "type": "string"
            },
            "type": "array",
            "nullable": true
          },
          "css_classes_to_skip": {
            "title": "Css Classes To Skip",
            "default": [
            ],
            "items": {
              "type": "string"
            },
            "type": "array",
            "nullable": true
          },
          "css_selectors_to_skip": {
            "title": "Css Selectors To Skip",
            "default": [
            ],
            "items": {
              "type": "string"
            },
            "type": "array",
            "nullable": true
          },
          "embedding_model": {
            "$ref": "#/components/schemas/EmbeddingGenerators"
          }
        },
        "type": "object",
        "required": [
          "url"
        ],
        "x-konfig-properties": {
          "embedding_model": {
            "default": "OPENAI"
          }
        }
      },
      "WhiteLabelingResponse": {
        "title": "WhiteLabelingResponse",
        "properties": {
          "remove_branding": {
            "title": "Remove Branding",
            "type": "boolean"
          },
          "integrations": {
            "title": "Integrations",
            "type": "object"
          }
        },
        "type": "object",
        "required": [
          "remove_branding",
          "integrations"
        ]
      },
      "YoutubeTranscriptResponse": {
        "title": "YoutubeTranscriptResponse",
        "properties": {
          "status": {
            "title": "Status",
            "type": "string"
          },
          "error": {
            "title": "Error",
            "type": "string",
            "nullable": true
          },
          "data": {
            "title": "Data",
            "type": "string",
            "nullable": true
          },
          "raw_transcript": {
            "title": "Raw Transcript",
            "items": {
              "additionalProperties": {
                "anyOf": [
                  {
                    "type": "string"
                  },
                  {
                    "type": "number"
                  }
                ]
              },
              "type": "object"
            },
            "type": "array",
            "nullable": true
          }
        },
        "type": "object",
        "required": [
          "status",
          "error",
          "data",
          "raw_transcript"
        ]
      },
      "DataSourceTypeNullable": {
        "title": "DataSourceType",
        "type": "string",
        "enum": [
          "GOOGLE_DRIVE",
          "NOTION",
          "NOTION_DATABASE",
          "INTERCOM",
          "DROPBOX",
          "ONEDRIVE",
          "SHAREPOINT",
          "CONFLUENCE",
          "BOX",
          "ZENDESK",
          "ZOTERO",
          "S3",
          "GMAIL",
          "OUTLOOK",
          "TEXT",
          "CSV",
          "TSV",
          "PDF",
          "DOCX",
          "PPTX",
          "XLSX",
          "MD",
          "RTF",
          "JSON",
          "RAW_TEXT",
          "WEB_SCRAPE",
          "RSS_FEED",
          "FRESHDESK",
          "GITBOOK",
          "JPG",
          "PNG",
          "MP3",
          "MP4",
          "MP2",
          "AAC",
          "WAV",
          "FLAC",
          "PCM",
          "M4A",
          "OGG",
          "OPUS",
          "WEBM"
        ],
        "nullable": true
      },
      "EmbeddingGeneratorsNullable": {
        "title": "EmbeddingGenerators",
        "type": "string",
        "enum": [
          "OPENAI",
          "AZURE_OPENAI",
          "COHERE_MULTILINGUAL_V3",
          "VERTEX_MULTIMODAL",
          "OPENAI_ADA_LARGE_256",
          "OPENAI_ADA_LARGE_1024",
          "OPENAI_ADA_LARGE_3072",
          "OPENAI_ADA_SMALL_512",
          "OPENAI_ADA_SMALL_1536"
        ],
        "default": "OPENAI",
        "nullable": true
      },
      "FileFormatsNullable": {
        "title": "FileFormats",
        "type": "string",
        "enum": [
          "TXT",
          "CSV",
          "TSV",
          "PDF",
          "DOCX",
          "PPTX",
          "XLSX",
          "MD",
          "RTF",
          "JSON",
          "NOTION",
          "GOOGLE_DRIVE",
          "GOOGLE_DOCS",
          "GOOGLE_SHEETS",
          "GOOGLE_SLIDES",
          "INTERCOM",
          "DROPBOX",
          "ONEDRIVE",
          "SHAREPOINT",
          "CONFLUENCE",
          "RSS_FEED",
          "GMAIL",
          "OUTLOOK",
          "BOX",
          "ZENDESK",
          "FRESHDESK",
          "WEB_SCRAPE",
          "GITBOOK",
          "JPG",
          "JPG",
          "PNG",
          "MP3",
          "MP4",
          "MP2",
          "AAC",
          "WAV",
          "FLAC",
          "PCM",
          "M4A",
          "OGG",
          "OPUS",
          "WEBM"
        ],
        "nullable": true
      },
      "HybridSearchTuningParamsNullable": {
        "title": "HybridSearchTuningParams",
        "description": "Hybrid search tuning parameters. See the endpoint description for more details.",
        "properties": {
          "weight_a": {
            "title": "Weight A",
            "type": "number"
          },
          "weight_b": {
            "title": "Weight B",
            "type": "number"
          }
        },
        "type": "object",
        "required": [
          "weight_a",
          "weight_b"
        ],
        "nullable": true,
        "example": {
          "weight_a": 0.5,
          "weight_b": 0.5
        },
        "x-examples": [
          {
            "weight_a": 0.5,
            "weight_b": 0.5
          },
          {
            "weight_a": 0.3,
            "weight_b": 0.7
          }
        ]
      },
      "FileContentTypesNullable": {
        "title": "FileContentTypes",
        "description": "Used to filter the kind of files (e.g. `TEXT` or `IMAGE`) over which to perform the search. Also\n        plays a role in determining what embedding model is used to embed the query. If `IMAGE` is chosen as the media type,\n        then the embedding model used will be an embedding model that is not text-only, *regardless* of what value is passed\n        for `embedding_model`.",
        "type": "string",
        "enum": [
          "TEXT",
          "IMAGE"
        ],
        "default": "TEXT",
        "nullable": true
      },
      "FileStatisticsNullable": {
        "title": "FileStatistics",
        "properties": {
          "file_format": {
            "$ref": "#/components/schemas/FileFormatsNullable"
          },
          "file_size": {
            "title": "File Size",
            "type": "integer",
            "nullable": true
          },
          "num_characters": {
            "title": "Num Characters",
            "type": "integer",
            "nullable": true
          },
          "num_tokens": {
            "title": "Num Tokens",
            "type": "integer",
            "nullable": true
          },
          "num_embeddings": {
            "title": "Num Embeddings",
            "type": "integer",
            "nullable": true
          }
        },
        "type": "object",
        "required": [
          "file_format",
          "file_size",
          "num_characters",
          "num_tokens",
          "num_embeddings"
        ],
        "nullable": true
      },
      "ChunkPropertiesNullable": {
        "title": "ChunkProperties",
        "properties": {
          "set_page_as_boundary": {
            "title": "Set Page As Boundary",
            "type": "boolean",
            "default": false
          },
          "prepend_filename_to_chunks": {
            "title": "Prepend Filename To Chunks",
            "type": "boolean",
            "default": false
          },
          "max_items_per_chunk": {
            "title": "Max Items Per Chunk",
            "type": "integer",
            "nullable": true
          }
        },
        "type": "object",
        "required": [
          "set_page_as_boundary",
          "prepend_filename_to_chunks",
          "max_items_per_chunk"
        ],
        "nullable": true
      },
      "UtilitiesScrapeWebRequest": {
        "title": "Scraping Requests",
        "type": "array",
        "items": {
          "$ref": "#/components/schemas/WebscrapeRequest"
        }
      },
      "IntegrationsGetOauthUrlResponse": {
        "type": "object",
        "properties": {
        },
        "example": {
        }
      },
      "IntegrationsListFoldersResponse": {
        "type": "object",
        "properties": {
        },
        "example": {
        }
      },
      "IntegrationsListLabelsResponse": {
        "type": "object",
        "properties": {
        },
        "example": {
        }
      },
      "IntegrationsListGitbookSpacesResponse": {
        "type": "object",
        "properties": {
        },
        "example": {
        }
      },
      "IntegrationsSyncGitbookResponse": {
        "type": "object",
        "properties": {
        },
        "example": {
        }
      },
      "FilesQueryUserFilesDeprecatedResponse": {
        "title": "Response User Files User Files Post",
        "type": "array",
        "items": {
          "$ref": "#/components/schemas/UserFile"
        }
      },
      "UtilitiesScrapeWebResponse": {
        "type": "object",
        "properties": {
        },
        "example": {
        }
      },
      "UtilitiesProcessSitemapResponse": {
        "type": "object",
        "properties": {
        },
        "example": {
        }
      },
      "UtilitiesScrapeSitemapResponse": {
        "type": "object",
        "properties": {
        },
        "example": {
        }
      },
      "HealthCheckResponse": {
        "type": "object",
        "properties": {
        },
        "example": {
        }
      }
    },
    "securitySchemes": {
      "apiKey": {
        "type": "apiKey",
        "name": "authorization",
        "in": "header",
        "x-konfig-prefix": "Bearer "
      },
      "accessToken": {
        "type": "apiKey",
        "name": "authorization",
        "in": "header",
        "x-konfig-prefix": "Token "
      },
      "customerId": {
        "type": "apiKey",
        "name": "customer-id",
        "in": "header"
      }
    }
  }
}