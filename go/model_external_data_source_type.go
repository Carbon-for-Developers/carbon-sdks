/*
Carbon

Connect external data to LLMs, no matter the source.

API version: 1.0.0
*/

// Code generated by Konfig (https://konfigthis.com); DO NOT EDIT.

package carbon

import (
	"encoding/json"
	"fmt"
)

// ExternalDataSourceType the model 'ExternalDataSourceType'
type ExternalDataSourceType string

// List of ExternalDataSourceType
const (
	EXTERNALDATASOURCETYPE_BOX ExternalDataSourceType = "BOX"
	EXTERNALDATASOURCETYPE_CONFLUENCE ExternalDataSourceType = "CONFLUENCE"
	EXTERNALDATASOURCETYPE_DROPBOX ExternalDataSourceType = "DROPBOX"
	EXTERNALDATASOURCETYPE_GMAIL ExternalDataSourceType = "GMAIL"
	EXTERNALDATASOURCETYPE_GOOGLE_DRIVE ExternalDataSourceType = "GOOGLE_DRIVE"
	EXTERNALDATASOURCETYPE_GOOGLE_CLOUD_STORAGE ExternalDataSourceType = "GOOGLE_CLOUD_STORAGE"
	EXTERNALDATASOURCETYPE_INTERCOM ExternalDataSourceType = "INTERCOM"
	EXTERNALDATASOURCETYPE_NOTION ExternalDataSourceType = "NOTION"
	EXTERNALDATASOURCETYPE_ONEDRIVE ExternalDataSourceType = "ONEDRIVE"
	EXTERNALDATASOURCETYPE_OUTLOOK ExternalDataSourceType = "OUTLOOK"
	EXTERNALDATASOURCETYPE_SALESFORCE ExternalDataSourceType = "SALESFORCE"
	EXTERNALDATASOURCETYPE_SHAREPOINT ExternalDataSourceType = "SHAREPOINT"
	EXTERNALDATASOURCETYPE_SLACK ExternalDataSourceType = "SLACK"
	EXTERNALDATASOURCETYPE_ZENDESK ExternalDataSourceType = "ZENDESK"
	EXTERNALDATASOURCETYPE_ZOTERO ExternalDataSourceType = "ZOTERO"
)

// All allowed values of ExternalDataSourceType enum
var AllowedExternalDataSourceTypeEnumValues = []ExternalDataSourceType{
	"BOX",
	"CONFLUENCE",
	"DROPBOX",
	"GMAIL",
	"GOOGLE_DRIVE",
	"GOOGLE_CLOUD_STORAGE",
	"INTERCOM",
	"NOTION",
	"ONEDRIVE",
	"OUTLOOK",
	"SALESFORCE",
	"SHAREPOINT",
	"SLACK",
	"ZENDESK",
	"ZOTERO",
}

func (v *ExternalDataSourceType) UnmarshalJSON(src []byte) error {
	var value string
	err := json.Unmarshal(src, &value)
	if err != nil {
		return err
	}
	enumTypeValue := ExternalDataSourceType(value)
	for _, existing := range AllowedExternalDataSourceTypeEnumValues {
		if existing == enumTypeValue {
			*v = enumTypeValue
			return nil
		}
	}

	return fmt.Errorf("%+v is not a valid ExternalDataSourceType", value)
}

// NewExternalDataSourceTypeFromValue returns a pointer to a valid ExternalDataSourceType
// for the value passed as argument, or an error if the value passed is not allowed by the enum
func NewExternalDataSourceTypeFromValue(v string) (*ExternalDataSourceType, error) {
	ev := ExternalDataSourceType(v)
	if ev.IsValid() {
		return &ev, nil
	} else {
		return nil, fmt.Errorf("invalid value '%v' for ExternalDataSourceType: valid values are %v", v, AllowedExternalDataSourceTypeEnumValues)
	}
}

// IsValid return true if the value is valid for the enum, false otherwise
func (v ExternalDataSourceType) IsValid() bool {
	for _, existing := range AllowedExternalDataSourceTypeEnumValues {
		if existing == v {
			return true
		}
	}
	return false
}

// Ptr returns reference to ExternalDataSourceType value
func (v ExternalDataSourceType) Ptr() *ExternalDataSourceType {
	return &v
}

type NullableExternalDataSourceType struct {
	value *ExternalDataSourceType
	isSet bool
}

func (v NullableExternalDataSourceType) Get() *ExternalDataSourceType {
	return v.value
}

func (v *NullableExternalDataSourceType) Set(val *ExternalDataSourceType) {
	v.value = val
	v.isSet = true
}

func (v NullableExternalDataSourceType) IsSet() bool {
	return v.isSet
}

func (v *NullableExternalDataSourceType) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableExternalDataSourceType(val *ExternalDataSourceType) *NullableExternalDataSourceType {
	return &NullableExternalDataSourceType{value: val, isSet: true}
}

func (v NullableExternalDataSourceType) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableExternalDataSourceType) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}

