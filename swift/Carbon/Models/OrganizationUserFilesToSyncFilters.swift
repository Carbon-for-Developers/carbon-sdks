//
// OrganizationUserFilesToSyncFilters.swift
//
// Generated by Konfig
// https://konfigthis.com
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

public struct OrganizationUserFilesToSyncFilters: Codable, JSONEncodable, Hashable {

    @available(*, deprecated, message: "This property is deprecated.")
    public var tags: [String: Tags1]?
    public var source: SourceProperty?
    /** The name of the file. The query will return files with names that contain this string. */
    public var name: String?
    /**          Tags to filter by. Supports logical AND and OR operations. Input should be like below:         {             \"OR\": [                 {                 \"key\": \"subject\",                 \"value\": \"holy-bible\",                 \"negate\": false                 },                 {                     \"key\": \"person-of-interest\",                     \"value\": \"jesus christ\",                     \"negate\": false                 },                 {                     \"key\": \"genre\",                     \"value\": \"fiction\",                     \"negate\": true                 }                 {                     \"AND\": [                         {                             \"key\": \"subject\",                             \"value\": \"tao-te-ching\",                             \"negate\": true                         },                         {                             \"key\": \"author\",                             \"value\": \"lao-tzu\",                             \"negate\": false                         }                     ]                 }             ]         }         For a single filter, the filter block can be placed within either an \"AND\" or \"OR\" block.          */
    public var tagsV2: AnyCodable?
    /** The IDs of the files. The query will return files with these IDs. */
    public var ids: [Int]?
    /** The external file IDs of the files. The query will return files with these external file IDs. */
    public var externalFileIds: [String]?
    /** The sync statuses of the files. The query will return files with these sync statuses. */
    public var syncStatuses: [ExternalFileSyncStatuses]?
    @available(*, deprecated, message: "This property is deprecated.")
    public var parentFileIds: [Int]?
    /** The organization user data source IDs of the files. The query will return files with these organization user data source IDs. */
    public var organizationUserDataSourceId: [Int]?
    /** The embedding generators of the files. The query will return files with these embedding generators. */
    public var embeddingGenerators: [EmbeddingGenerators]?
    /** If true, the query will return only root files. Cannot be true if parent_file_ids or include_all_children is specified. */
    public var rootFilesOnly: Bool?
    /** If true, the query will return all descendents of the specified parent_file_ids. */
    public var includeAllChildren: Bool? = false
    /** If true, the query will return only files that have not been synced yet. */
    public var nonSyncedOnly: Bool? = false
    /** Filter by request ID(s) which were used to sync the files */
    public var requestIds: [String]?

    public init(tags: [String: Tags1]? = nil, source: SourceProperty? = nil, name: String? = nil, tagsV2: AnyCodable? = nil, ids: [Int]? = nil, externalFileIds: [String]? = nil, syncStatuses: [ExternalFileSyncStatuses]? = nil, parentFileIds: [Int]? = nil, organizationUserDataSourceId: [Int]? = nil, embeddingGenerators: [EmbeddingGenerators]? = nil, rootFilesOnly: Bool? = nil, includeAllChildren: Bool? = false, nonSyncedOnly: Bool? = false, requestIds: [String]? = nil) {
        self.tags = tags
        self.source = source
        self.name = name
        self.tagsV2 = tagsV2
        self.ids = ids
        self.externalFileIds = externalFileIds
        self.syncStatuses = syncStatuses
        self.parentFileIds = parentFileIds
        self.organizationUserDataSourceId = organizationUserDataSourceId
        self.embeddingGenerators = embeddingGenerators
        self.rootFilesOnly = rootFilesOnly
        self.includeAllChildren = includeAllChildren
        self.nonSyncedOnly = nonSyncedOnly
        self.requestIds = requestIds
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case tags
        case source
        case name
        case tagsV2 = "tags_v2"
        case ids
        case externalFileIds = "external_file_ids"
        case syncStatuses = "sync_statuses"
        case parentFileIds = "parent_file_ids"
        case organizationUserDataSourceId = "organization_user_data_source_id"
        case embeddingGenerators = "embedding_generators"
        case rootFilesOnly = "root_files_only"
        case includeAllChildren = "include_all_children"
        case nonSyncedOnly = "non_synced_only"
        case requestIds = "request_ids"
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(tags, forKey: .tags)
        try container.encodeIfPresent(source, forKey: .source)
        try container.encodeIfPresent(name, forKey: .name)
        try container.encodeIfPresent(tagsV2, forKey: .tagsV2)
        try container.encodeIfPresent(ids, forKey: .ids)
        try container.encodeIfPresent(externalFileIds, forKey: .externalFileIds)
        try container.encodeIfPresent(syncStatuses, forKey: .syncStatuses)
        try container.encodeIfPresent(parentFileIds, forKey: .parentFileIds)
        try container.encodeIfPresent(organizationUserDataSourceId, forKey: .organizationUserDataSourceId)
        try container.encodeIfPresent(embeddingGenerators, forKey: .embeddingGenerators)
        try container.encodeIfPresent(rootFilesOnly, forKey: .rootFilesOnly)
        try container.encodeIfPresent(includeAllChildren, forKey: .includeAllChildren)
        try container.encodeIfPresent(nonSyncedOnly, forKey: .nonSyncedOnly)
        try container.encodeIfPresent(requestIds, forKey: .requestIds)
    }
}

