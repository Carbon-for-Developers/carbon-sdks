//
// FilesAPI.swift
//
// Generated by Konfig
// https://konfigthis.com
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

open class FilesAPI {

    let client: CarbonClient

    public init(client: CarbonClient) {
        self.client = client
    }

    /**
     Create File Tags
     
     - parameter organizationUserFileTagCreate: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @discardableResult
    open class func createUserFileTagsSync(organizationUserFileTagCreate: OrganizationUserFileTagCreate, apiResponseQueue: DispatchQueue = CarbonAPI.apiResponseQueue, completion: @escaping ((_ data: UserFile?, _ error: Error?) -> Void)) -> RequestTask {
        return createUserFileTagsWithRequestBuilder(organizationUserFileTagCreate: organizationUserFileTagCreate).execute(apiResponseQueue) { result in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Create File Tags
     
     - parameter organizationUserFileTagCreate: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    private class func createUserFileTagsAsyncMappedParams(organizationUserFileTagCreate: OrganizationUserFileTagCreate) async throws -> UserFile {
        return try await withCheckedThrowingContinuation { continuation in
            createUserFileTagsWithRequestBuilder(organizationUserFileTagCreate: organizationUserFileTagCreate).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }

    /**
     Create File Tags
     
     - parameter organizationUserFileTagCreate: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    open class func createUserFileTags(
        tags: [String: Tags1],
        organizationUserFileId: Int
    ) async throws -> UserFile {
        let organizationUserFileTagCreate = OrganizationUserFileTagCreate(
            tags: tags,
            organizationUserFileId: organizationUserFileId
        )
        return try await withCheckedThrowingContinuation { continuation in
            createUserFileTagsWithRequestBuilder(organizationUserFileTagCreate: organizationUserFileTagCreate).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    /**
     Create File Tags
     
     - parameter organizationUserFileTagCreate: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    open func createUserFileTags(
        tags: [String: Tags1],
        organizationUserFileId: Int
    ) async throws -> UserFile {
        let organizationUserFileTagCreate = OrganizationUserFileTagCreate(
            tags: tags,
            organizationUserFileId: organizationUserFileId
        )
        return try await withCheckedThrowingContinuation { continuation in
            createUserFileTagsWithRequestBuilder(organizationUserFileTagCreate: organizationUserFileTagCreate).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }



    /**
     Create File Tags
     - POST /create_user_file_tags
     - A tag is a key-value pair that can be added to a file. This pair can then be used for searches (e.g. embedding searches) in order to narrow down the scope of the search. A file can have any number of tags. The following are reserved keys that cannot be used: - db_embedding_id - organization_id - user_id - organization_user_file_id  Carbon currently supports two data types for tag values - `string` and `list<string>`. Keys can only be `string`. If values other than `string` and `list<string>` are used, they're automatically converted to strings (e.g. 4 will become \"4\").
     - API Key:
       - type: apiKey authorization 
       - name: accessToken
     - API Key:
       - type: apiKey authorization 
       - name: apiKey
     - API Key:
       - type: apiKey customer-id 
       - name: customerId
     - parameter organizationUserFileTagCreate: (body)  
     - returns: RequestBuilder<UserFile> 
     */
    open class func createUserFileTagsWithRequestBuilder(
            organizationUserFileTagCreate: OrganizationUserFileTagCreate
    ) -> RequestBuilder<UserFile> {
        let basePath = CarbonAPI.basePath;
        let localVariablePath = "/create_user_file_tags"
        let localVariableURLString = basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: organizationUserFileTagCreate)

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        var localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        do {
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: CarbonAPI.accessToken, prefix: "Token ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: CarbonAPI.apiKey, prefix: "Bearer ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "customer-id", value: CarbonAPI.customerId, prefix: nil)
            let localVariableRequestBuilder: RequestBuilder<UserFile>.Type = CarbonAPI.requestBuilderFactory.getBuilder()
            let URLString = localVariableUrlComponents?.string ?? localVariableURLString
            return localVariableRequestBuilder.init(method: "POST", URLString: URLString, parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
        } catch {
            print("Error: \(error)")
        }
        fatalError("Error: Unable to send request to POST /create_user_file_tags")
    }

    /**
     Create File Tags
     - POST /create_user_file_tags
     - A tag is a key-value pair that can be added to a file. This pair can then be used for searches (e.g. embedding searches) in order to narrow down the scope of the search. A file can have any number of tags. The following are reserved keys that cannot be used: - db_embedding_id - organization_id - user_id - organization_user_file_id  Carbon currently supports two data types for tag values - `string` and `list<string>`. Keys can only be `string`. If values other than `string` and `list<string>` are used, they're automatically converted to strings (e.g. 4 will become \"4\").
     - API Key:
       - type: apiKey authorization 
       - name: accessToken
     - API Key:
       - type: apiKey authorization 
       - name: apiKey
     - API Key:
       - type: apiKey customer-id 
       - name: customerId
     - parameter organizationUserFileTagCreate: (body)  
     - returns: RequestBuilder<UserFile> 
     */
    open func createUserFileTagsWithRequestBuilder(
            organizationUserFileTagCreate: OrganizationUserFileTagCreate
    ) -> RequestBuilder<UserFile> {
        let basePath = self.client.basePath;
        let localVariablePath = "/create_user_file_tags"
        let localVariableURLString = basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: organizationUserFileTagCreate)

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        var localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        do {
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: self.client.accessToken, prefix: "Token ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: self.client.apiKey, prefix: "Bearer ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "customer-id", value: self.client.customerId, prefix: nil)
            let localVariableRequestBuilder: RequestBuilder<UserFile>.Type = CarbonAPI.requestBuilderFactory.getBuilder()
            let URLString = localVariableUrlComponents?.string ?? localVariableURLString
            return localVariableRequestBuilder.init(method: "POST", URLString: URLString, parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
        } catch {
            print("Error: \(error)")
        }
        fatalError("Error: Unable to send request to POST /create_user_file_tags")
    }


    /**
     Delete File Endpoint
     
     - parameter fileId: (path)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(*, deprecated, message: "This operation is deprecated.")
    @discardableResult
    open class func deleteSync(fileId: Int, apiResponseQueue: DispatchQueue = CarbonAPI.apiResponseQueue, completion: @escaping ((_ data: GenericSuccessResponse?, _ error: Error?) -> Void)) -> RequestTask {
        return deleteWithRequestBuilder(fileId: fileId).execute(apiResponseQueue) { result in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Delete File Endpoint
     
     - parameter fileId: (path)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(*, deprecated, message: "This operation is deprecated.")
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    private class func deleteAsyncMappedParams(fileId: Int) async throws -> GenericSuccessResponse {
        return try await withCheckedThrowingContinuation { continuation in
            deleteWithRequestBuilder(fileId: fileId).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }

    /**
     Delete File Endpoint
     
     - parameter fileId: (path)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(*, deprecated, message: "This operation is deprecated.")
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    open class func delete(
        fileId: Int
    ) async throws -> GenericSuccessResponse {
        return try await withCheckedThrowingContinuation { continuation in
            deleteWithRequestBuilder(fileId: fileId).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    /**
     Delete File Endpoint
     
     - parameter fileId: (path)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(*, deprecated, message: "This operation is deprecated.")
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    open func delete(
        fileId: Int
    ) async throws -> GenericSuccessResponse {
        return try await withCheckedThrowingContinuation { continuation in
            deleteWithRequestBuilder(fileId: fileId).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }



    /**
     Delete File Endpoint
     - DELETE /deletefile/{file_id}
     - API Key:
       - type: apiKey authorization 
       - name: accessToken
     - API Key:
       - type: apiKey authorization 
       - name: apiKey
     - API Key:
       - type: apiKey customer-id 
       - name: customerId
     - parameter fileId: (path)  
     - returns: RequestBuilder<GenericSuccessResponse> 
     */
    @available(*, deprecated, message: "This operation is deprecated.")
    open class func deleteWithRequestBuilder(
            fileId: Int
    ) -> RequestBuilder<GenericSuccessResponse> {
        let basePath = CarbonAPI.basePath;
        var localVariablePath = "/deletefile/{file_id}"
        let fileIdPreEscape = "\(APIHelper.mapValueToPathItem(fileId))"
        let fileIdPostEscape = fileIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{file_id}", with: fileIdPostEscape, options: .literal, range: nil)
        let localVariableURLString = basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        var localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        do {
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: CarbonAPI.accessToken, prefix: "Token ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: CarbonAPI.apiKey, prefix: "Bearer ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "customer-id", value: CarbonAPI.customerId, prefix: nil)
            let localVariableRequestBuilder: RequestBuilder<GenericSuccessResponse>.Type = CarbonAPI.requestBuilderFactory.getBuilder()
            let URLString = localVariableUrlComponents?.string ?? localVariableURLString
            return localVariableRequestBuilder.init(method: "DELETE", URLString: URLString, parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
        } catch {
            print("Error: \(error)")
        }
        fatalError("Error: Unable to send request to DELETE /deletefile/{file_id}")
    }

    /**
     Delete File Endpoint
     - DELETE /deletefile/{file_id}
     - API Key:
       - type: apiKey authorization 
       - name: accessToken
     - API Key:
       - type: apiKey authorization 
       - name: apiKey
     - API Key:
       - type: apiKey customer-id 
       - name: customerId
     - parameter fileId: (path)  
     - returns: RequestBuilder<GenericSuccessResponse> 
     */
    @available(*, deprecated, message: "This operation is deprecated.")
    open func deleteWithRequestBuilder(
            fileId: Int
    ) -> RequestBuilder<GenericSuccessResponse> {
        let basePath = self.client.basePath;
        var localVariablePath = "/deletefile/{file_id}"
        let fileIdPreEscape = "\(APIHelper.mapValueToPathItem(fileId))"
        let fileIdPostEscape = fileIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{file_id}", with: fileIdPostEscape, options: .literal, range: nil)
        let localVariableURLString = basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        var localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        do {
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: self.client.accessToken, prefix: "Token ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: self.client.apiKey, prefix: "Bearer ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "customer-id", value: self.client.customerId, prefix: nil)
            let localVariableRequestBuilder: RequestBuilder<GenericSuccessResponse>.Type = CarbonAPI.requestBuilderFactory.getBuilder()
            let URLString = localVariableUrlComponents?.string ?? localVariableURLString
            return localVariableRequestBuilder.init(method: "DELETE", URLString: URLString, parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
        } catch {
            print("Error: \(error)")
        }
        fatalError("Error: Unable to send request to DELETE /deletefile/{file_id}")
    }


    /**
     Delete File Tags
     
     - parameter organizationUserFileTagsRemove: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @discardableResult
    open class func deleteFileTagsSync(organizationUserFileTagsRemove: OrganizationUserFileTagsRemove, apiResponseQueue: DispatchQueue = CarbonAPI.apiResponseQueue, completion: @escaping ((_ data: UserFile?, _ error: Error?) -> Void)) -> RequestTask {
        return deleteFileTagsWithRequestBuilder(organizationUserFileTagsRemove: organizationUserFileTagsRemove).execute(apiResponseQueue) { result in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Delete File Tags
     
     - parameter organizationUserFileTagsRemove: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    private class func deleteFileTagsAsyncMappedParams(organizationUserFileTagsRemove: OrganizationUserFileTagsRemove) async throws -> UserFile {
        return try await withCheckedThrowingContinuation { continuation in
            deleteFileTagsWithRequestBuilder(organizationUserFileTagsRemove: organizationUserFileTagsRemove).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }

    /**
     Delete File Tags
     
     - parameter organizationUserFileTagsRemove: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    open class func deleteFileTags(
        tags: [String],
        organizationUserFileId: Int
    ) async throws -> UserFile {
        let organizationUserFileTagsRemove = OrganizationUserFileTagsRemove(
            tags: tags,
            organizationUserFileId: organizationUserFileId
        )
        return try await withCheckedThrowingContinuation { continuation in
            deleteFileTagsWithRequestBuilder(organizationUserFileTagsRemove: organizationUserFileTagsRemove).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    /**
     Delete File Tags
     
     - parameter organizationUserFileTagsRemove: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    open func deleteFileTags(
        tags: [String],
        organizationUserFileId: Int
    ) async throws -> UserFile {
        let organizationUserFileTagsRemove = OrganizationUserFileTagsRemove(
            tags: tags,
            organizationUserFileId: organizationUserFileId
        )
        return try await withCheckedThrowingContinuation { continuation in
            deleteFileTagsWithRequestBuilder(organizationUserFileTagsRemove: organizationUserFileTagsRemove).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }



    /**
     Delete File Tags
     - POST /delete_user_file_tags
     - API Key:
       - type: apiKey authorization 
       - name: accessToken
     - API Key:
       - type: apiKey authorization 
       - name: apiKey
     - API Key:
       - type: apiKey customer-id 
       - name: customerId
     - parameter organizationUserFileTagsRemove: (body)  
     - returns: RequestBuilder<UserFile> 
     */
    open class func deleteFileTagsWithRequestBuilder(
            organizationUserFileTagsRemove: OrganizationUserFileTagsRemove
    ) -> RequestBuilder<UserFile> {
        let basePath = CarbonAPI.basePath;
        let localVariablePath = "/delete_user_file_tags"
        let localVariableURLString = basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: organizationUserFileTagsRemove)

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        var localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        do {
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: CarbonAPI.accessToken, prefix: "Token ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: CarbonAPI.apiKey, prefix: "Bearer ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "customer-id", value: CarbonAPI.customerId, prefix: nil)
            let localVariableRequestBuilder: RequestBuilder<UserFile>.Type = CarbonAPI.requestBuilderFactory.getBuilder()
            let URLString = localVariableUrlComponents?.string ?? localVariableURLString
            return localVariableRequestBuilder.init(method: "POST", URLString: URLString, parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
        } catch {
            print("Error: \(error)")
        }
        fatalError("Error: Unable to send request to POST /delete_user_file_tags")
    }

    /**
     Delete File Tags
     - POST /delete_user_file_tags
     - API Key:
       - type: apiKey authorization 
       - name: accessToken
     - API Key:
       - type: apiKey authorization 
       - name: apiKey
     - API Key:
       - type: apiKey customer-id 
       - name: customerId
     - parameter organizationUserFileTagsRemove: (body)  
     - returns: RequestBuilder<UserFile> 
     */
    open func deleteFileTagsWithRequestBuilder(
            organizationUserFileTagsRemove: OrganizationUserFileTagsRemove
    ) -> RequestBuilder<UserFile> {
        let basePath = self.client.basePath;
        let localVariablePath = "/delete_user_file_tags"
        let localVariableURLString = basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: organizationUserFileTagsRemove)

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        var localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        do {
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: self.client.accessToken, prefix: "Token ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: self.client.apiKey, prefix: "Bearer ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "customer-id", value: self.client.customerId, prefix: nil)
            let localVariableRequestBuilder: RequestBuilder<UserFile>.Type = CarbonAPI.requestBuilderFactory.getBuilder()
            let URLString = localVariableUrlComponents?.string ?? localVariableURLString
            return localVariableRequestBuilder.init(method: "POST", URLString: URLString, parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
        } catch {
            print("Error: \(error)")
        }
        fatalError("Error: Unable to send request to POST /delete_user_file_tags")
    }


    /**
     Delete Files Endpoint
     
     - parameter deleteFilesQueryInput: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(*, deprecated, message: "This operation is deprecated.")
    @discardableResult
    open class func deleteManySync(deleteFilesQueryInput: DeleteFilesQueryInput, apiResponseQueue: DispatchQueue = CarbonAPI.apiResponseQueue, completion: @escaping ((_ data: GenericSuccessResponse?, _ error: Error?) -> Void)) -> RequestTask {
        return deleteManyWithRequestBuilder(deleteFilesQueryInput: deleteFilesQueryInput).execute(apiResponseQueue) { result in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Delete Files Endpoint
     
     - parameter deleteFilesQueryInput: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(*, deprecated, message: "This operation is deprecated.")
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    private class func deleteManyAsyncMappedParams(deleteFilesQueryInput: DeleteFilesQueryInput) async throws -> GenericSuccessResponse {
        return try await withCheckedThrowingContinuation { continuation in
            deleteManyWithRequestBuilder(deleteFilesQueryInput: deleteFilesQueryInput).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }

    /**
     Delete Files Endpoint
     
     - parameter deleteFilesQueryInput: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(*, deprecated, message: "This operation is deprecated.")
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    open class func deleteMany(
        fileIds: [Int]? = nil, 
        syncStatuses: [ExternalFileSyncStatuses]? = nil, 
        deleteNonSyncedOnly: Bool? = nil, 
        sendWebhook: Bool? = nil, 
        deleteChildFiles: Bool? = nil
    ) async throws -> GenericSuccessResponse {
        let deleteFilesQueryInput = DeleteFilesQueryInput(
            fileIds: fileIds,
            syncStatuses: syncStatuses,
            deleteNonSyncedOnly: deleteNonSyncedOnly,
            sendWebhook: sendWebhook,
            deleteChildFiles: deleteChildFiles
        )
        return try await withCheckedThrowingContinuation { continuation in
            deleteManyWithRequestBuilder(deleteFilesQueryInput: deleteFilesQueryInput).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    /**
     Delete Files Endpoint
     
     - parameter deleteFilesQueryInput: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(*, deprecated, message: "This operation is deprecated.")
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    open func deleteMany(
        fileIds: [Int]? = nil, 
        syncStatuses: [ExternalFileSyncStatuses]? = nil, 
        deleteNonSyncedOnly: Bool? = nil, 
        sendWebhook: Bool? = nil, 
        deleteChildFiles: Bool? = nil
    ) async throws -> GenericSuccessResponse {
        let deleteFilesQueryInput = DeleteFilesQueryInput(
            fileIds: fileIds,
            syncStatuses: syncStatuses,
            deleteNonSyncedOnly: deleteNonSyncedOnly,
            sendWebhook: sendWebhook,
            deleteChildFiles: deleteChildFiles
        )
        return try await withCheckedThrowingContinuation { continuation in
            deleteManyWithRequestBuilder(deleteFilesQueryInput: deleteFilesQueryInput).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }



    /**
     Delete Files Endpoint
     - POST /delete_files
     - API Key:
       - type: apiKey authorization 
       - name: accessToken
     - API Key:
       - type: apiKey authorization 
       - name: apiKey
     - API Key:
       - type: apiKey customer-id 
       - name: customerId
     - parameter deleteFilesQueryInput: (body)  
     - returns: RequestBuilder<GenericSuccessResponse> 
     */
    @available(*, deprecated, message: "This operation is deprecated.")
    open class func deleteManyWithRequestBuilder(
            deleteFilesQueryInput: DeleteFilesQueryInput
    ) -> RequestBuilder<GenericSuccessResponse> {
        let basePath = CarbonAPI.basePath;
        let localVariablePath = "/delete_files"
        let localVariableURLString = basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: deleteFilesQueryInput)

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        var localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        do {
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: CarbonAPI.accessToken, prefix: "Token ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: CarbonAPI.apiKey, prefix: "Bearer ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "customer-id", value: CarbonAPI.customerId, prefix: nil)
            let localVariableRequestBuilder: RequestBuilder<GenericSuccessResponse>.Type = CarbonAPI.requestBuilderFactory.getBuilder()
            let URLString = localVariableUrlComponents?.string ?? localVariableURLString
            return localVariableRequestBuilder.init(method: "POST", URLString: URLString, parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
        } catch {
            print("Error: \(error)")
        }
        fatalError("Error: Unable to send request to POST /delete_files")
    }

    /**
     Delete Files Endpoint
     - POST /delete_files
     - API Key:
       - type: apiKey authorization 
       - name: accessToken
     - API Key:
       - type: apiKey authorization 
       - name: apiKey
     - API Key:
       - type: apiKey customer-id 
       - name: customerId
     - parameter deleteFilesQueryInput: (body)  
     - returns: RequestBuilder<GenericSuccessResponse> 
     */
    @available(*, deprecated, message: "This operation is deprecated.")
    open func deleteManyWithRequestBuilder(
            deleteFilesQueryInput: DeleteFilesQueryInput
    ) -> RequestBuilder<GenericSuccessResponse> {
        let basePath = self.client.basePath;
        let localVariablePath = "/delete_files"
        let localVariableURLString = basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: deleteFilesQueryInput)

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        var localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        do {
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: self.client.accessToken, prefix: "Token ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: self.client.apiKey, prefix: "Bearer ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "customer-id", value: self.client.customerId, prefix: nil)
            let localVariableRequestBuilder: RequestBuilder<GenericSuccessResponse>.Type = CarbonAPI.requestBuilderFactory.getBuilder()
            let URLString = localVariableUrlComponents?.string ?? localVariableURLString
            return localVariableRequestBuilder.init(method: "POST", URLString: URLString, parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
        } catch {
            print("Error: \(error)")
        }
        fatalError("Error: Unable to send request to POST /delete_files")
    }


    /**
     Delete Files V2 Endpoint
     
     - parameter deleteFilesV2QueryInput: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @discardableResult
    open class func deleteV2Sync(deleteFilesV2QueryInput: DeleteFilesV2QueryInput, apiResponseQueue: DispatchQueue = CarbonAPI.apiResponseQueue, completion: @escaping ((_ data: GenericSuccessResponse?, _ error: Error?) -> Void)) -> RequestTask {
        return deleteV2WithRequestBuilder(deleteFilesV2QueryInput: deleteFilesV2QueryInput).execute(apiResponseQueue) { result in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Delete Files V2 Endpoint
     
     - parameter deleteFilesV2QueryInput: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    private class func deleteV2AsyncMappedParams(deleteFilesV2QueryInput: DeleteFilesV2QueryInput) async throws -> GenericSuccessResponse {
        return try await withCheckedThrowingContinuation { continuation in
            deleteV2WithRequestBuilder(deleteFilesV2QueryInput: deleteFilesV2QueryInput).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }

    /**
     Delete Files V2 Endpoint
     
     - parameter deleteFilesV2QueryInput: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    open class func deleteV2(
        filters: OrganizationUserFilesToSyncFilters? = nil, 
        sendWebhook: Bool? = nil
    ) async throws -> GenericSuccessResponse {
        let deleteFilesV2QueryInput = DeleteFilesV2QueryInput(
            filters: filters,
            sendWebhook: sendWebhook
        )
        return try await withCheckedThrowingContinuation { continuation in
            deleteV2WithRequestBuilder(deleteFilesV2QueryInput: deleteFilesV2QueryInput).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    /**
     Delete Files V2 Endpoint
     
     - parameter deleteFilesV2QueryInput: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    open func deleteV2(
        filters: OrganizationUserFilesToSyncFilters? = nil, 
        sendWebhook: Bool? = nil
    ) async throws -> GenericSuccessResponse {
        let deleteFilesV2QueryInput = DeleteFilesV2QueryInput(
            filters: filters,
            sendWebhook: sendWebhook
        )
        return try await withCheckedThrowingContinuation { continuation in
            deleteV2WithRequestBuilder(deleteFilesV2QueryInput: deleteFilesV2QueryInput).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }



    /**
     Delete Files V2 Endpoint
     - POST /delete_files_v2
     - API Key:
       - type: apiKey authorization 
       - name: accessToken
     - API Key:
       - type: apiKey authorization 
       - name: apiKey
     - API Key:
       - type: apiKey customer-id 
       - name: customerId
     - parameter deleteFilesV2QueryInput: (body)  
     - returns: RequestBuilder<GenericSuccessResponse> 
     */
    open class func deleteV2WithRequestBuilder(
            deleteFilesV2QueryInput: DeleteFilesV2QueryInput
    ) -> RequestBuilder<GenericSuccessResponse> {
        let basePath = CarbonAPI.basePath;
        let localVariablePath = "/delete_files_v2"
        let localVariableURLString = basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: deleteFilesV2QueryInput)

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        var localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        do {
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: CarbonAPI.accessToken, prefix: "Token ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: CarbonAPI.apiKey, prefix: "Bearer ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "customer-id", value: CarbonAPI.customerId, prefix: nil)
            let localVariableRequestBuilder: RequestBuilder<GenericSuccessResponse>.Type = CarbonAPI.requestBuilderFactory.getBuilder()
            let URLString = localVariableUrlComponents?.string ?? localVariableURLString
            return localVariableRequestBuilder.init(method: "POST", URLString: URLString, parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
        } catch {
            print("Error: \(error)")
        }
        fatalError("Error: Unable to send request to POST /delete_files_v2")
    }

    /**
     Delete Files V2 Endpoint
     - POST /delete_files_v2
     - API Key:
       - type: apiKey authorization 
       - name: accessToken
     - API Key:
       - type: apiKey authorization 
       - name: apiKey
     - API Key:
       - type: apiKey customer-id 
       - name: customerId
     - parameter deleteFilesV2QueryInput: (body)  
     - returns: RequestBuilder<GenericSuccessResponse> 
     */
    open func deleteV2WithRequestBuilder(
            deleteFilesV2QueryInput: DeleteFilesV2QueryInput
    ) -> RequestBuilder<GenericSuccessResponse> {
        let basePath = self.client.basePath;
        let localVariablePath = "/delete_files_v2"
        let localVariableURLString = basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: deleteFilesV2QueryInput)

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        var localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        do {
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: self.client.accessToken, prefix: "Token ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: self.client.apiKey, prefix: "Bearer ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "customer-id", value: self.client.customerId, prefix: nil)
            let localVariableRequestBuilder: RequestBuilder<GenericSuccessResponse>.Type = CarbonAPI.requestBuilderFactory.getBuilder()
            let URLString = localVariableUrlComponents?.string ?? localVariableURLString
            return localVariableRequestBuilder.init(method: "POST", URLString: URLString, parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
        } catch {
            print("Error: \(error)")
        }
        fatalError("Error: Unable to send request to POST /delete_files_v2")
    }


    /**
     Parsed File
     
     - parameter fileId: (path)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(*, deprecated, message: "This operation is deprecated.")
    @discardableResult
    open class func getParsedFileSync(fileId: Int, apiResponseQueue: DispatchQueue = CarbonAPI.apiResponseQueue, completion: @escaping ((_ data: PresignedURLResponse?, _ error: Error?) -> Void)) -> RequestTask {
        return getParsedFileWithRequestBuilder(fileId: fileId).execute(apiResponseQueue) { result in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Parsed File
     
     - parameter fileId: (path)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(*, deprecated, message: "This operation is deprecated.")
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    private class func getParsedFileAsyncMappedParams(fileId: Int) async throws -> PresignedURLResponse {
        return try await withCheckedThrowingContinuation { continuation in
            getParsedFileWithRequestBuilder(fileId: fileId).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }

    /**
     Parsed File
     
     - parameter fileId: (path)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(*, deprecated, message: "This operation is deprecated.")
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    open class func getParsedFile(
        fileId: Int
    ) async throws -> PresignedURLResponse {
        return try await withCheckedThrowingContinuation { continuation in
            getParsedFileWithRequestBuilder(fileId: fileId).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    /**
     Parsed File
     
     - parameter fileId: (path)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(*, deprecated, message: "This operation is deprecated.")
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    open func getParsedFile(
        fileId: Int
    ) async throws -> PresignedURLResponse {
        return try await withCheckedThrowingContinuation { continuation in
            getParsedFileWithRequestBuilder(fileId: fileId).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }



    /**
     Parsed File
     - GET /parsed_file/{file_id}
     - This route is deprecated. Use `/user_files_v2` instead.
     - API Key:
       - type: apiKey authorization 
       - name: accessToken
     - API Key:
       - type: apiKey authorization 
       - name: apiKey
     - API Key:
       - type: apiKey customer-id 
       - name: customerId
     - parameter fileId: (path)  
     - returns: RequestBuilder<PresignedURLResponse> 
     */
    @available(*, deprecated, message: "This operation is deprecated.")
    open class func getParsedFileWithRequestBuilder(
            fileId: Int
    ) -> RequestBuilder<PresignedURLResponse> {
        let basePath = CarbonAPI.basePath;
        var localVariablePath = "/parsed_file/{file_id}"
        let fileIdPreEscape = "\(APIHelper.mapValueToPathItem(fileId))"
        let fileIdPostEscape = fileIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{file_id}", with: fileIdPostEscape, options: .literal, range: nil)
        let localVariableURLString = basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        var localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        do {
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: CarbonAPI.accessToken, prefix: "Token ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: CarbonAPI.apiKey, prefix: "Bearer ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "customer-id", value: CarbonAPI.customerId, prefix: nil)
            let localVariableRequestBuilder: RequestBuilder<PresignedURLResponse>.Type = CarbonAPI.requestBuilderFactory.getBuilder()
            let URLString = localVariableUrlComponents?.string ?? localVariableURLString
            return localVariableRequestBuilder.init(method: "GET", URLString: URLString, parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
        } catch {
            print("Error: \(error)")
        }
        fatalError("Error: Unable to send request to GET /parsed_file/{file_id}")
    }

    /**
     Parsed File
     - GET /parsed_file/{file_id}
     - This route is deprecated. Use `/user_files_v2` instead.
     - API Key:
       - type: apiKey authorization 
       - name: accessToken
     - API Key:
       - type: apiKey authorization 
       - name: apiKey
     - API Key:
       - type: apiKey customer-id 
       - name: customerId
     - parameter fileId: (path)  
     - returns: RequestBuilder<PresignedURLResponse> 
     */
    @available(*, deprecated, message: "This operation is deprecated.")
    open func getParsedFileWithRequestBuilder(
            fileId: Int
    ) -> RequestBuilder<PresignedURLResponse> {
        let basePath = self.client.basePath;
        var localVariablePath = "/parsed_file/{file_id}"
        let fileIdPreEscape = "\(APIHelper.mapValueToPathItem(fileId))"
        let fileIdPostEscape = fileIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{file_id}", with: fileIdPostEscape, options: .literal, range: nil)
        let localVariableURLString = basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        var localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        do {
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: self.client.accessToken, prefix: "Token ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: self.client.apiKey, prefix: "Bearer ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "customer-id", value: self.client.customerId, prefix: nil)
            let localVariableRequestBuilder: RequestBuilder<PresignedURLResponse>.Type = CarbonAPI.requestBuilderFactory.getBuilder()
            let URLString = localVariableUrlComponents?.string ?? localVariableURLString
            return localVariableRequestBuilder.init(method: "GET", URLString: URLString, parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
        } catch {
            print("Error: \(error)")
        }
        fatalError("Error: Unable to send request to GET /parsed_file/{file_id}")
    }


    /**
     Raw File
     
     - parameter fileId: (path)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(*, deprecated, message: "This operation is deprecated.")
    @discardableResult
    open class func getRawFileSync(fileId: Int, apiResponseQueue: DispatchQueue = CarbonAPI.apiResponseQueue, completion: @escaping ((_ data: PresignedURLResponse?, _ error: Error?) -> Void)) -> RequestTask {
        return getRawFileWithRequestBuilder(fileId: fileId).execute(apiResponseQueue) { result in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Raw File
     
     - parameter fileId: (path)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(*, deprecated, message: "This operation is deprecated.")
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    private class func getRawFileAsyncMappedParams(fileId: Int) async throws -> PresignedURLResponse {
        return try await withCheckedThrowingContinuation { continuation in
            getRawFileWithRequestBuilder(fileId: fileId).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }

    /**
     Raw File
     
     - parameter fileId: (path)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(*, deprecated, message: "This operation is deprecated.")
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    open class func getRawFile(
        fileId: Int
    ) async throws -> PresignedURLResponse {
        return try await withCheckedThrowingContinuation { continuation in
            getRawFileWithRequestBuilder(fileId: fileId).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    /**
     Raw File
     
     - parameter fileId: (path)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(*, deprecated, message: "This operation is deprecated.")
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    open func getRawFile(
        fileId: Int
    ) async throws -> PresignedURLResponse {
        return try await withCheckedThrowingContinuation { continuation in
            getRawFileWithRequestBuilder(fileId: fileId).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }



    /**
     Raw File
     - GET /raw_file/{file_id}
     - This route is deprecated. Use `/user_files_v2` instead.
     - API Key:
       - type: apiKey authorization 
       - name: accessToken
     - API Key:
       - type: apiKey authorization 
       - name: apiKey
     - API Key:
       - type: apiKey customer-id 
       - name: customerId
     - parameter fileId: (path)  
     - returns: RequestBuilder<PresignedURLResponse> 
     */
    @available(*, deprecated, message: "This operation is deprecated.")
    open class func getRawFileWithRequestBuilder(
            fileId: Int
    ) -> RequestBuilder<PresignedURLResponse> {
        let basePath = CarbonAPI.basePath;
        var localVariablePath = "/raw_file/{file_id}"
        let fileIdPreEscape = "\(APIHelper.mapValueToPathItem(fileId))"
        let fileIdPostEscape = fileIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{file_id}", with: fileIdPostEscape, options: .literal, range: nil)
        let localVariableURLString = basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        var localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        do {
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: CarbonAPI.accessToken, prefix: "Token ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: CarbonAPI.apiKey, prefix: "Bearer ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "customer-id", value: CarbonAPI.customerId, prefix: nil)
            let localVariableRequestBuilder: RequestBuilder<PresignedURLResponse>.Type = CarbonAPI.requestBuilderFactory.getBuilder()
            let URLString = localVariableUrlComponents?.string ?? localVariableURLString
            return localVariableRequestBuilder.init(method: "GET", URLString: URLString, parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
        } catch {
            print("Error: \(error)")
        }
        fatalError("Error: Unable to send request to GET /raw_file/{file_id}")
    }

    /**
     Raw File
     - GET /raw_file/{file_id}
     - This route is deprecated. Use `/user_files_v2` instead.
     - API Key:
       - type: apiKey authorization 
       - name: accessToken
     - API Key:
       - type: apiKey authorization 
       - name: apiKey
     - API Key:
       - type: apiKey customer-id 
       - name: customerId
     - parameter fileId: (path)  
     - returns: RequestBuilder<PresignedURLResponse> 
     */
    @available(*, deprecated, message: "This operation is deprecated.")
    open func getRawFileWithRequestBuilder(
            fileId: Int
    ) -> RequestBuilder<PresignedURLResponse> {
        let basePath = self.client.basePath;
        var localVariablePath = "/raw_file/{file_id}"
        let fileIdPreEscape = "\(APIHelper.mapValueToPathItem(fileId))"
        let fileIdPostEscape = fileIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{file_id}", with: fileIdPostEscape, options: .literal, range: nil)
        let localVariableURLString = basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        var localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        do {
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: self.client.accessToken, prefix: "Token ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: self.client.apiKey, prefix: "Bearer ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "customer-id", value: self.client.customerId, prefix: nil)
            let localVariableRequestBuilder: RequestBuilder<PresignedURLResponse>.Type = CarbonAPI.requestBuilderFactory.getBuilder()
            let URLString = localVariableUrlComponents?.string ?? localVariableURLString
            return localVariableRequestBuilder.init(method: "GET", URLString: URLString, parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
        } catch {
            print("Error: \(error)")
        }
        fatalError("Error: Unable to send request to GET /raw_file/{file_id}")
    }


    /**
     User Files V2
     
     - parameter organizationUserFilesToSyncQueryInput: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @discardableResult
    open class func queryUserFilesSync(organizationUserFilesToSyncQueryInput: OrganizationUserFilesToSyncQueryInput, apiResponseQueue: DispatchQueue = CarbonAPI.apiResponseQueue, completion: @escaping ((_ data: UserFilesV2?, _ error: Error?) -> Void)) -> RequestTask {
        return queryUserFilesWithRequestBuilder(organizationUserFilesToSyncQueryInput: organizationUserFilesToSyncQueryInput).execute(apiResponseQueue) { result in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     User Files V2
     
     - parameter organizationUserFilesToSyncQueryInput: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    private class func queryUserFilesAsyncMappedParams(organizationUserFilesToSyncQueryInput: OrganizationUserFilesToSyncQueryInput) async throws -> UserFilesV2 {
        return try await withCheckedThrowingContinuation { continuation in
            queryUserFilesWithRequestBuilder(organizationUserFilesToSyncQueryInput: organizationUserFilesToSyncQueryInput).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }

    /**
     User Files V2
     
     - parameter organizationUserFilesToSyncQueryInput: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    open class func queryUserFiles(
        pagination: Pagination? = nil, 
        orderBy: OrganizationUserFilesToSyncOrderByTypes? = nil, 
        orderDir: OrderDir? = nil, 
        filters: OrganizationUserFilesToSyncFilters? = nil, 
        includeRawFile: Bool? = nil, 
        includeParsedTextFile: Bool? = nil, 
        includeAdditionalFiles: Bool? = nil
    ) async throws -> UserFilesV2 {
        let organizationUserFilesToSyncQueryInput = OrganizationUserFilesToSyncQueryInput(
            pagination: pagination,
            orderBy: orderBy,
            orderDir: orderDir,
            filters: filters,
            includeRawFile: includeRawFile,
            includeParsedTextFile: includeParsedTextFile,
            includeAdditionalFiles: includeAdditionalFiles
        )
        return try await withCheckedThrowingContinuation { continuation in
            queryUserFilesWithRequestBuilder(organizationUserFilesToSyncQueryInput: organizationUserFilesToSyncQueryInput).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    /**
     User Files V2
     
     - parameter organizationUserFilesToSyncQueryInput: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    open func queryUserFiles(
        pagination: Pagination? = nil, 
        orderBy: OrganizationUserFilesToSyncOrderByTypes? = nil, 
        orderDir: OrderDir? = nil, 
        filters: OrganizationUserFilesToSyncFilters? = nil, 
        includeRawFile: Bool? = nil, 
        includeParsedTextFile: Bool? = nil, 
        includeAdditionalFiles: Bool? = nil
    ) async throws -> UserFilesV2 {
        let organizationUserFilesToSyncQueryInput = OrganizationUserFilesToSyncQueryInput(
            pagination: pagination,
            orderBy: orderBy,
            orderDir: orderDir,
            filters: filters,
            includeRawFile: includeRawFile,
            includeParsedTextFile: includeParsedTextFile,
            includeAdditionalFiles: includeAdditionalFiles
        )
        return try await withCheckedThrowingContinuation { continuation in
            queryUserFilesWithRequestBuilder(organizationUserFilesToSyncQueryInput: organizationUserFilesToSyncQueryInput).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }



    /**
     User Files V2
     - POST /user_files_v2
     - For pre-filtering documents, using `tags_v2` is preferred to using `tags` (which is now deprecated). If both `tags_v2` and `tags` are specified, `tags` is ignored. `tags_v2` enables building complex filters through the use of \"AND\", \"OR\", and negation logic. Take the below input as an example: ```json {     \"OR\": [         {             \"key\": \"subject\",             \"value\": \"holy-bible\",             \"negate\": false         },         {             \"key\": \"person-of-interest\",             \"value\": \"jesus christ\",             \"negate\": false         },         {             \"key\": \"genre\",             \"value\": \"religion\",             \"negate\": true         }         {             \"AND\": [                 {                     \"key\": \"subject\",                     \"value\": \"tao-te-ching\",                     \"negate\": false                 },                 {                     \"key\": \"author\",                     \"value\": \"lao-tzu\",                     \"negate\": false                 }             ]         }     ] } ``` In this case, files will be filtered such that: 1. \"subject\" = \"holy-bible\" OR 2. \"person-of-interest\" = \"jesus christ\" OR 3. \"genre\" != \"religion\" OR 4. \"subject\" = \"tao-te-ching\" AND \"author\" = \"lao-tzu\"  Note that the top level of the query must be either an \"OR\" or \"AND\" array. Currently, nesting is limited to 3. For tag blocks (those with \"key\", \"value\", and \"negate\" keys), the following typing rules apply: 1. \"key\" isn't optional and must be a `string` 2. \"value\" isn't optional and can be `any` or list[`any`] 3. \"negate\" is optional and must be `true` or `false`. If present and `true`, then the filter block is negated in the resulting query. It is `false` by default.
     - API Key:
       - type: apiKey authorization 
       - name: accessToken
     - API Key:
       - type: apiKey authorization 
       - name: apiKey
     - API Key:
       - type: apiKey customer-id 
       - name: customerId
     - parameter organizationUserFilesToSyncQueryInput: (body)  
     - returns: RequestBuilder<UserFilesV2> 
     */
    open class func queryUserFilesWithRequestBuilder(
            organizationUserFilesToSyncQueryInput: OrganizationUserFilesToSyncQueryInput
    ) -> RequestBuilder<UserFilesV2> {
        let basePath = CarbonAPI.basePath;
        let localVariablePath = "/user_files_v2"
        let localVariableURLString = basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: organizationUserFilesToSyncQueryInput)

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        var localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        do {
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: CarbonAPI.accessToken, prefix: "Token ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: CarbonAPI.apiKey, prefix: "Bearer ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "customer-id", value: CarbonAPI.customerId, prefix: nil)
            let localVariableRequestBuilder: RequestBuilder<UserFilesV2>.Type = CarbonAPI.requestBuilderFactory.getBuilder()
            let URLString = localVariableUrlComponents?.string ?? localVariableURLString
            return localVariableRequestBuilder.init(method: "POST", URLString: URLString, parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
        } catch {
            print("Error: \(error)")
        }
        fatalError("Error: Unable to send request to POST /user_files_v2")
    }

    /**
     User Files V2
     - POST /user_files_v2
     - For pre-filtering documents, using `tags_v2` is preferred to using `tags` (which is now deprecated). If both `tags_v2` and `tags` are specified, `tags` is ignored. `tags_v2` enables building complex filters through the use of \"AND\", \"OR\", and negation logic. Take the below input as an example: ```json {     \"OR\": [         {             \"key\": \"subject\",             \"value\": \"holy-bible\",             \"negate\": false         },         {             \"key\": \"person-of-interest\",             \"value\": \"jesus christ\",             \"negate\": false         },         {             \"key\": \"genre\",             \"value\": \"religion\",             \"negate\": true         }         {             \"AND\": [                 {                     \"key\": \"subject\",                     \"value\": \"tao-te-ching\",                     \"negate\": false                 },                 {                     \"key\": \"author\",                     \"value\": \"lao-tzu\",                     \"negate\": false                 }             ]         }     ] } ``` In this case, files will be filtered such that: 1. \"subject\" = \"holy-bible\" OR 2. \"person-of-interest\" = \"jesus christ\" OR 3. \"genre\" != \"religion\" OR 4. \"subject\" = \"tao-te-ching\" AND \"author\" = \"lao-tzu\"  Note that the top level of the query must be either an \"OR\" or \"AND\" array. Currently, nesting is limited to 3. For tag blocks (those with \"key\", \"value\", and \"negate\" keys), the following typing rules apply: 1. \"key\" isn't optional and must be a `string` 2. \"value\" isn't optional and can be `any` or list[`any`] 3. \"negate\" is optional and must be `true` or `false`. If present and `true`, then the filter block is negated in the resulting query. It is `false` by default.
     - API Key:
       - type: apiKey authorization 
       - name: accessToken
     - API Key:
       - type: apiKey authorization 
       - name: apiKey
     - API Key:
       - type: apiKey customer-id 
       - name: customerId
     - parameter organizationUserFilesToSyncQueryInput: (body)  
     - returns: RequestBuilder<UserFilesV2> 
     */
    open func queryUserFilesWithRequestBuilder(
            organizationUserFilesToSyncQueryInput: OrganizationUserFilesToSyncQueryInput
    ) -> RequestBuilder<UserFilesV2> {
        let basePath = self.client.basePath;
        let localVariablePath = "/user_files_v2"
        let localVariableURLString = basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: organizationUserFilesToSyncQueryInput)

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        var localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        do {
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: self.client.accessToken, prefix: "Token ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: self.client.apiKey, prefix: "Bearer ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "customer-id", value: self.client.customerId, prefix: nil)
            let localVariableRequestBuilder: RequestBuilder<UserFilesV2>.Type = CarbonAPI.requestBuilderFactory.getBuilder()
            let URLString = localVariableUrlComponents?.string ?? localVariableURLString
            return localVariableRequestBuilder.init(method: "POST", URLString: URLString, parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
        } catch {
            print("Error: \(error)")
        }
        fatalError("Error: Unable to send request to POST /user_files_v2")
    }


    /**
     User Files
     
     - parameter organizationUserFilesToSyncQueryInput: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(*, deprecated, message: "This operation is deprecated.")
    @discardableResult
    open class func queryUserFilesDeprecatedSync(organizationUserFilesToSyncQueryInput: OrganizationUserFilesToSyncQueryInput, apiResponseQueue: DispatchQueue = CarbonAPI.apiResponseQueue, completion: @escaping ((_ data: [UserFile]?, _ error: Error?) -> Void)) -> RequestTask {
        return queryUserFilesDeprecatedWithRequestBuilder(organizationUserFilesToSyncQueryInput: organizationUserFilesToSyncQueryInput).execute(apiResponseQueue) { result in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     User Files
     
     - parameter organizationUserFilesToSyncQueryInput: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(*, deprecated, message: "This operation is deprecated.")
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    private class func queryUserFilesDeprecatedAsyncMappedParams(organizationUserFilesToSyncQueryInput: OrganizationUserFilesToSyncQueryInput) async throws -> [UserFile] {
        return try await withCheckedThrowingContinuation { continuation in
            queryUserFilesDeprecatedWithRequestBuilder(organizationUserFilesToSyncQueryInput: organizationUserFilesToSyncQueryInput).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }

    /**
     User Files
     
     - parameter organizationUserFilesToSyncQueryInput: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(*, deprecated, message: "This operation is deprecated.")
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    open class func queryUserFilesDeprecated(
        pagination: Pagination? = nil, 
        orderBy: OrganizationUserFilesToSyncOrderByTypes? = nil, 
        orderDir: OrderDir? = nil, 
        filters: OrganizationUserFilesToSyncFilters? = nil, 
        includeRawFile: Bool? = nil, 
        includeParsedTextFile: Bool? = nil, 
        includeAdditionalFiles: Bool? = nil
    ) async throws -> [UserFile] {
        let organizationUserFilesToSyncQueryInput = OrganizationUserFilesToSyncQueryInput(
            pagination: pagination,
            orderBy: orderBy,
            orderDir: orderDir,
            filters: filters,
            includeRawFile: includeRawFile,
            includeParsedTextFile: includeParsedTextFile,
            includeAdditionalFiles: includeAdditionalFiles
        )
        return try await withCheckedThrowingContinuation { continuation in
            queryUserFilesDeprecatedWithRequestBuilder(organizationUserFilesToSyncQueryInput: organizationUserFilesToSyncQueryInput).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    /**
     User Files
     
     - parameter organizationUserFilesToSyncQueryInput: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(*, deprecated, message: "This operation is deprecated.")
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    open func queryUserFilesDeprecated(
        pagination: Pagination? = nil, 
        orderBy: OrganizationUserFilesToSyncOrderByTypes? = nil, 
        orderDir: OrderDir? = nil, 
        filters: OrganizationUserFilesToSyncFilters? = nil, 
        includeRawFile: Bool? = nil, 
        includeParsedTextFile: Bool? = nil, 
        includeAdditionalFiles: Bool? = nil
    ) async throws -> [UserFile] {
        let organizationUserFilesToSyncQueryInput = OrganizationUserFilesToSyncQueryInput(
            pagination: pagination,
            orderBy: orderBy,
            orderDir: orderDir,
            filters: filters,
            includeRawFile: includeRawFile,
            includeParsedTextFile: includeParsedTextFile,
            includeAdditionalFiles: includeAdditionalFiles
        )
        return try await withCheckedThrowingContinuation { continuation in
            queryUserFilesDeprecatedWithRequestBuilder(organizationUserFilesToSyncQueryInput: organizationUserFilesToSyncQueryInput).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }



    /**
     User Files
     - POST /user_files
     - This route is deprecated. Use `/user_files_v2` instead.
     - API Key:
       - type: apiKey authorization 
       - name: accessToken
     - API Key:
       - type: apiKey authorization 
       - name: apiKey
     - API Key:
       - type: apiKey customer-id 
       - name: customerId
     - parameter organizationUserFilesToSyncQueryInput: (body)  
     - returns: RequestBuilder<[UserFile]> 
     */
    @available(*, deprecated, message: "This operation is deprecated.")
    open class func queryUserFilesDeprecatedWithRequestBuilder(
            organizationUserFilesToSyncQueryInput: OrganizationUserFilesToSyncQueryInput
    ) -> RequestBuilder<[UserFile]> {
        let basePath = CarbonAPI.basePath;
        let localVariablePath = "/user_files"
        let localVariableURLString = basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: organizationUserFilesToSyncQueryInput)

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        var localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        do {
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: CarbonAPI.accessToken, prefix: "Token ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: CarbonAPI.apiKey, prefix: "Bearer ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "customer-id", value: CarbonAPI.customerId, prefix: nil)
            let localVariableRequestBuilder: RequestBuilder<[UserFile]>.Type = CarbonAPI.requestBuilderFactory.getBuilder()
            let URLString = localVariableUrlComponents?.string ?? localVariableURLString
            return localVariableRequestBuilder.init(method: "POST", URLString: URLString, parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
        } catch {
            print("Error: \(error)")
        }
        fatalError("Error: Unable to send request to POST /user_files")
    }

    /**
     User Files
     - POST /user_files
     - This route is deprecated. Use `/user_files_v2` instead.
     - API Key:
       - type: apiKey authorization 
       - name: accessToken
     - API Key:
       - type: apiKey authorization 
       - name: apiKey
     - API Key:
       - type: apiKey customer-id 
       - name: customerId
     - parameter organizationUserFilesToSyncQueryInput: (body)  
     - returns: RequestBuilder<[UserFile]> 
     */
    @available(*, deprecated, message: "This operation is deprecated.")
    open func queryUserFilesDeprecatedWithRequestBuilder(
            organizationUserFilesToSyncQueryInput: OrganizationUserFilesToSyncQueryInput
    ) -> RequestBuilder<[UserFile]> {
        let basePath = self.client.basePath;
        let localVariablePath = "/user_files"
        let localVariableURLString = basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: organizationUserFilesToSyncQueryInput)

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        var localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        do {
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: self.client.accessToken, prefix: "Token ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: self.client.apiKey, prefix: "Bearer ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "customer-id", value: self.client.customerId, prefix: nil)
            let localVariableRequestBuilder: RequestBuilder<[UserFile]>.Type = CarbonAPI.requestBuilderFactory.getBuilder()
            let URLString = localVariableUrlComponents?.string ?? localVariableURLString
            return localVariableRequestBuilder.init(method: "POST", URLString: URLString, parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
        } catch {
            print("Error: \(error)")
        }
        fatalError("Error: Unable to send request to POST /user_files")
    }


    /**
     Resync File
     
     - parameter resyncFileQueryInput: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @discardableResult
    open class func resyncSync(resyncFileQueryInput: ResyncFileQueryInput, apiResponseQueue: DispatchQueue = CarbonAPI.apiResponseQueue, completion: @escaping ((_ data: UserFile?, _ error: Error?) -> Void)) -> RequestTask {
        return resyncWithRequestBuilder(resyncFileQueryInput: resyncFileQueryInput).execute(apiResponseQueue) { result in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Resync File
     
     - parameter resyncFileQueryInput: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    private class func resyncAsyncMappedParams(resyncFileQueryInput: ResyncFileQueryInput) async throws -> UserFile {
        return try await withCheckedThrowingContinuation { continuation in
            resyncWithRequestBuilder(resyncFileQueryInput: resyncFileQueryInput).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }

    /**
     Resync File
     
     - parameter resyncFileQueryInput: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    open class func resync(
        fileId: Int,
        chunkSize: Int? = nil, 
        chunkOverlap: Int? = nil, 
        forceEmbeddingGeneration: Bool? = nil
    ) async throws -> UserFile {
        let resyncFileQueryInput = ResyncFileQueryInput(
            fileId: fileId,
            chunkSize: chunkSize,
            chunkOverlap: chunkOverlap,
            forceEmbeddingGeneration: forceEmbeddingGeneration
        )
        return try await withCheckedThrowingContinuation { continuation in
            resyncWithRequestBuilder(resyncFileQueryInput: resyncFileQueryInput).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    /**
     Resync File
     
     - parameter resyncFileQueryInput: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    open func resync(
        fileId: Int,
        chunkSize: Int? = nil, 
        chunkOverlap: Int? = nil, 
        forceEmbeddingGeneration: Bool? = nil
    ) async throws -> UserFile {
        let resyncFileQueryInput = ResyncFileQueryInput(
            fileId: fileId,
            chunkSize: chunkSize,
            chunkOverlap: chunkOverlap,
            forceEmbeddingGeneration: forceEmbeddingGeneration
        )
        return try await withCheckedThrowingContinuation { continuation in
            resyncWithRequestBuilder(resyncFileQueryInput: resyncFileQueryInput).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }



    /**
     Resync File
     - POST /resync_file
     - API Key:
       - type: apiKey authorization 
       - name: accessToken
     - API Key:
       - type: apiKey authorization 
       - name: apiKey
     - API Key:
       - type: apiKey customer-id 
       - name: customerId
     - parameter resyncFileQueryInput: (body)  
     - returns: RequestBuilder<UserFile> 
     */
    open class func resyncWithRequestBuilder(
            resyncFileQueryInput: ResyncFileQueryInput
    ) -> RequestBuilder<UserFile> {
        let basePath = CarbonAPI.basePath;
        let localVariablePath = "/resync_file"
        let localVariableURLString = basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: resyncFileQueryInput)

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        var localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        do {
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: CarbonAPI.accessToken, prefix: "Token ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: CarbonAPI.apiKey, prefix: "Bearer ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "customer-id", value: CarbonAPI.customerId, prefix: nil)
            let localVariableRequestBuilder: RequestBuilder<UserFile>.Type = CarbonAPI.requestBuilderFactory.getBuilder()
            let URLString = localVariableUrlComponents?.string ?? localVariableURLString
            return localVariableRequestBuilder.init(method: "POST", URLString: URLString, parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
        } catch {
            print("Error: \(error)")
        }
        fatalError("Error: Unable to send request to POST /resync_file")
    }

    /**
     Resync File
     - POST /resync_file
     - API Key:
       - type: apiKey authorization 
       - name: accessToken
     - API Key:
       - type: apiKey authorization 
       - name: apiKey
     - API Key:
       - type: apiKey customer-id 
       - name: customerId
     - parameter resyncFileQueryInput: (body)  
     - returns: RequestBuilder<UserFile> 
     */
    open func resyncWithRequestBuilder(
            resyncFileQueryInput: ResyncFileQueryInput
    ) -> RequestBuilder<UserFile> {
        let basePath = self.client.basePath;
        let localVariablePath = "/resync_file"
        let localVariableURLString = basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: resyncFileQueryInput)

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        var localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        do {
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: self.client.accessToken, prefix: "Token ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: self.client.apiKey, prefix: "Bearer ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "customer-id", value: self.client.customerId, prefix: nil)
            let localVariableRequestBuilder: RequestBuilder<UserFile>.Type = CarbonAPI.requestBuilderFactory.getBuilder()
            let URLString = localVariableUrlComponents?.string ?? localVariableURLString
            return localVariableRequestBuilder.init(method: "POST", URLString: URLString, parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
        } catch {
            print("Error: \(error)")
        }
        fatalError("Error: Unable to send request to POST /resync_file")
    }


    /**
     Create Upload File
     
     - parameter file: (form)  
     - parameter bodyCreateUploadFileUploadfilePost: (body)  
     - parameter chunkSize: (query) Chunk size in tiktoken tokens to be used when processing file. (optional)
     - parameter chunkOverlap: (query) Chunk overlap in tiktoken tokens to be used when processing file. (optional)
     - parameter skipEmbeddingGeneration: (query) Flag to control whether or not embeddings should be generated and stored             when processing file. (optional, default to false)
     - parameter setPageAsBoundary: (query) Flag to control whether or not to set the a page&#39;s worth of content as the maximum             amount of content that can appear in a chunk. Only valid for PDFs. See description route description for             more information. (optional, default to false)
     - parameter embeddingModel: (query) Embedding model that will be used to embed file chunks. (optional)
     - parameter useOcr: (query) Whether or not to use OCR when processing files. Only valid for PDFs. Useful for documents with             tables, images, and/or scanned text. (optional, default to false)
     - parameter generateSparseVectors: (query) Whether or not to generate sparse vectors for the file. This is *required* for the file to be a             candidate for hybrid search. (optional, default to false)
     - parameter prependFilenameToChunks: (query) Whether or not to prepend the file&#39;s name to chunks. (optional, default to false)
     - parameter maxItemsPerChunk: (query) Number of objects per chunk. For csv, tsv, xlsx, and json files only. (optional)
     - parameter parsePdfTablesWithOcr: (query) Whether to use rich table parsing when &#x60;use_ocr&#x60; is enabled. (optional, default to false)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @discardableResult
    open class func uploadSync(file: URL, bodyCreateUploadFileUploadfilePost: BodyCreateUploadFileUploadfilePost, chunkSize: Int? = nil, chunkOverlap: Int? = nil, skipEmbeddingGeneration: Bool? = nil, setPageAsBoundary: Bool? = nil, embeddingModel: TextEmbeddingGenerators? = nil, useOcr: Bool? = nil, generateSparseVectors: Bool? = nil, prependFilenameToChunks: Bool? = nil, maxItemsPerChunk: Int? = nil, parsePdfTablesWithOcr: Bool? = nil, apiResponseQueue: DispatchQueue = CarbonAPI.apiResponseQueue, completion: @escaping ((_ data: UserFile?, _ error: Error?) -> Void)) -> RequestTask {
        return uploadWithRequestBuilder(file: file, bodyCreateUploadFileUploadfilePost: bodyCreateUploadFileUploadfilePost, chunkSize: chunkSize, chunkOverlap: chunkOverlap, skipEmbeddingGeneration: skipEmbeddingGeneration, setPageAsBoundary: setPageAsBoundary, embeddingModel: embeddingModel, useOcr: useOcr, generateSparseVectors: generateSparseVectors, prependFilenameToChunks: prependFilenameToChunks, maxItemsPerChunk: maxItemsPerChunk, parsePdfTablesWithOcr: parsePdfTablesWithOcr).execute(apiResponseQueue) { result in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Create Upload File
     
     - parameter file: (form)  
     - parameter bodyCreateUploadFileUploadfilePost: (body)  
     - parameter chunkSize: (query) Chunk size in tiktoken tokens to be used when processing file. (optional)
     - parameter chunkOverlap: (query) Chunk overlap in tiktoken tokens to be used when processing file. (optional)
     - parameter skipEmbeddingGeneration: (query) Flag to control whether or not embeddings should be generated and stored             when processing file. (optional, default to false)
     - parameter setPageAsBoundary: (query) Flag to control whether or not to set the a page&#39;s worth of content as the maximum             amount of content that can appear in a chunk. Only valid for PDFs. See description route description for             more information. (optional, default to false)
     - parameter embeddingModel: (query) Embedding model that will be used to embed file chunks. (optional)
     - parameter useOcr: (query) Whether or not to use OCR when processing files. Only valid for PDFs. Useful for documents with             tables, images, and/or scanned text. (optional, default to false)
     - parameter generateSparseVectors: (query) Whether or not to generate sparse vectors for the file. This is *required* for the file to be a             candidate for hybrid search. (optional, default to false)
     - parameter prependFilenameToChunks: (query) Whether or not to prepend the file&#39;s name to chunks. (optional, default to false)
     - parameter maxItemsPerChunk: (query) Number of objects per chunk. For csv, tsv, xlsx, and json files only. (optional)
     - parameter parsePdfTablesWithOcr: (query) Whether to use rich table parsing when &#x60;use_ocr&#x60; is enabled. (optional, default to false)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    private class func uploadAsyncMappedParams(file: URL, bodyCreateUploadFileUploadfilePost: BodyCreateUploadFileUploadfilePost, chunkSize: Int? = nil, chunkOverlap: Int? = nil, skipEmbeddingGeneration: Bool? = nil, setPageAsBoundary: Bool? = nil, embeddingModel: TextEmbeddingGenerators? = nil, useOcr: Bool? = nil, generateSparseVectors: Bool? = nil, prependFilenameToChunks: Bool? = nil, maxItemsPerChunk: Int? = nil, parsePdfTablesWithOcr: Bool? = nil) async throws -> UserFile {
        return try await withCheckedThrowingContinuation { continuation in
            uploadWithRequestBuilder(file: file, bodyCreateUploadFileUploadfilePost: bodyCreateUploadFileUploadfilePost, chunkSize: chunkSize, chunkOverlap: chunkOverlap, skipEmbeddingGeneration: skipEmbeddingGeneration, setPageAsBoundary: setPageAsBoundary, embeddingModel: embeddingModel, useOcr: useOcr, generateSparseVectors: generateSparseVectors, prependFilenameToChunks: prependFilenameToChunks, maxItemsPerChunk: maxItemsPerChunk, parsePdfTablesWithOcr: parsePdfTablesWithOcr).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }

    /**
     Create Upload File
     
     - parameter file: (form)  
     - parameter bodyCreateUploadFileUploadfilePost: (body)  
     - parameter chunkSize: (query) Chunk size in tiktoken tokens to be used when processing file. (optional)
     - parameter chunkOverlap: (query) Chunk overlap in tiktoken tokens to be used when processing file. (optional)
     - parameter skipEmbeddingGeneration: (query) Flag to control whether or not embeddings should be generated and stored             when processing file. (optional, default to false)
     - parameter setPageAsBoundary: (query) Flag to control whether or not to set the a page&#39;s worth of content as the maximum             amount of content that can appear in a chunk. Only valid for PDFs. See description route description for             more information. (optional, default to false)
     - parameter embeddingModel: (query) Embedding model that will be used to embed file chunks. (optional)
     - parameter useOcr: (query) Whether or not to use OCR when processing files. Only valid for PDFs. Useful for documents with             tables, images, and/or scanned text. (optional, default to false)
     - parameter generateSparseVectors: (query) Whether or not to generate sparse vectors for the file. This is *required* for the file to be a             candidate for hybrid search. (optional, default to false)
     - parameter prependFilenameToChunks: (query) Whether or not to prepend the file&#39;s name to chunks. (optional, default to false)
     - parameter maxItemsPerChunk: (query) Number of objects per chunk. For csv, tsv, xlsx, and json files only. (optional)
     - parameter parsePdfTablesWithOcr: (query) Whether to use rich table parsing when &#x60;use_ocr&#x60; is enabled. (optional, default to false)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    open class func upload(
        file: URL,
        chunkSize: Int? = nil, 
        chunkOverlap: Int? = nil, 
        skipEmbeddingGeneration: Bool? = nil, 
        setPageAsBoundary: Bool? = nil, 
        embeddingModel: TextEmbeddingGenerators? = nil, 
        useOcr: Bool? = nil, 
        generateSparseVectors: Bool? = nil, 
        prependFilenameToChunks: Bool? = nil, 
        maxItemsPerChunk: Int? = nil, 
        parsePdfTablesWithOcr: Bool? = nil
    ) async throws -> UserFile {
        let bodyCreateUploadFileUploadfilePost = BodyCreateUploadFileUploadfilePost(
            file: file
        )
        return try await withCheckedThrowingContinuation { continuation in
            uploadWithRequestBuilder(file: file, bodyCreateUploadFileUploadfilePost: bodyCreateUploadFileUploadfilePost, chunkSize: chunkSize, chunkOverlap: chunkOverlap, skipEmbeddingGeneration: skipEmbeddingGeneration, setPageAsBoundary: setPageAsBoundary, embeddingModel: embeddingModel, useOcr: useOcr, generateSparseVectors: generateSparseVectors, prependFilenameToChunks: prependFilenameToChunks, maxItemsPerChunk: maxItemsPerChunk, parsePdfTablesWithOcr: parsePdfTablesWithOcr).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    /**
     Create Upload File
     
     - parameter file: (form)  
     - parameter bodyCreateUploadFileUploadfilePost: (body)  
     - parameter chunkSize: (query) Chunk size in tiktoken tokens to be used when processing file. (optional)
     - parameter chunkOverlap: (query) Chunk overlap in tiktoken tokens to be used when processing file. (optional)
     - parameter skipEmbeddingGeneration: (query) Flag to control whether or not embeddings should be generated and stored             when processing file. (optional, default to false)
     - parameter setPageAsBoundary: (query) Flag to control whether or not to set the a page&#39;s worth of content as the maximum             amount of content that can appear in a chunk. Only valid for PDFs. See description route description for             more information. (optional, default to false)
     - parameter embeddingModel: (query) Embedding model that will be used to embed file chunks. (optional)
     - parameter useOcr: (query) Whether or not to use OCR when processing files. Only valid for PDFs. Useful for documents with             tables, images, and/or scanned text. (optional, default to false)
     - parameter generateSparseVectors: (query) Whether or not to generate sparse vectors for the file. This is *required* for the file to be a             candidate for hybrid search. (optional, default to false)
     - parameter prependFilenameToChunks: (query) Whether or not to prepend the file&#39;s name to chunks. (optional, default to false)
     - parameter maxItemsPerChunk: (query) Number of objects per chunk. For csv, tsv, xlsx, and json files only. (optional)
     - parameter parsePdfTablesWithOcr: (query) Whether to use rich table parsing when &#x60;use_ocr&#x60; is enabled. (optional, default to false)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    open func upload(
        file: URL,
        chunkSize: Int? = nil, 
        chunkOverlap: Int? = nil, 
        skipEmbeddingGeneration: Bool? = nil, 
        setPageAsBoundary: Bool? = nil, 
        embeddingModel: TextEmbeddingGenerators? = nil, 
        useOcr: Bool? = nil, 
        generateSparseVectors: Bool? = nil, 
        prependFilenameToChunks: Bool? = nil, 
        maxItemsPerChunk: Int? = nil, 
        parsePdfTablesWithOcr: Bool? = nil
    ) async throws -> UserFile {
        let bodyCreateUploadFileUploadfilePost = BodyCreateUploadFileUploadfilePost(
            file: file
        )
        return try await withCheckedThrowingContinuation { continuation in
            uploadWithRequestBuilder(file: file, bodyCreateUploadFileUploadfilePost: bodyCreateUploadFileUploadfilePost, chunkSize: chunkSize, chunkOverlap: chunkOverlap, skipEmbeddingGeneration: skipEmbeddingGeneration, setPageAsBoundary: setPageAsBoundary, embeddingModel: embeddingModel, useOcr: useOcr, generateSparseVectors: generateSparseVectors, prependFilenameToChunks: prependFilenameToChunks, maxItemsPerChunk: maxItemsPerChunk, parsePdfTablesWithOcr: parsePdfTablesWithOcr).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }



    /**
     Create Upload File
     - POST /uploadfile
     - This endpoint is used to directly upload local files to Carbon. The `POST` request should be a multipart form request. Note that the `set_page_as_boundary` query parameter is applicable only to PDFs for now. When this value is set, PDF chunks are at most one page long. Additional information can be retrieved for each chunk, however, namely the coordinates of the bounding box around the chunk (this can be used for things like text highlighting). Following is a description of all possible query parameters: - `chunk_size`: the chunk size (in tokens) applied when splitting the document - `chunk_overlap`: the chunk overlap (in tokens) applied when splitting the document - `skip_embedding_generation`: whether or not to skip the generation of chunks and embeddings - `set_page_as_boundary`: described above - `embedding_model`: the model used to generate embeddings for the document chunks - `use_ocr`: whether or not to use OCR as a preprocessing step prior to generating chunks (only valid for PDFs currently) - `generate_sparse_vectors`: whether or not to generate sparse vectors for the file. Required for hybrid search. - `prepend_filename_to_chunks`: whether or not to prepend the filename to the chunk text   Carbon supports multiple models for use in generating embeddings for files. For images, we support Vertex AI's multimodal model; for text, we support OpenAI's `text-embedding-ada-002` and Cohere's embed-multilingual-v3.0. The model can be specified via the `embedding_model` parameter (in the POST body for `/embeddings`, and a query  parameter in `/uploadfile`). If no model is supplied, the `text-embedding-ada-002` is used by default. When performing embedding queries, embeddings from files that used the specified model will be considered in the query. For example, if files A and B have embeddings generated with `OPENAI`, and files C and D have embeddings generated with `COHERE_MULTILINGUAL_V3`, then by default, queries will only consider files A and B. If `COHERE_MULTILINGUAL_V3` is specified as the `embedding_model` in `/embeddings`, then only files C and D will be considered. Make sure that the set of all files you want considered for a query have embeddings generated via the same model. For now, **do not** set `VERTEX_MULTIMODAL` as an `embedding_model`. This model is used automatically by Carbon when it detects an image file.
     - API Key:
       - type: apiKey authorization 
       - name: accessToken
     - API Key:
       - type: apiKey authorization 
       - name: apiKey
     - API Key:
       - type: apiKey customer-id 
       - name: customerId
     - parameter file: (form)  
     - parameter bodyCreateUploadFileUploadfilePost: (body)  
     - parameter chunkSize: (query) Chunk size in tiktoken tokens to be used when processing file. (optional)
     - parameter chunkOverlap: (query) Chunk overlap in tiktoken tokens to be used when processing file. (optional)
     - parameter skipEmbeddingGeneration: (query) Flag to control whether or not embeddings should be generated and stored             when processing file. (optional, default to false)
     - parameter setPageAsBoundary: (query) Flag to control whether or not to set the a page&#39;s worth of content as the maximum             amount of content that can appear in a chunk. Only valid for PDFs. See description route description for             more information. (optional, default to false)
     - parameter embeddingModel: (query) Embedding model that will be used to embed file chunks. (optional)
     - parameter useOcr: (query) Whether or not to use OCR when processing files. Only valid for PDFs. Useful for documents with             tables, images, and/or scanned text. (optional, default to false)
     - parameter generateSparseVectors: (query) Whether or not to generate sparse vectors for the file. This is *required* for the file to be a             candidate for hybrid search. (optional, default to false)
     - parameter prependFilenameToChunks: (query) Whether or not to prepend the file&#39;s name to chunks. (optional, default to false)
     - parameter maxItemsPerChunk: (query) Number of objects per chunk. For csv, tsv, xlsx, and json files only. (optional)
     - parameter parsePdfTablesWithOcr: (query) Whether to use rich table parsing when &#x60;use_ocr&#x60; is enabled. (optional, default to false)
     - returns: RequestBuilder<UserFile> 
     */
    open class func uploadWithRequestBuilder(
            file: URL,
            bodyCreateUploadFileUploadfilePost: BodyCreateUploadFileUploadfilePost,
            chunkSize: Int? = nil,
            chunkOverlap: Int? = nil,
            skipEmbeddingGeneration: Bool? = nil,
            setPageAsBoundary: Bool? = nil,
            embeddingModel: TextEmbeddingGenerators? = nil,
            useOcr: Bool? = nil,
            generateSparseVectors: Bool? = nil,
            prependFilenameToChunks: Bool? = nil,
            maxItemsPerChunk: Int? = nil,
            parsePdfTablesWithOcr: Bool? = nil
    ) -> RequestBuilder<UserFile> {
        let basePath = CarbonAPI.basePath;
        let localVariablePath = "/uploadfile"
        let localVariableURLString = basePath + localVariablePath
        let localVariableFormParams: [String: Any?] = [
            "file": file.encodeToJSON(),
        ]

        let localVariableNonNullParameters = APIHelper.rejectNil(localVariableFormParams)
        let localVariableParameters = APIHelper.convertBoolToString(localVariableNonNullParameters)
        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "chunk_size": (wrappedValue: chunkSize?.encodeToJSON(), isExplode: true),
            "chunk_overlap": (wrappedValue: chunkOverlap?.encodeToJSON(), isExplode: true),
            "skip_embedding_generation": (wrappedValue: skipEmbeddingGeneration?.encodeToJSON(), isExplode: true),
            "set_page_as_boundary": (wrappedValue: setPageAsBoundary?.encodeToJSON(), isExplode: true),
            "embedding_model": (wrappedValue: embeddingModel?.encodeToJSON(), isExplode: true),
            "use_ocr": (wrappedValue: useOcr?.encodeToJSON(), isExplode: true),
            "generate_sparse_vectors": (wrappedValue: generateSparseVectors?.encodeToJSON(), isExplode: true),
            "prepend_filename_to_chunks": (wrappedValue: prependFilenameToChunks?.encodeToJSON(), isExplode: true),
            "max_items_per_chunk": (wrappedValue: maxItemsPerChunk?.encodeToJSON(), isExplode: true),
            "parse_pdf_tables_with_ocr": (wrappedValue: parsePdfTablesWithOcr?.encodeToJSON(), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            "Content-Type": "multipart/form-data",
        ]

        var localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        do {
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: CarbonAPI.accessToken, prefix: "Token ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: CarbonAPI.apiKey, prefix: "Bearer ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "customer-id", value: CarbonAPI.customerId, prefix: nil)
            let localVariableRequestBuilder: RequestBuilder<UserFile>.Type = CarbonAPI.requestBuilderFactory.getBuilder()
            let URLString = localVariableUrlComponents?.string ?? localVariableURLString
            return localVariableRequestBuilder.init(method: "POST", URLString: URLString, parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
        } catch {
            print("Error: \(error)")
        }
        fatalError("Error: Unable to send request to POST /uploadfile")
    }

    /**
     Create Upload File
     - POST /uploadfile
     - This endpoint is used to directly upload local files to Carbon. The `POST` request should be a multipart form request. Note that the `set_page_as_boundary` query parameter is applicable only to PDFs for now. When this value is set, PDF chunks are at most one page long. Additional information can be retrieved for each chunk, however, namely the coordinates of the bounding box around the chunk (this can be used for things like text highlighting). Following is a description of all possible query parameters: - `chunk_size`: the chunk size (in tokens) applied when splitting the document - `chunk_overlap`: the chunk overlap (in tokens) applied when splitting the document - `skip_embedding_generation`: whether or not to skip the generation of chunks and embeddings - `set_page_as_boundary`: described above - `embedding_model`: the model used to generate embeddings for the document chunks - `use_ocr`: whether or not to use OCR as a preprocessing step prior to generating chunks (only valid for PDFs currently) - `generate_sparse_vectors`: whether or not to generate sparse vectors for the file. Required for hybrid search. - `prepend_filename_to_chunks`: whether or not to prepend the filename to the chunk text   Carbon supports multiple models for use in generating embeddings for files. For images, we support Vertex AI's multimodal model; for text, we support OpenAI's `text-embedding-ada-002` and Cohere's embed-multilingual-v3.0. The model can be specified via the `embedding_model` parameter (in the POST body for `/embeddings`, and a query  parameter in `/uploadfile`). If no model is supplied, the `text-embedding-ada-002` is used by default. When performing embedding queries, embeddings from files that used the specified model will be considered in the query. For example, if files A and B have embeddings generated with `OPENAI`, and files C and D have embeddings generated with `COHERE_MULTILINGUAL_V3`, then by default, queries will only consider files A and B. If `COHERE_MULTILINGUAL_V3` is specified as the `embedding_model` in `/embeddings`, then only files C and D will be considered. Make sure that the set of all files you want considered for a query have embeddings generated via the same model. For now, **do not** set `VERTEX_MULTIMODAL` as an `embedding_model`. This model is used automatically by Carbon when it detects an image file.
     - API Key:
       - type: apiKey authorization 
       - name: accessToken
     - API Key:
       - type: apiKey authorization 
       - name: apiKey
     - API Key:
       - type: apiKey customer-id 
       - name: customerId
     - parameter file: (form)  
     - parameter bodyCreateUploadFileUploadfilePost: (body)  
     - parameter chunkSize: (query) Chunk size in tiktoken tokens to be used when processing file. (optional)
     - parameter chunkOverlap: (query) Chunk overlap in tiktoken tokens to be used when processing file. (optional)
     - parameter skipEmbeddingGeneration: (query) Flag to control whether or not embeddings should be generated and stored             when processing file. (optional, default to false)
     - parameter setPageAsBoundary: (query) Flag to control whether or not to set the a page&#39;s worth of content as the maximum             amount of content that can appear in a chunk. Only valid for PDFs. See description route description for             more information. (optional, default to false)
     - parameter embeddingModel: (query) Embedding model that will be used to embed file chunks. (optional)
     - parameter useOcr: (query) Whether or not to use OCR when processing files. Only valid for PDFs. Useful for documents with             tables, images, and/or scanned text. (optional, default to false)
     - parameter generateSparseVectors: (query) Whether or not to generate sparse vectors for the file. This is *required* for the file to be a             candidate for hybrid search. (optional, default to false)
     - parameter prependFilenameToChunks: (query) Whether or not to prepend the file&#39;s name to chunks. (optional, default to false)
     - parameter maxItemsPerChunk: (query) Number of objects per chunk. For csv, tsv, xlsx, and json files only. (optional)
     - parameter parsePdfTablesWithOcr: (query) Whether to use rich table parsing when &#x60;use_ocr&#x60; is enabled. (optional, default to false)
     - returns: RequestBuilder<UserFile> 
     */
    open func uploadWithRequestBuilder(
            file: URL,
            bodyCreateUploadFileUploadfilePost: BodyCreateUploadFileUploadfilePost,
            chunkSize: Int? = nil,
            chunkOverlap: Int? = nil,
            skipEmbeddingGeneration: Bool? = nil,
            setPageAsBoundary: Bool? = nil,
            embeddingModel: TextEmbeddingGenerators? = nil,
            useOcr: Bool? = nil,
            generateSparseVectors: Bool? = nil,
            prependFilenameToChunks: Bool? = nil,
            maxItemsPerChunk: Int? = nil,
            parsePdfTablesWithOcr: Bool? = nil
    ) -> RequestBuilder<UserFile> {
        let basePath = self.client.basePath;
        let localVariablePath = "/uploadfile"
        let localVariableURLString = basePath + localVariablePath
        let localVariableFormParams: [String: Any?] = [
            "file": file.encodeToJSON(),
        ]

        let localVariableNonNullParameters = APIHelper.rejectNil(localVariableFormParams)
        let localVariableParameters = APIHelper.convertBoolToString(localVariableNonNullParameters)
        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "chunk_size": (wrappedValue: chunkSize?.encodeToJSON(), isExplode: true),
            "chunk_overlap": (wrappedValue: chunkOverlap?.encodeToJSON(), isExplode: true),
            "skip_embedding_generation": (wrappedValue: skipEmbeddingGeneration?.encodeToJSON(), isExplode: true),
            "set_page_as_boundary": (wrappedValue: setPageAsBoundary?.encodeToJSON(), isExplode: true),
            "embedding_model": (wrappedValue: embeddingModel?.encodeToJSON(), isExplode: true),
            "use_ocr": (wrappedValue: useOcr?.encodeToJSON(), isExplode: true),
            "generate_sparse_vectors": (wrappedValue: generateSparseVectors?.encodeToJSON(), isExplode: true),
            "prepend_filename_to_chunks": (wrappedValue: prependFilenameToChunks?.encodeToJSON(), isExplode: true),
            "max_items_per_chunk": (wrappedValue: maxItemsPerChunk?.encodeToJSON(), isExplode: true),
            "parse_pdf_tables_with_ocr": (wrappedValue: parsePdfTablesWithOcr?.encodeToJSON(), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            "Content-Type": "multipart/form-data",
        ]

        var localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        do {
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: self.client.accessToken, prefix: "Token ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: self.client.apiKey, prefix: "Bearer ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "customer-id", value: self.client.customerId, prefix: nil)
            let localVariableRequestBuilder: RequestBuilder<UserFile>.Type = CarbonAPI.requestBuilderFactory.getBuilder()
            let URLString = localVariableUrlComponents?.string ?? localVariableURLString
            return localVariableRequestBuilder.init(method: "POST", URLString: URLString, parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
        } catch {
            print("Error: \(error)")
        }
        fatalError("Error: Unable to send request to POST /uploadfile")
    }


    /**
     Create Upload File From Url
     
     - parameter uploadFileFromUrlInput: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @discardableResult
    open class func uploadFromUrlSync(uploadFileFromUrlInput: UploadFileFromUrlInput, apiResponseQueue: DispatchQueue = CarbonAPI.apiResponseQueue, completion: @escaping ((_ data: UserFile?, _ error: Error?) -> Void)) -> RequestTask {
        return uploadFromUrlWithRequestBuilder(uploadFileFromUrlInput: uploadFileFromUrlInput).execute(apiResponseQueue) { result in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Create Upload File From Url
     
     - parameter uploadFileFromUrlInput: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    private class func uploadFromUrlAsyncMappedParams(uploadFileFromUrlInput: UploadFileFromUrlInput) async throws -> UserFile {
        return try await withCheckedThrowingContinuation { continuation in
            uploadFromUrlWithRequestBuilder(uploadFileFromUrlInput: uploadFileFromUrlInput).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }

    /**
     Create Upload File From Url
     
     - parameter uploadFileFromUrlInput: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    open class func uploadFromUrl(
        url: String,
        fileName: String? = nil, 
        chunkSize: Int? = nil, 
        chunkOverlap: Int? = nil, 
        skipEmbeddingGeneration: Bool? = nil, 
        setPageAsBoundary: Bool? = nil, 
        embeddingModel: EmbeddingGenerators? = nil, 
        generateSparseVectors: Bool? = nil, 
        useTextract: Bool? = nil, 
        prependFilenameToChunks: Bool? = nil, 
        maxItemsPerChunk: Int? = nil, 
        parsePdfTablesWithOcr: Bool? = nil
    ) async throws -> UserFile {
        let uploadFileFromUrlInput = UploadFileFromUrlInput(
            url: url,
            fileName: fileName,
            chunkSize: chunkSize,
            chunkOverlap: chunkOverlap,
            skipEmbeddingGeneration: skipEmbeddingGeneration,
            setPageAsBoundary: setPageAsBoundary,
            embeddingModel: embeddingModel,
            generateSparseVectors: generateSparseVectors,
            useTextract: useTextract,
            prependFilenameToChunks: prependFilenameToChunks,
            maxItemsPerChunk: maxItemsPerChunk,
            parsePdfTablesWithOcr: parsePdfTablesWithOcr
        )
        return try await withCheckedThrowingContinuation { continuation in
            uploadFromUrlWithRequestBuilder(uploadFileFromUrlInput: uploadFileFromUrlInput).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    /**
     Create Upload File From Url
     
     - parameter uploadFileFromUrlInput: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    open func uploadFromUrl(
        url: String,
        fileName: String? = nil, 
        chunkSize: Int? = nil, 
        chunkOverlap: Int? = nil, 
        skipEmbeddingGeneration: Bool? = nil, 
        setPageAsBoundary: Bool? = nil, 
        embeddingModel: EmbeddingGenerators? = nil, 
        generateSparseVectors: Bool? = nil, 
        useTextract: Bool? = nil, 
        prependFilenameToChunks: Bool? = nil, 
        maxItemsPerChunk: Int? = nil, 
        parsePdfTablesWithOcr: Bool? = nil
    ) async throws -> UserFile {
        let uploadFileFromUrlInput = UploadFileFromUrlInput(
            url: url,
            fileName: fileName,
            chunkSize: chunkSize,
            chunkOverlap: chunkOverlap,
            skipEmbeddingGeneration: skipEmbeddingGeneration,
            setPageAsBoundary: setPageAsBoundary,
            embeddingModel: embeddingModel,
            generateSparseVectors: generateSparseVectors,
            useTextract: useTextract,
            prependFilenameToChunks: prependFilenameToChunks,
            maxItemsPerChunk: maxItemsPerChunk,
            parsePdfTablesWithOcr: parsePdfTablesWithOcr
        )
        return try await withCheckedThrowingContinuation { continuation in
            uploadFromUrlWithRequestBuilder(uploadFileFromUrlInput: uploadFileFromUrlInput).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }



    /**
     Create Upload File From Url
     - POST /upload_file_from_url
     - API Key:
       - type: apiKey authorization 
       - name: accessToken
     - API Key:
       - type: apiKey authorization 
       - name: apiKey
     - API Key:
       - type: apiKey customer-id 
       - name: customerId
     - parameter uploadFileFromUrlInput: (body)  
     - returns: RequestBuilder<UserFile> 
     */
    open class func uploadFromUrlWithRequestBuilder(
            uploadFileFromUrlInput: UploadFileFromUrlInput
    ) -> RequestBuilder<UserFile> {
        let basePath = CarbonAPI.basePath;
        let localVariablePath = "/upload_file_from_url"
        let localVariableURLString = basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: uploadFileFromUrlInput)

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        var localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        do {
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: CarbonAPI.accessToken, prefix: "Token ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: CarbonAPI.apiKey, prefix: "Bearer ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "customer-id", value: CarbonAPI.customerId, prefix: nil)
            let localVariableRequestBuilder: RequestBuilder<UserFile>.Type = CarbonAPI.requestBuilderFactory.getBuilder()
            let URLString = localVariableUrlComponents?.string ?? localVariableURLString
            return localVariableRequestBuilder.init(method: "POST", URLString: URLString, parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
        } catch {
            print("Error: \(error)")
        }
        fatalError("Error: Unable to send request to POST /upload_file_from_url")
    }

    /**
     Create Upload File From Url
     - POST /upload_file_from_url
     - API Key:
       - type: apiKey authorization 
       - name: accessToken
     - API Key:
       - type: apiKey authorization 
       - name: apiKey
     - API Key:
       - type: apiKey customer-id 
       - name: customerId
     - parameter uploadFileFromUrlInput: (body)  
     - returns: RequestBuilder<UserFile> 
     */
    open func uploadFromUrlWithRequestBuilder(
            uploadFileFromUrlInput: UploadFileFromUrlInput
    ) -> RequestBuilder<UserFile> {
        let basePath = self.client.basePath;
        let localVariablePath = "/upload_file_from_url"
        let localVariableURLString = basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: uploadFileFromUrlInput)

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        var localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        do {
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: self.client.accessToken, prefix: "Token ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: self.client.apiKey, prefix: "Bearer ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "customer-id", value: self.client.customerId, prefix: nil)
            let localVariableRequestBuilder: RequestBuilder<UserFile>.Type = CarbonAPI.requestBuilderFactory.getBuilder()
            let URLString = localVariableUrlComponents?.string ?? localVariableURLString
            return localVariableRequestBuilder.init(method: "POST", URLString: URLString, parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
        } catch {
            print("Error: \(error)")
        }
        fatalError("Error: Unable to send request to POST /upload_file_from_url")
    }


    /**
     Create Raw Text
     
     - parameter rawTextInput: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @discardableResult
    open class func uploadTextSync(rawTextInput: RawTextInput, apiResponseQueue: DispatchQueue = CarbonAPI.apiResponseQueue, completion: @escaping ((_ data: UserFile?, _ error: Error?) -> Void)) -> RequestTask {
        return uploadTextWithRequestBuilder(rawTextInput: rawTextInput).execute(apiResponseQueue) { result in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Create Raw Text
     
     - parameter rawTextInput: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    private class func uploadTextAsyncMappedParams(rawTextInput: RawTextInput) async throws -> UserFile {
        return try await withCheckedThrowingContinuation { continuation in
            uploadTextWithRequestBuilder(rawTextInput: rawTextInput).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }

    /**
     Create Raw Text
     
     - parameter rawTextInput: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    open class func uploadText(
        contents: String,
        name: String? = nil, 
        chunkSize: Int? = nil, 
        chunkOverlap: Int? = nil, 
        skipEmbeddingGeneration: Bool? = nil, 
        overwriteFileId: Int? = nil, 
        embeddingModel: EmbeddingGeneratorsNullable? = nil, 
        generateSparseVectors: Bool? = nil
    ) async throws -> UserFile {
        let rawTextInput = RawTextInput(
            contents: contents,
            name: name,
            chunkSize: chunkSize,
            chunkOverlap: chunkOverlap,
            skipEmbeddingGeneration: skipEmbeddingGeneration,
            overwriteFileId: overwriteFileId,
            embeddingModel: embeddingModel,
            generateSparseVectors: generateSparseVectors
        )
        return try await withCheckedThrowingContinuation { continuation in
            uploadTextWithRequestBuilder(rawTextInput: rawTextInput).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    /**
     Create Raw Text
     
     - parameter rawTextInput: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    open func uploadText(
        contents: String,
        name: String? = nil, 
        chunkSize: Int? = nil, 
        chunkOverlap: Int? = nil, 
        skipEmbeddingGeneration: Bool? = nil, 
        overwriteFileId: Int? = nil, 
        embeddingModel: EmbeddingGeneratorsNullable? = nil, 
        generateSparseVectors: Bool? = nil
    ) async throws -> UserFile {
        let rawTextInput = RawTextInput(
            contents: contents,
            name: name,
            chunkSize: chunkSize,
            chunkOverlap: chunkOverlap,
            skipEmbeddingGeneration: skipEmbeddingGeneration,
            overwriteFileId: overwriteFileId,
            embeddingModel: embeddingModel,
            generateSparseVectors: generateSparseVectors
        )
        return try await withCheckedThrowingContinuation { continuation in
            uploadTextWithRequestBuilder(rawTextInput: rawTextInput).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }



    /**
     Create Raw Text
     - POST /upload_text
     - Carbon supports multiple models for use in generating embeddings for files. For images, we support Vertex AI's multimodal model; for text, we support OpenAI's `text-embedding-ada-002` and Cohere's embed-multilingual-v3.0. The model can be specified via the `embedding_model` parameter (in the POST body for `/embeddings`, and a query  parameter in `/uploadfile`). If no model is supplied, the `text-embedding-ada-002` is used by default. When performing embedding queries, embeddings from files that used the specified model will be considered in the query. For example, if files A and B have embeddings generated with `OPENAI`, and files C and D have embeddings generated with `COHERE_MULTILINGUAL_V3`, then by default, queries will only consider files A and B. If `COHERE_MULTILINGUAL_V3` is specified as the `embedding_model` in `/embeddings`, then only files C and D will be considered. Make sure that the set of all files you want considered for a query have embeddings generated via the same model. For now, **do not** set `VERTEX_MULTIMODAL` as an `embedding_model`. This model is used automatically by Carbon when it detects an image file.
     - API Key:
       - type: apiKey authorization 
       - name: accessToken
     - API Key:
       - type: apiKey authorization 
       - name: apiKey
     - API Key:
       - type: apiKey customer-id 
       - name: customerId
     - parameter rawTextInput: (body)  
     - returns: RequestBuilder<UserFile> 
     */
    open class func uploadTextWithRequestBuilder(
            rawTextInput: RawTextInput
    ) -> RequestBuilder<UserFile> {
        let basePath = CarbonAPI.basePath;
        let localVariablePath = "/upload_text"
        let localVariableURLString = basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: rawTextInput)

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        var localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        do {
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: CarbonAPI.accessToken, prefix: "Token ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: CarbonAPI.apiKey, prefix: "Bearer ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "customer-id", value: CarbonAPI.customerId, prefix: nil)
            let localVariableRequestBuilder: RequestBuilder<UserFile>.Type = CarbonAPI.requestBuilderFactory.getBuilder()
            let URLString = localVariableUrlComponents?.string ?? localVariableURLString
            return localVariableRequestBuilder.init(method: "POST", URLString: URLString, parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
        } catch {
            print("Error: \(error)")
        }
        fatalError("Error: Unable to send request to POST /upload_text")
    }

    /**
     Create Raw Text
     - POST /upload_text
     - Carbon supports multiple models for use in generating embeddings for files. For images, we support Vertex AI's multimodal model; for text, we support OpenAI's `text-embedding-ada-002` and Cohere's embed-multilingual-v3.0. The model can be specified via the `embedding_model` parameter (in the POST body for `/embeddings`, and a query  parameter in `/uploadfile`). If no model is supplied, the `text-embedding-ada-002` is used by default. When performing embedding queries, embeddings from files that used the specified model will be considered in the query. For example, if files A and B have embeddings generated with `OPENAI`, and files C and D have embeddings generated with `COHERE_MULTILINGUAL_V3`, then by default, queries will only consider files A and B. If `COHERE_MULTILINGUAL_V3` is specified as the `embedding_model` in `/embeddings`, then only files C and D will be considered. Make sure that the set of all files you want considered for a query have embeddings generated via the same model. For now, **do not** set `VERTEX_MULTIMODAL` as an `embedding_model`. This model is used automatically by Carbon when it detects an image file.
     - API Key:
       - type: apiKey authorization 
       - name: accessToken
     - API Key:
       - type: apiKey authorization 
       - name: apiKey
     - API Key:
       - type: apiKey customer-id 
       - name: customerId
     - parameter rawTextInput: (body)  
     - returns: RequestBuilder<UserFile> 
     */
    open func uploadTextWithRequestBuilder(
            rawTextInput: RawTextInput
    ) -> RequestBuilder<UserFile> {
        let basePath = self.client.basePath;
        let localVariablePath = "/upload_text"
        let localVariableURLString = basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: rawTextInput)

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        var localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        do {
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: self.client.accessToken, prefix: "Token ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: self.client.apiKey, prefix: "Bearer ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "customer-id", value: self.client.customerId, prefix: nil)
            let localVariableRequestBuilder: RequestBuilder<UserFile>.Type = CarbonAPI.requestBuilderFactory.getBuilder()
            let URLString = localVariableUrlComponents?.string ?? localVariableURLString
            return localVariableRequestBuilder.init(method: "POST", URLString: URLString, parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
        } catch {
            print("Error: \(error)")
        }
        fatalError("Error: Unable to send request to POST /upload_text")
    }

}
