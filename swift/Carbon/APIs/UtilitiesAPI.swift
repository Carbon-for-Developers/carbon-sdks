//
// UtilitiesAPI.swift
//
// Generated by Konfig
// https://konfigthis.com
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

open class UtilitiesAPI {

    let client: CarbonClient

    public init(client: CarbonClient) {
        self.client = client
    }

    /**
     Fetch Urls
     
     - parameter url: (query)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @discardableResult
    open class func fetchUrlsSync(url: String, apiResponseQueue: DispatchQueue = CarbonAPI.apiResponseQueue, completion: @escaping ((_ data: FetchURLsResponse?, _ error: Error?) -> Void)) -> RequestTask {
        return fetchUrlsWithRequestBuilder(url: url).execute(apiResponseQueue) { result in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Fetch Urls
     
     - parameter url: (query)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    private class func fetchUrlsAsyncMappedParams(url: String) async throws -> FetchURLsResponse {
        return try await withCheckedThrowingContinuation { continuation in
            fetchUrlsWithRequestBuilder(url: url).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }

    /**
     Fetch Urls
     
     - parameter url: (query)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    open class func fetchUrls(
        url: String
    ) async throws -> FetchURLsResponse {
        return try await withCheckedThrowingContinuation { continuation in
            fetchUrlsWithRequestBuilder(url: url).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    /**
     Fetch Urls
     
     - parameter url: (query)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    open func fetchUrls(
        url: String
    ) async throws -> FetchURLsResponse {
        return try await withCheckedThrowingContinuation { continuation in
            fetchUrlsWithRequestBuilder(url: url).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }



    /**
     Fetch Urls
     - GET /fetch_urls
     - Extracts all URLs from a webpage.   Args:     url (str): URL of the webpage  Returns:     FetchURLsResponse: A response object with a list of URLs extracted from the webpage and the webpage content.
     - API Key:
       - type: apiKey authorization 
       - name: accessToken
     - API Key:
       - type: apiKey authorization 
       - name: apiKey
     - API Key:
       - type: apiKey customer-id 
       - name: customerId
     - parameter url: (query)  
     - returns: RequestBuilder<FetchURLsResponse> 
     */
    open class func fetchUrlsWithRequestBuilder(
            url: String
    ) -> RequestBuilder<FetchURLsResponse> {
        let basePath = CarbonAPI.basePath;
        let localVariablePath = "/fetch_urls"
        let localVariableURLString = basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil
        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "url": (wrappedValue: url.encodeToJSON(), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        var localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        do {
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: CarbonAPI.accessToken, prefix: "Token ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: CarbonAPI.apiKey, prefix: "Bearer ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "customer-id", value: CarbonAPI.customerId, prefix: nil)
            let localVariableRequestBuilder: RequestBuilder<FetchURLsResponse>.Type = CarbonAPI.requestBuilderFactory.getBuilder()
            let URLString = localVariableUrlComponents?.string ?? localVariableURLString
            return localVariableRequestBuilder.init(method: "GET", URLString: URLString, parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
        } catch {
            print("Error: \(error)")
        }
        fatalError("Error: Unable to send request to GET /fetch_urls")
    }

    /**
     Fetch Urls
     - GET /fetch_urls
     - Extracts all URLs from a webpage.   Args:     url (str): URL of the webpage  Returns:     FetchURLsResponse: A response object with a list of URLs extracted from the webpage and the webpage content.
     - API Key:
       - type: apiKey authorization 
       - name: accessToken
     - API Key:
       - type: apiKey authorization 
       - name: apiKey
     - API Key:
       - type: apiKey customer-id 
       - name: customerId
     - parameter url: (query)  
     - returns: RequestBuilder<FetchURLsResponse> 
     */
    open func fetchUrlsWithRequestBuilder(
            url: String
    ) -> RequestBuilder<FetchURLsResponse> {
        let basePath = self.client.basePath;
        let localVariablePath = "/fetch_urls"
        let localVariableURLString = basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil
        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "url": (wrappedValue: url.encodeToJSON(), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        var localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        do {
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: self.client.accessToken, prefix: "Token ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: self.client.apiKey, prefix: "Bearer ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "customer-id", value: self.client.customerId, prefix: nil)
            let localVariableRequestBuilder: RequestBuilder<FetchURLsResponse>.Type = CarbonAPI.requestBuilderFactory.getBuilder()
            let URLString = localVariableUrlComponents?.string ?? localVariableURLString
            return localVariableRequestBuilder.init(method: "GET", URLString: URLString, parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
        } catch {
            print("Error: \(error)")
        }
        fatalError("Error: Unable to send request to GET /fetch_urls")
    }


    /**
     Fetch Youtube Transcripts
     
     - parameter id: (query)  
     - parameter raw: (query)  (optional, default to false)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @discardableResult
    open class func fetchYoutubeTranscriptsSync(id: String, raw: Bool? = nil, apiResponseQueue: DispatchQueue = CarbonAPI.apiResponseQueue, completion: @escaping ((_ data: YoutubeTranscriptResponse?, _ error: Error?) -> Void)) -> RequestTask {
        return fetchYoutubeTranscriptsWithRequestBuilder(id: id, raw: raw).execute(apiResponseQueue) { result in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Fetch Youtube Transcripts
     
     - parameter id: (query)  
     - parameter raw: (query)  (optional, default to false)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    private class func fetchYoutubeTranscriptsAsyncMappedParams(id: String, raw: Bool? = nil) async throws -> YoutubeTranscriptResponse {
        return try await withCheckedThrowingContinuation { continuation in
            fetchYoutubeTranscriptsWithRequestBuilder(id: id, raw: raw).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }

    /**
     Fetch Youtube Transcripts
     
     - parameter id: (query)  
     - parameter raw: (query)  (optional, default to false)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    open class func fetchYoutubeTranscripts(
        id: String,
        raw: Bool? = nil
    ) async throws -> YoutubeTranscriptResponse {
        return try await withCheckedThrowingContinuation { continuation in
            fetchYoutubeTranscriptsWithRequestBuilder(id: id, raw: raw).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    /**
     Fetch Youtube Transcripts
     
     - parameter id: (query)  
     - parameter raw: (query)  (optional, default to false)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    open func fetchYoutubeTranscripts(
        id: String,
        raw: Bool? = nil
    ) async throws -> YoutubeTranscriptResponse {
        return try await withCheckedThrowingContinuation { continuation in
            fetchYoutubeTranscriptsWithRequestBuilder(id: id, raw: raw).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }



    /**
     Fetch Youtube Transcripts
     - GET /fetch_youtube_transcript
     - Fetches english transcripts from YouTube videos.  Args:     id (str): The ID of the YouTube video.      raw (bool): Whether to return the raw transcript or not. Defaults to False.  Returns:     dict: A dictionary with the transcript of the YouTube video.
     - API Key:
       - type: apiKey authorization 
       - name: accessToken
     - API Key:
       - type: apiKey authorization 
       - name: apiKey
     - API Key:
       - type: apiKey customer-id 
       - name: customerId
     - parameter id: (query)  
     - parameter raw: (query)  (optional, default to false)
     - returns: RequestBuilder<YoutubeTranscriptResponse> 
     */
    open class func fetchYoutubeTranscriptsWithRequestBuilder(
            id: String,
            raw: Bool? = nil
    ) -> RequestBuilder<YoutubeTranscriptResponse> {
        let basePath = CarbonAPI.basePath;
        let localVariablePath = "/fetch_youtube_transcript"
        let localVariableURLString = basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil
        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "id": (wrappedValue: id.encodeToJSON(), isExplode: true),
            "raw": (wrappedValue: raw?.encodeToJSON(), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        var localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        do {
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: CarbonAPI.accessToken, prefix: "Token ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: CarbonAPI.apiKey, prefix: "Bearer ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "customer-id", value: CarbonAPI.customerId, prefix: nil)
            let localVariableRequestBuilder: RequestBuilder<YoutubeTranscriptResponse>.Type = CarbonAPI.requestBuilderFactory.getBuilder()
            let URLString = localVariableUrlComponents?.string ?? localVariableURLString
            return localVariableRequestBuilder.init(method: "GET", URLString: URLString, parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
        } catch {
            print("Error: \(error)")
        }
        fatalError("Error: Unable to send request to GET /fetch_youtube_transcript")
    }

    /**
     Fetch Youtube Transcripts
     - GET /fetch_youtube_transcript
     - Fetches english transcripts from YouTube videos.  Args:     id (str): The ID of the YouTube video.      raw (bool): Whether to return the raw transcript or not. Defaults to False.  Returns:     dict: A dictionary with the transcript of the YouTube video.
     - API Key:
       - type: apiKey authorization 
       - name: accessToken
     - API Key:
       - type: apiKey authorization 
       - name: apiKey
     - API Key:
       - type: apiKey customer-id 
       - name: customerId
     - parameter id: (query)  
     - parameter raw: (query)  (optional, default to false)
     - returns: RequestBuilder<YoutubeTranscriptResponse> 
     */
    open func fetchYoutubeTranscriptsWithRequestBuilder(
            id: String,
            raw: Bool? = nil
    ) -> RequestBuilder<YoutubeTranscriptResponse> {
        let basePath = self.client.basePath;
        let localVariablePath = "/fetch_youtube_transcript"
        let localVariableURLString = basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil
        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "id": (wrappedValue: id.encodeToJSON(), isExplode: true),
            "raw": (wrappedValue: raw?.encodeToJSON(), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        var localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        do {
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: self.client.accessToken, prefix: "Token ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: self.client.apiKey, prefix: "Bearer ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "customer-id", value: self.client.customerId, prefix: nil)
            let localVariableRequestBuilder: RequestBuilder<YoutubeTranscriptResponse>.Type = CarbonAPI.requestBuilderFactory.getBuilder()
            let URLString = localVariableUrlComponents?.string ?? localVariableURLString
            return localVariableRequestBuilder.init(method: "GET", URLString: URLString, parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
        } catch {
            print("Error: \(error)")
        }
        fatalError("Error: Unable to send request to GET /fetch_youtube_transcript")
    }


    /**
     Sitemap
     
     - parameter url: (query)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @discardableResult
    open class func processSitemapSync(url: String, apiResponseQueue: DispatchQueue = CarbonAPI.apiResponseQueue, completion: @escaping ((_ data: AnyCodable?, _ error: Error?) -> Void)) -> RequestTask {
        return processSitemapWithRequestBuilder(url: url).execute(apiResponseQueue) { result in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Sitemap
     
     - parameter url: (query)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    private class func processSitemapAsyncMappedParams(url: String) async throws -> AnyCodable {
        return try await withCheckedThrowingContinuation { continuation in
            processSitemapWithRequestBuilder(url: url).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }

    /**
     Sitemap
     
     - parameter url: (query)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    open class func processSitemap(
        url: String
    ) async throws -> AnyCodable {
        return try await withCheckedThrowingContinuation { continuation in
            processSitemapWithRequestBuilder(url: url).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    /**
     Sitemap
     
     - parameter url: (query)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    open func processSitemap(
        url: String
    ) async throws -> AnyCodable {
        return try await withCheckedThrowingContinuation { continuation in
            processSitemapWithRequestBuilder(url: url).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }



    /**
     Sitemap
     - GET /process_sitemap
     - Retrieves all URLs from a sitemap, which can subsequently be utilized with our `web_scrape` endpoint.  <!--Args:     url (str): URL of the sitemap  Returns:     dict: A dictionary with a list of URLs extracted from the sitemap.-->
     - API Key:
       - type: apiKey authorization 
       - name: accessToken
     - API Key:
       - type: apiKey authorization 
       - name: apiKey
     - API Key:
       - type: apiKey customer-id 
       - name: customerId
     - parameter url: (query)  
     - returns: RequestBuilder<AnyCodable> 
     */
    open class func processSitemapWithRequestBuilder(
            url: String
    ) -> RequestBuilder<AnyCodable> {
        let basePath = CarbonAPI.basePath;
        let localVariablePath = "/process_sitemap"
        let localVariableURLString = basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil
        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "url": (wrappedValue: url.encodeToJSON(), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        var localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        do {
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: CarbonAPI.accessToken, prefix: "Token ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: CarbonAPI.apiKey, prefix: "Bearer ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "customer-id", value: CarbonAPI.customerId, prefix: nil)
            let localVariableRequestBuilder: RequestBuilder<AnyCodable>.Type = CarbonAPI.requestBuilderFactory.getBuilder()
            let URLString = localVariableUrlComponents?.string ?? localVariableURLString
            return localVariableRequestBuilder.init(method: "GET", URLString: URLString, parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
        } catch {
            print("Error: \(error)")
        }
        fatalError("Error: Unable to send request to GET /process_sitemap")
    }

    /**
     Sitemap
     - GET /process_sitemap
     - Retrieves all URLs from a sitemap, which can subsequently be utilized with our `web_scrape` endpoint.  <!--Args:     url (str): URL of the sitemap  Returns:     dict: A dictionary with a list of URLs extracted from the sitemap.-->
     - API Key:
       - type: apiKey authorization 
       - name: accessToken
     - API Key:
       - type: apiKey authorization 
       - name: apiKey
     - API Key:
       - type: apiKey customer-id 
       - name: customerId
     - parameter url: (query)  
     - returns: RequestBuilder<AnyCodable> 
     */
    open func processSitemapWithRequestBuilder(
            url: String
    ) -> RequestBuilder<AnyCodable> {
        let basePath = self.client.basePath;
        let localVariablePath = "/process_sitemap"
        let localVariableURLString = basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil
        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "url": (wrappedValue: url.encodeToJSON(), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        var localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        do {
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: self.client.accessToken, prefix: "Token ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: self.client.apiKey, prefix: "Bearer ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "customer-id", value: self.client.customerId, prefix: nil)
            let localVariableRequestBuilder: RequestBuilder<AnyCodable>.Type = CarbonAPI.requestBuilderFactory.getBuilder()
            let URLString = localVariableUrlComponents?.string ?? localVariableURLString
            return localVariableRequestBuilder.init(method: "GET", URLString: URLString, parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
        } catch {
            print("Error: \(error)")
        }
        fatalError("Error: Unable to send request to GET /process_sitemap")
    }


    /**
     Scrape Sitemap
     
     - parameter sitemapScrapeRequest: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @discardableResult
    open class func scrapeSitemapSync(sitemapScrapeRequest: SitemapScrapeRequest, apiResponseQueue: DispatchQueue = CarbonAPI.apiResponseQueue, completion: @escaping ((_ data: AnyCodable?, _ error: Error?) -> Void)) -> RequestTask {
        return scrapeSitemapWithRequestBuilder(sitemapScrapeRequest: sitemapScrapeRequest).execute(apiResponseQueue) { result in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Scrape Sitemap
     
     - parameter sitemapScrapeRequest: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    private class func scrapeSitemapAsyncMappedParams(sitemapScrapeRequest: SitemapScrapeRequest) async throws -> AnyCodable {
        return try await withCheckedThrowingContinuation { continuation in
            scrapeSitemapWithRequestBuilder(sitemapScrapeRequest: sitemapScrapeRequest).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }

    /**
     Scrape Sitemap
     
     - parameter sitemapScrapeRequest: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    open class func scrapeSitemap(
        url: String,
        tags: [String: Tags1]? = nil, 
        maxPagesToScrape: Int? = nil, 
        chunkSize: Int? = nil, 
        chunkOverlap: Int? = nil, 
        skipEmbeddingGeneration: Bool? = nil, 
        enableAutoSync: Bool? = nil, 
        generateSparseVectors: Bool? = nil, 
        prependFilenameToChunks: Bool? = nil, 
        htmlTagsToSkip: [String]? = nil, 
        cssClassesToSkip: [String]? = nil, 
        cssSelectorsToSkip: [String]? = nil, 
        embeddingModel: EmbeddingGenerators? = nil
    ) async throws -> AnyCodable {
        let sitemapScrapeRequest = SitemapScrapeRequest(
            tags: tags,
            url: url,
            maxPagesToScrape: maxPagesToScrape,
            chunkSize: chunkSize,
            chunkOverlap: chunkOverlap,
            skipEmbeddingGeneration: skipEmbeddingGeneration,
            enableAutoSync: enableAutoSync,
            generateSparseVectors: generateSparseVectors,
            prependFilenameToChunks: prependFilenameToChunks,
            htmlTagsToSkip: htmlTagsToSkip,
            cssClassesToSkip: cssClassesToSkip,
            cssSelectorsToSkip: cssSelectorsToSkip,
            embeddingModel: embeddingModel
        )
        return try await withCheckedThrowingContinuation { continuation in
            scrapeSitemapWithRequestBuilder(sitemapScrapeRequest: sitemapScrapeRequest).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    /**
     Scrape Sitemap
     
     - parameter sitemapScrapeRequest: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    open func scrapeSitemap(
        url: String,
        tags: [String: Tags1]? = nil, 
        maxPagesToScrape: Int? = nil, 
        chunkSize: Int? = nil, 
        chunkOverlap: Int? = nil, 
        skipEmbeddingGeneration: Bool? = nil, 
        enableAutoSync: Bool? = nil, 
        generateSparseVectors: Bool? = nil, 
        prependFilenameToChunks: Bool? = nil, 
        htmlTagsToSkip: [String]? = nil, 
        cssClassesToSkip: [String]? = nil, 
        cssSelectorsToSkip: [String]? = nil, 
        embeddingModel: EmbeddingGenerators? = nil
    ) async throws -> AnyCodable {
        let sitemapScrapeRequest = SitemapScrapeRequest(
            tags: tags,
            url: url,
            maxPagesToScrape: maxPagesToScrape,
            chunkSize: chunkSize,
            chunkOverlap: chunkOverlap,
            skipEmbeddingGeneration: skipEmbeddingGeneration,
            enableAutoSync: enableAutoSync,
            generateSparseVectors: generateSparseVectors,
            prependFilenameToChunks: prependFilenameToChunks,
            htmlTagsToSkip: htmlTagsToSkip,
            cssClassesToSkip: cssClassesToSkip,
            cssSelectorsToSkip: cssSelectorsToSkip,
            embeddingModel: embeddingModel
        )
        return try await withCheckedThrowingContinuation { continuation in
            scrapeSitemapWithRequestBuilder(sitemapScrapeRequest: sitemapScrapeRequest).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }



    /**
     Scrape Sitemap
     - POST /scrape_sitemap
     - Extracts all URLs from a sitemap and performs a web scrape on each of them.  Args:     sitemap_url (str): URL of the sitemap  Returns:     dict: A response object with the status of the scraping job message.-->
     - API Key:
       - type: apiKey authorization 
       - name: accessToken
     - API Key:
       - type: apiKey authorization 
       - name: apiKey
     - API Key:
       - type: apiKey customer-id 
       - name: customerId
     - parameter sitemapScrapeRequest: (body)  
     - returns: RequestBuilder<AnyCodable> 
     */
    open class func scrapeSitemapWithRequestBuilder(
            sitemapScrapeRequest: SitemapScrapeRequest
    ) -> RequestBuilder<AnyCodable> {
        let basePath = CarbonAPI.basePath;
        let localVariablePath = "/scrape_sitemap"
        let localVariableURLString = basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: sitemapScrapeRequest)

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        var localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        do {
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: CarbonAPI.accessToken, prefix: "Token ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: CarbonAPI.apiKey, prefix: "Bearer ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "customer-id", value: CarbonAPI.customerId, prefix: nil)
            let localVariableRequestBuilder: RequestBuilder<AnyCodable>.Type = CarbonAPI.requestBuilderFactory.getBuilder()
            let URLString = localVariableUrlComponents?.string ?? localVariableURLString
            return localVariableRequestBuilder.init(method: "POST", URLString: URLString, parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
        } catch {
            print("Error: \(error)")
        }
        fatalError("Error: Unable to send request to POST /scrape_sitemap")
    }

    /**
     Scrape Sitemap
     - POST /scrape_sitemap
     - Extracts all URLs from a sitemap and performs a web scrape on each of them.  Args:     sitemap_url (str): URL of the sitemap  Returns:     dict: A response object with the status of the scraping job message.-->
     - API Key:
       - type: apiKey authorization 
       - name: accessToken
     - API Key:
       - type: apiKey authorization 
       - name: apiKey
     - API Key:
       - type: apiKey customer-id 
       - name: customerId
     - parameter sitemapScrapeRequest: (body)  
     - returns: RequestBuilder<AnyCodable> 
     */
    open func scrapeSitemapWithRequestBuilder(
            sitemapScrapeRequest: SitemapScrapeRequest
    ) -> RequestBuilder<AnyCodable> {
        let basePath = self.client.basePath;
        let localVariablePath = "/scrape_sitemap"
        let localVariableURLString = basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: sitemapScrapeRequest)

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        var localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        do {
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: self.client.accessToken, prefix: "Token ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: self.client.apiKey, prefix: "Bearer ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "customer-id", value: self.client.customerId, prefix: nil)
            let localVariableRequestBuilder: RequestBuilder<AnyCodable>.Type = CarbonAPI.requestBuilderFactory.getBuilder()
            let URLString = localVariableUrlComponents?.string ?? localVariableURLString
            return localVariableRequestBuilder.init(method: "POST", URLString: URLString, parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
        } catch {
            print("Error: \(error)")
        }
        fatalError("Error: Unable to send request to POST /scrape_sitemap")
    }


    /**
     Web Scrape
     
     - parameter webscrapeRequest: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @discardableResult
    open class func scrapeWebSync(webscrapeRequest: [WebscrapeRequest], apiResponseQueue: DispatchQueue = CarbonAPI.apiResponseQueue, completion: @escaping ((_ data: AnyCodable?, _ error: Error?) -> Void)) -> RequestTask {
        return scrapeWebWithRequestBuilder(webscrapeRequest: webscrapeRequest).execute(apiResponseQueue) { result in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Web Scrape
     
     - parameter webscrapeRequest: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    private class func scrapeWebAsyncMappedParams(webscrapeRequest: [WebscrapeRequest]) async throws -> AnyCodable {
        return try await withCheckedThrowingContinuation { continuation in
            scrapeWebWithRequestBuilder(webscrapeRequest: webscrapeRequest).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }

    /**
     Web Scrape
     
     - parameter webscrapeRequest: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    open class func scrapeWeb(
    ) async throws -> AnyCodable {
        let webscrapeRequest = [WebscrapeRequest](
        )
        return try await withCheckedThrowingContinuation { continuation in
            scrapeWebWithRequestBuilder(webscrapeRequest: webscrapeRequest).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    /**
     Web Scrape
     
     - parameter webscrapeRequest: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    open func scrapeWeb(
    ) async throws -> AnyCodable {
        let webscrapeRequest = [WebscrapeRequest](
        )
        return try await withCheckedThrowingContinuation { continuation in
            scrapeWebWithRequestBuilder(webscrapeRequest: webscrapeRequest).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }



    /**
     Web Scrape
     - POST /web_scrape
     - Conduct a web scrape on a given webpage URL. Our web scraper is fully compatible with JavaScript and supports recursion depth, enabling you to efficiently extract all content from the target website.  <!--Args:     scraping_requests (List[WebscrapeRequest]): A list of WebscrapeRequest objects.       Returns:     dict: A response object with the status of the scraping job message.-->
     - API Key:
       - type: apiKey authorization 
       - name: accessToken
     - API Key:
       - type: apiKey authorization 
       - name: apiKey
     - API Key:
       - type: apiKey customer-id 
       - name: customerId
     - parameter webscrapeRequest: (body)  
     - returns: RequestBuilder<AnyCodable> 
     */
    open class func scrapeWebWithRequestBuilder(
            webscrapeRequest: [WebscrapeRequest]
    ) -> RequestBuilder<AnyCodable> {
        let basePath = CarbonAPI.basePath;
        let localVariablePath = "/web_scrape"
        let localVariableURLString = basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: webscrapeRequest)

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        var localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        do {
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: CarbonAPI.accessToken, prefix: "Token ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: CarbonAPI.apiKey, prefix: "Bearer ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "customer-id", value: CarbonAPI.customerId, prefix: nil)
            let localVariableRequestBuilder: RequestBuilder<AnyCodable>.Type = CarbonAPI.requestBuilderFactory.getBuilder()
            let URLString = localVariableUrlComponents?.string ?? localVariableURLString
            return localVariableRequestBuilder.init(method: "POST", URLString: URLString, parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
        } catch {
            print("Error: \(error)")
        }
        fatalError("Error: Unable to send request to POST /web_scrape")
    }

    /**
     Web Scrape
     - POST /web_scrape
     - Conduct a web scrape on a given webpage URL. Our web scraper is fully compatible with JavaScript and supports recursion depth, enabling you to efficiently extract all content from the target website.  <!--Args:     scraping_requests (List[WebscrapeRequest]): A list of WebscrapeRequest objects.       Returns:     dict: A response object with the status of the scraping job message.-->
     - API Key:
       - type: apiKey authorization 
       - name: accessToken
     - API Key:
       - type: apiKey authorization 
       - name: apiKey
     - API Key:
       - type: apiKey customer-id 
       - name: customerId
     - parameter webscrapeRequest: (body)  
     - returns: RequestBuilder<AnyCodable> 
     */
    open func scrapeWebWithRequestBuilder(
            webscrapeRequest: [WebscrapeRequest]
    ) -> RequestBuilder<AnyCodable> {
        let basePath = self.client.basePath;
        let localVariablePath = "/web_scrape"
        let localVariableURLString = basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: webscrapeRequest)

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        var localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        do {
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: self.client.accessToken, prefix: "Token ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: self.client.apiKey, prefix: "Bearer ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "customer-id", value: self.client.customerId, prefix: nil)
            let localVariableRequestBuilder: RequestBuilder<AnyCodable>.Type = CarbonAPI.requestBuilderFactory.getBuilder()
            let URLString = localVariableUrlComponents?.string ?? localVariableURLString
            return localVariableRequestBuilder.init(method: "POST", URLString: URLString, parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
        } catch {
            print("Error: \(error)")
        }
        fatalError("Error: Unable to send request to POST /web_scrape")
    }


    /**
     Search Urls
     
     - parameter query: (query)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @discardableResult
    open class func searchUrlsSync(query: String, apiResponseQueue: DispatchQueue = CarbonAPI.apiResponseQueue, completion: @escaping ((_ data: FetchURLsResponse?, _ error: Error?) -> Void)) -> RequestTask {
        return searchUrlsWithRequestBuilder(query: query).execute(apiResponseQueue) { result in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Search Urls
     
     - parameter query: (query)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    private class func searchUrlsAsyncMappedParams(query: String) async throws -> FetchURLsResponse {
        return try await withCheckedThrowingContinuation { continuation in
            searchUrlsWithRequestBuilder(query: query).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }

    /**
     Search Urls
     
     - parameter query: (query)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    open class func searchUrls(
        query: String
    ) async throws -> FetchURLsResponse {
        return try await withCheckedThrowingContinuation { continuation in
            searchUrlsWithRequestBuilder(query: query).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    /**
     Search Urls
     
     - parameter query: (query)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    open func searchUrls(
        query: String
    ) async throws -> FetchURLsResponse {
        return try await withCheckedThrowingContinuation { continuation in
            searchUrlsWithRequestBuilder(query: query).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }



    /**
     Search Urls
     - GET /search_urls
     - Perform a web search and obtain a list of relevant URLs.  As an illustration, when you perform a search for “content related to MRNA,” you will receive a list of links such as the following:      - https://tomrenz.substack.com/p/mrna-and-why-it-matters      - https://www.statnews.com/2020/11/10/the-story-of-mrna-how-a-once-dismissed-idea-became-a-leading-technology-in-the-covid-vaccine-race/      - https://www.statnews.com/2022/11/16/covid-19-vaccines-were-a-success-but-mrna-still-has-a-delivery-problem/          - https://joomi.substack.com/p/were-still-being-misled-about-how  Subsequently, you can submit these links to the web_scrape endpoint in order to retrieve the content of the respective web pages.  Args:     query (str): Query to search for  Returns:     FetchURLsResponse: A response object with a list of URLs for a given search query.
     - API Key:
       - type: apiKey authorization 
       - name: accessToken
     - API Key:
       - type: apiKey authorization 
       - name: apiKey
     - API Key:
       - type: apiKey customer-id 
       - name: customerId
     - parameter query: (query)  
     - returns: RequestBuilder<FetchURLsResponse> 
     */
    open class func searchUrlsWithRequestBuilder(
            query: String
    ) -> RequestBuilder<FetchURLsResponse> {
        let basePath = CarbonAPI.basePath;
        let localVariablePath = "/search_urls"
        let localVariableURLString = basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil
        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "query": (wrappedValue: query.encodeToJSON(), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        var localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        do {
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: CarbonAPI.accessToken, prefix: "Token ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: CarbonAPI.apiKey, prefix: "Bearer ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "customer-id", value: CarbonAPI.customerId, prefix: nil)
            let localVariableRequestBuilder: RequestBuilder<FetchURLsResponse>.Type = CarbonAPI.requestBuilderFactory.getBuilder()
            let URLString = localVariableUrlComponents?.string ?? localVariableURLString
            return localVariableRequestBuilder.init(method: "GET", URLString: URLString, parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
        } catch {
            print("Error: \(error)")
        }
        fatalError("Error: Unable to send request to GET /search_urls")
    }

    /**
     Search Urls
     - GET /search_urls
     - Perform a web search and obtain a list of relevant URLs.  As an illustration, when you perform a search for “content related to MRNA,” you will receive a list of links such as the following:      - https://tomrenz.substack.com/p/mrna-and-why-it-matters      - https://www.statnews.com/2020/11/10/the-story-of-mrna-how-a-once-dismissed-idea-became-a-leading-technology-in-the-covid-vaccine-race/      - https://www.statnews.com/2022/11/16/covid-19-vaccines-were-a-success-but-mrna-still-has-a-delivery-problem/          - https://joomi.substack.com/p/were-still-being-misled-about-how  Subsequently, you can submit these links to the web_scrape endpoint in order to retrieve the content of the respective web pages.  Args:     query (str): Query to search for  Returns:     FetchURLsResponse: A response object with a list of URLs for a given search query.
     - API Key:
       - type: apiKey authorization 
       - name: accessToken
     - API Key:
       - type: apiKey authorization 
       - name: apiKey
     - API Key:
       - type: apiKey customer-id 
       - name: customerId
     - parameter query: (query)  
     - returns: RequestBuilder<FetchURLsResponse> 
     */
    open func searchUrlsWithRequestBuilder(
            query: String
    ) -> RequestBuilder<FetchURLsResponse> {
        let basePath = self.client.basePath;
        let localVariablePath = "/search_urls"
        let localVariableURLString = basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil
        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "query": (wrappedValue: query.encodeToJSON(), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        var localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        do {
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: self.client.accessToken, prefix: "Token ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: self.client.apiKey, prefix: "Bearer ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "customer-id", value: self.client.customerId, prefix: nil)
            let localVariableRequestBuilder: RequestBuilder<FetchURLsResponse>.Type = CarbonAPI.requestBuilderFactory.getBuilder()
            let URLString = localVariableUrlComponents?.string ?? localVariableURLString
            return localVariableRequestBuilder.init(method: "GET", URLString: URLString, parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
        } catch {
            print("Error: \(error)")
        }
        fatalError("Error: Unable to send request to GET /search_urls")
    }

}
