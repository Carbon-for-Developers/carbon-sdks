//
// IntegrationsAPI.swift
//
// Generated by Konfig
// https://konfigthis.com
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

open class IntegrationsAPI {

    let client: CarbonClient

    public init(client: CarbonClient) {
        self.client = client
    }

    /**
     Connect Data Source
     
     - parameter connectDataSourceInput: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @discardableResult
    open class func connectDataSourceSync(connectDataSourceInput: ConnectDataSourceInput, apiResponseQueue: DispatchQueue = CarbonAPI.apiResponseQueue, completion: @escaping ((_ data: ConnectDataSourceResponse?, _ error: Error?) -> Void)) -> RequestTask {
        return connectDataSourceWithRequestBuilder(connectDataSourceInput: connectDataSourceInput).execute(apiResponseQueue) { result in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Connect Data Source
     
     - parameter connectDataSourceInput: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    private class func connectDataSourceAsyncMappedParams(connectDataSourceInput: ConnectDataSourceInput) async throws -> ConnectDataSourceResponse {
        return try await withCheckedThrowingContinuation { continuation in
            connectDataSourceWithRequestBuilder(connectDataSourceInput: connectDataSourceInput).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }

    /**
     Connect Data Source
     
     - parameter connectDataSourceInput: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    open class func connectDataSource(
        authentication: AuthenticationProperty,
        syncOptions: SyncOptions? = nil
    ) async throws -> ConnectDataSourceResponse {
        let connectDataSourceInput = ConnectDataSourceInput(
            authentication: authentication,
            syncOptions: syncOptions
        )
        return try await withCheckedThrowingContinuation { continuation in
            connectDataSourceWithRequestBuilder(connectDataSourceInput: connectDataSourceInput).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    /**
     Connect Data Source
     
     - parameter connectDataSourceInput: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    open func connectDataSource(
        authentication: AuthenticationProperty,
        syncOptions: SyncOptions? = nil
    ) async throws -> ConnectDataSourceResponse {
        let connectDataSourceInput = ConnectDataSourceInput(
            authentication: authentication,
            syncOptions: syncOptions
        )
        return try await withCheckedThrowingContinuation { continuation in
            connectDataSourceWithRequestBuilder(connectDataSourceInput: connectDataSourceInput).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }



    /**
     Connect Data Source
     - POST /integrations/connect
     - API Key:
       - type: apiKey authorization 
       - name: accessToken
     - API Key:
       - type: apiKey authorization 
       - name: apiKey
     - API Key:
       - type: apiKey customer-id 
       - name: customerId
     - parameter connectDataSourceInput: (body)  
     - returns: RequestBuilder<ConnectDataSourceResponse> 
     */
    open class func connectDataSourceWithRequestBuilder(
            connectDataSourceInput: ConnectDataSourceInput
    ) -> RequestBuilder<ConnectDataSourceResponse> {
        let basePath = CarbonAPI.basePath;
        let localVariablePath = "/integrations/connect"
        let localVariableURLString = basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: connectDataSourceInput)

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        var localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        do {
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: CarbonAPI.accessToken, prefix: "Token ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: CarbonAPI.apiKey, prefix: "Bearer ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "customer-id", value: CarbonAPI.customerId, prefix: nil)
            let localVariableRequestBuilder: RequestBuilder<ConnectDataSourceResponse>.Type = CarbonAPI.requestBuilderFactory.getBuilder()
            let URLString = localVariableUrlComponents?.string ?? localVariableURLString
            return localVariableRequestBuilder.init(method: "POST", URLString: URLString, parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
        } catch {
            print("Error: \(error)")
        }
        fatalError("Error: Unable to send request to POST /integrations/connect")
    }

    /**
     Connect Data Source
     - POST /integrations/connect
     - API Key:
       - type: apiKey authorization 
       - name: accessToken
     - API Key:
       - type: apiKey authorization 
       - name: apiKey
     - API Key:
       - type: apiKey customer-id 
       - name: customerId
     - parameter connectDataSourceInput: (body)  
     - returns: RequestBuilder<ConnectDataSourceResponse> 
     */
    open func connectDataSourceWithRequestBuilder(
            connectDataSourceInput: ConnectDataSourceInput
    ) -> RequestBuilder<ConnectDataSourceResponse> {
        let basePath = self.client.basePath;
        let localVariablePath = "/integrations/connect"
        let localVariableURLString = basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: connectDataSourceInput)

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        var localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        do {
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: self.client.accessToken, prefix: "Token ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: self.client.apiKey, prefix: "Bearer ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "customer-id", value: self.client.customerId, prefix: nil)
            let localVariableRequestBuilder: RequestBuilder<ConnectDataSourceResponse>.Type = CarbonAPI.requestBuilderFactory.getBuilder()
            let URLString = localVariableUrlComponents?.string ?? localVariableURLString
            return localVariableRequestBuilder.init(method: "POST", URLString: URLString, parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
        } catch {
            print("Error: \(error)")
        }
        fatalError("Error: Unable to send request to POST /integrations/connect")
    }


    /**
     Freshdesk Connect
     
     - parameter freshDeskConnectRequest: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @discardableResult
    open class func connectFreshdeskSync(freshDeskConnectRequest: FreshDeskConnectRequest, apiResponseQueue: DispatchQueue = CarbonAPI.apiResponseQueue, completion: @escaping ((_ data: GenericSuccessResponse?, _ error: Error?) -> Void)) -> RequestTask {
        return connectFreshdeskWithRequestBuilder(freshDeskConnectRequest: freshDeskConnectRequest).execute(apiResponseQueue) { result in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Freshdesk Connect
     
     - parameter freshDeskConnectRequest: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    private class func connectFreshdeskAsyncMappedParams(freshDeskConnectRequest: FreshDeskConnectRequest) async throws -> GenericSuccessResponse {
        return try await withCheckedThrowingContinuation { continuation in
            connectFreshdeskWithRequestBuilder(freshDeskConnectRequest: freshDeskConnectRequest).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }

    /**
     Freshdesk Connect
     
     - parameter freshDeskConnectRequest: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    open class func connectFreshdesk(
        domain: String,
        apiKey: String,
        tags: AnyCodable? = nil, 
        chunkSize: Int? = nil, 
        chunkOverlap: Int? = nil, 
        skipEmbeddingGeneration: Bool? = nil, 
        embeddingModel: EmbeddingGeneratorsNullable? = nil, 
        generateSparseVectors: Bool? = nil, 
        prependFilenameToChunks: Bool? = nil, 
        syncFilesOnConnection: Bool? = nil, 
        requestId: String? = nil
    ) async throws -> GenericSuccessResponse {
        let freshDeskConnectRequest = FreshDeskConnectRequest(
            tags: tags,
            domain: domain,
            apiKey: apiKey,
            chunkSize: chunkSize,
            chunkOverlap: chunkOverlap,
            skipEmbeddingGeneration: skipEmbeddingGeneration,
            embeddingModel: embeddingModel,
            generateSparseVectors: generateSparseVectors,
            prependFilenameToChunks: prependFilenameToChunks,
            syncFilesOnConnection: syncFilesOnConnection,
            requestId: requestId
        )
        return try await withCheckedThrowingContinuation { continuation in
            connectFreshdeskWithRequestBuilder(freshDeskConnectRequest: freshDeskConnectRequest).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    /**
     Freshdesk Connect
     
     - parameter freshDeskConnectRequest: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    open func connectFreshdesk(
        domain: String,
        apiKey: String,
        tags: AnyCodable? = nil, 
        chunkSize: Int? = nil, 
        chunkOverlap: Int? = nil, 
        skipEmbeddingGeneration: Bool? = nil, 
        embeddingModel: EmbeddingGeneratorsNullable? = nil, 
        generateSparseVectors: Bool? = nil, 
        prependFilenameToChunks: Bool? = nil, 
        syncFilesOnConnection: Bool? = nil, 
        requestId: String? = nil
    ) async throws -> GenericSuccessResponse {
        let freshDeskConnectRequest = FreshDeskConnectRequest(
            tags: tags,
            domain: domain,
            apiKey: apiKey,
            chunkSize: chunkSize,
            chunkOverlap: chunkOverlap,
            skipEmbeddingGeneration: skipEmbeddingGeneration,
            embeddingModel: embeddingModel,
            generateSparseVectors: generateSparseVectors,
            prependFilenameToChunks: prependFilenameToChunks,
            syncFilesOnConnection: syncFilesOnConnection,
            requestId: requestId
        )
        return try await withCheckedThrowingContinuation { continuation in
            connectFreshdeskWithRequestBuilder(freshDeskConnectRequest: freshDeskConnectRequest).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }



    /**
     Freshdesk Connect
     - POST /integrations/freshdesk
     - Refer this article to obtain an API key https://support.freshdesk.com/en/support/solutions/articles/215517. Make sure that your API key has the permission to read solutions from your account and you are on a <b>paid</b> plan. Once you have an API key, you can make a request to this endpoint along with your freshdesk domain. This will  trigger an automatic sync of the articles in your \"solutions\" tab. Additional parameters below can be used to associate  data with the synced articles or modify the sync behavior.
     - API Key:
       - type: apiKey authorization 
       - name: accessToken
     - API Key:
       - type: apiKey authorization 
       - name: apiKey
     - API Key:
       - type: apiKey customer-id 
       - name: customerId
     - parameter freshDeskConnectRequest: (body)  
     - returns: RequestBuilder<GenericSuccessResponse> 
     */
    open class func connectFreshdeskWithRequestBuilder(
            freshDeskConnectRequest: FreshDeskConnectRequest
    ) -> RequestBuilder<GenericSuccessResponse> {
        let basePath = CarbonAPI.basePath;
        let localVariablePath = "/integrations/freshdesk"
        let localVariableURLString = basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: freshDeskConnectRequest)

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        var localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        do {
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: CarbonAPI.accessToken, prefix: "Token ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: CarbonAPI.apiKey, prefix: "Bearer ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "customer-id", value: CarbonAPI.customerId, prefix: nil)
            let localVariableRequestBuilder: RequestBuilder<GenericSuccessResponse>.Type = CarbonAPI.requestBuilderFactory.getBuilder()
            let URLString = localVariableUrlComponents?.string ?? localVariableURLString
            return localVariableRequestBuilder.init(method: "POST", URLString: URLString, parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
        } catch {
            print("Error: \(error)")
        }
        fatalError("Error: Unable to send request to POST /integrations/freshdesk")
    }

    /**
     Freshdesk Connect
     - POST /integrations/freshdesk
     - Refer this article to obtain an API key https://support.freshdesk.com/en/support/solutions/articles/215517. Make sure that your API key has the permission to read solutions from your account and you are on a <b>paid</b> plan. Once you have an API key, you can make a request to this endpoint along with your freshdesk domain. This will  trigger an automatic sync of the articles in your \"solutions\" tab. Additional parameters below can be used to associate  data with the synced articles or modify the sync behavior.
     - API Key:
       - type: apiKey authorization 
       - name: accessToken
     - API Key:
       - type: apiKey authorization 
       - name: apiKey
     - API Key:
       - type: apiKey customer-id 
       - name: customerId
     - parameter freshDeskConnectRequest: (body)  
     - returns: RequestBuilder<GenericSuccessResponse> 
     */
    open func connectFreshdeskWithRequestBuilder(
            freshDeskConnectRequest: FreshDeskConnectRequest
    ) -> RequestBuilder<GenericSuccessResponse> {
        let basePath = self.client.basePath;
        let localVariablePath = "/integrations/freshdesk"
        let localVariableURLString = basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: freshDeskConnectRequest)

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        var localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        do {
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: self.client.accessToken, prefix: "Token ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: self.client.apiKey, prefix: "Bearer ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "customer-id", value: self.client.customerId, prefix: nil)
            let localVariableRequestBuilder: RequestBuilder<GenericSuccessResponse>.Type = CarbonAPI.requestBuilderFactory.getBuilder()
            let URLString = localVariableUrlComponents?.string ?? localVariableURLString
            return localVariableRequestBuilder.init(method: "POST", URLString: URLString, parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
        } catch {
            print("Error: \(error)")
        }
        fatalError("Error: Unable to send request to POST /integrations/freshdesk")
    }


    /**
     Gitbook Connect
     
     - parameter gitbookConnectRequest: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @discardableResult
    open class func connectGitbookSync(gitbookConnectRequest: GitbookConnectRequest, apiResponseQueue: DispatchQueue = CarbonAPI.apiResponseQueue, completion: @escaping ((_ data: GenericSuccessResponse?, _ error: Error?) -> Void)) -> RequestTask {
        return connectGitbookWithRequestBuilder(gitbookConnectRequest: gitbookConnectRequest).execute(apiResponseQueue) { result in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Gitbook Connect
     
     - parameter gitbookConnectRequest: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    private class func connectGitbookAsyncMappedParams(gitbookConnectRequest: GitbookConnectRequest) async throws -> GenericSuccessResponse {
        return try await withCheckedThrowingContinuation { continuation in
            connectGitbookWithRequestBuilder(gitbookConnectRequest: gitbookConnectRequest).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }

    /**
     Gitbook Connect
     
     - parameter gitbookConnectRequest: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    open class func connectGitbook(
        organization: String,
        accessToken: String,
        tags: AnyCodable? = nil, 
        chunkSize: Int? = nil, 
        chunkOverlap: Int? = nil, 
        skipEmbeddingGeneration: Bool? = nil, 
        embeddingModel: EmbeddingGenerators? = nil, 
        generateSparseVectors: Bool? = nil, 
        prependFilenameToChunks: Bool? = nil, 
        syncFilesOnConnection: Bool? = nil, 
        requestId: String? = nil
    ) async throws -> GenericSuccessResponse {
        let gitbookConnectRequest = GitbookConnectRequest(
            tags: tags,
            organization: organization,
            accessToken: accessToken,
            chunkSize: chunkSize,
            chunkOverlap: chunkOverlap,
            skipEmbeddingGeneration: skipEmbeddingGeneration,
            embeddingModel: embeddingModel,
            generateSparseVectors: generateSparseVectors,
            prependFilenameToChunks: prependFilenameToChunks,
            syncFilesOnConnection: syncFilesOnConnection,
            requestId: requestId
        )
        return try await withCheckedThrowingContinuation { continuation in
            connectGitbookWithRequestBuilder(gitbookConnectRequest: gitbookConnectRequest).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    /**
     Gitbook Connect
     
     - parameter gitbookConnectRequest: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    open func connectGitbook(
        organization: String,
        accessToken: String,
        tags: AnyCodable? = nil, 
        chunkSize: Int? = nil, 
        chunkOverlap: Int? = nil, 
        skipEmbeddingGeneration: Bool? = nil, 
        embeddingModel: EmbeddingGenerators? = nil, 
        generateSparseVectors: Bool? = nil, 
        prependFilenameToChunks: Bool? = nil, 
        syncFilesOnConnection: Bool? = nil, 
        requestId: String? = nil
    ) async throws -> GenericSuccessResponse {
        let gitbookConnectRequest = GitbookConnectRequest(
            tags: tags,
            organization: organization,
            accessToken: accessToken,
            chunkSize: chunkSize,
            chunkOverlap: chunkOverlap,
            skipEmbeddingGeneration: skipEmbeddingGeneration,
            embeddingModel: embeddingModel,
            generateSparseVectors: generateSparseVectors,
            prependFilenameToChunks: prependFilenameToChunks,
            syncFilesOnConnection: syncFilesOnConnection,
            requestId: requestId
        )
        return try await withCheckedThrowingContinuation { continuation in
            connectGitbookWithRequestBuilder(gitbookConnectRequest: gitbookConnectRequest).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }



    /**
     Gitbook Connect
     - POST /integrations/gitbook
     - You will need an access token to connect your Gitbook account. Note that the permissions will be defined by the user  generating access token so make sure you have the permission to access spaces you will be syncing.  Refer this article for more details https://developer.gitbook.com/gitbook-api/authentication. Additionally, you need to specify the name of organization you will be syncing data from.
     - API Key:
       - type: apiKey authorization 
       - name: accessToken
     - API Key:
       - type: apiKey authorization 
       - name: apiKey
     - API Key:
       - type: apiKey customer-id 
       - name: customerId
     - parameter gitbookConnectRequest: (body)  
     - returns: RequestBuilder<GenericSuccessResponse> 
     */
    open class func connectGitbookWithRequestBuilder(
            gitbookConnectRequest: GitbookConnectRequest
    ) -> RequestBuilder<GenericSuccessResponse> {
        let basePath = CarbonAPI.basePath;
        let localVariablePath = "/integrations/gitbook"
        let localVariableURLString = basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: gitbookConnectRequest)

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        var localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        do {
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: CarbonAPI.accessToken, prefix: "Token ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: CarbonAPI.apiKey, prefix: "Bearer ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "customer-id", value: CarbonAPI.customerId, prefix: nil)
            let localVariableRequestBuilder: RequestBuilder<GenericSuccessResponse>.Type = CarbonAPI.requestBuilderFactory.getBuilder()
            let URLString = localVariableUrlComponents?.string ?? localVariableURLString
            return localVariableRequestBuilder.init(method: "POST", URLString: URLString, parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
        } catch {
            print("Error: \(error)")
        }
        fatalError("Error: Unable to send request to POST /integrations/gitbook")
    }

    /**
     Gitbook Connect
     - POST /integrations/gitbook
     - You will need an access token to connect your Gitbook account. Note that the permissions will be defined by the user  generating access token so make sure you have the permission to access spaces you will be syncing.  Refer this article for more details https://developer.gitbook.com/gitbook-api/authentication. Additionally, you need to specify the name of organization you will be syncing data from.
     - API Key:
       - type: apiKey authorization 
       - name: accessToken
     - API Key:
       - type: apiKey authorization 
       - name: apiKey
     - API Key:
       - type: apiKey customer-id 
       - name: customerId
     - parameter gitbookConnectRequest: (body)  
     - returns: RequestBuilder<GenericSuccessResponse> 
     */
    open func connectGitbookWithRequestBuilder(
            gitbookConnectRequest: GitbookConnectRequest
    ) -> RequestBuilder<GenericSuccessResponse> {
        let basePath = self.client.basePath;
        let localVariablePath = "/integrations/gitbook"
        let localVariableURLString = basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: gitbookConnectRequest)

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        var localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        do {
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: self.client.accessToken, prefix: "Token ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: self.client.apiKey, prefix: "Bearer ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "customer-id", value: self.client.customerId, prefix: nil)
            let localVariableRequestBuilder: RequestBuilder<GenericSuccessResponse>.Type = CarbonAPI.requestBuilderFactory.getBuilder()
            let URLString = localVariableUrlComponents?.string ?? localVariableURLString
            return localVariableRequestBuilder.init(method: "POST", URLString: URLString, parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
        } catch {
            print("Error: \(error)")
        }
        fatalError("Error: Unable to send request to POST /integrations/gitbook")
    }


    /**
     S3 Auth
     
     - parameter s3AuthRequest: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @discardableResult
    open class func createAwsIamUserSync(s3AuthRequest: S3AuthRequest, apiResponseQueue: DispatchQueue = CarbonAPI.apiResponseQueue, completion: @escaping ((_ data: OrganizationUserDataSourceAPI?, _ error: Error?) -> Void)) -> RequestTask {
        return createAwsIamUserWithRequestBuilder(s3AuthRequest: s3AuthRequest).execute(apiResponseQueue) { result in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     S3 Auth
     
     - parameter s3AuthRequest: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    private class func createAwsIamUserAsyncMappedParams(s3AuthRequest: S3AuthRequest) async throws -> OrganizationUserDataSourceAPI {
        return try await withCheckedThrowingContinuation { continuation in
            createAwsIamUserWithRequestBuilder(s3AuthRequest: s3AuthRequest).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }

    /**
     S3 Auth
     
     - parameter s3AuthRequest: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    open class func createAwsIamUser(
        accessKey: String,
        accessKeySecret: String
    ) async throws -> OrganizationUserDataSourceAPI {
        let s3AuthRequest = S3AuthRequest(
            accessKey: accessKey,
            accessKeySecret: accessKeySecret
        )
        return try await withCheckedThrowingContinuation { continuation in
            createAwsIamUserWithRequestBuilder(s3AuthRequest: s3AuthRequest).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    /**
     S3 Auth
     
     - parameter s3AuthRequest: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    open func createAwsIamUser(
        accessKey: String,
        accessKeySecret: String
    ) async throws -> OrganizationUserDataSourceAPI {
        let s3AuthRequest = S3AuthRequest(
            accessKey: accessKey,
            accessKeySecret: accessKeySecret
        )
        return try await withCheckedThrowingContinuation { continuation in
            createAwsIamUserWithRequestBuilder(s3AuthRequest: s3AuthRequest).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }



    /**
     S3 Auth
     - POST /integrations/s3
     - Create a new IAM user with permissions to: <ol> <li>List all buckets.</li> <li>Read from the specific buckets and objects to sync with Carbon. Ensure any future buckets or objects carry  the same permissions.</li> </ol> Once created, generate an access key for this user and share the credentials with us. We recommend testing this key beforehand.
     - API Key:
       - type: apiKey authorization 
       - name: accessToken
     - API Key:
       - type: apiKey authorization 
       - name: apiKey
     - API Key:
       - type: apiKey customer-id 
       - name: customerId
     - parameter s3AuthRequest: (body)  
     - returns: RequestBuilder<OrganizationUserDataSourceAPI> 
     */
    open class func createAwsIamUserWithRequestBuilder(
            s3AuthRequest: S3AuthRequest
    ) -> RequestBuilder<OrganizationUserDataSourceAPI> {
        let basePath = CarbonAPI.basePath;
        let localVariablePath = "/integrations/s3"
        let localVariableURLString = basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: s3AuthRequest)

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        var localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        do {
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: CarbonAPI.accessToken, prefix: "Token ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: CarbonAPI.apiKey, prefix: "Bearer ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "customer-id", value: CarbonAPI.customerId, prefix: nil)
            let localVariableRequestBuilder: RequestBuilder<OrganizationUserDataSourceAPI>.Type = CarbonAPI.requestBuilderFactory.getBuilder()
            let URLString = localVariableUrlComponents?.string ?? localVariableURLString
            return localVariableRequestBuilder.init(method: "POST", URLString: URLString, parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
        } catch {
            print("Error: \(error)")
        }
        fatalError("Error: Unable to send request to POST /integrations/s3")
    }

    /**
     S3 Auth
     - POST /integrations/s3
     - Create a new IAM user with permissions to: <ol> <li>List all buckets.</li> <li>Read from the specific buckets and objects to sync with Carbon. Ensure any future buckets or objects carry  the same permissions.</li> </ol> Once created, generate an access key for this user and share the credentials with us. We recommend testing this key beforehand.
     - API Key:
       - type: apiKey authorization 
       - name: accessToken
     - API Key:
       - type: apiKey authorization 
       - name: apiKey
     - API Key:
       - type: apiKey customer-id 
       - name: customerId
     - parameter s3AuthRequest: (body)  
     - returns: RequestBuilder<OrganizationUserDataSourceAPI> 
     */
    open func createAwsIamUserWithRequestBuilder(
            s3AuthRequest: S3AuthRequest
    ) -> RequestBuilder<OrganizationUserDataSourceAPI> {
        let basePath = self.client.basePath;
        let localVariablePath = "/integrations/s3"
        let localVariableURLString = basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: s3AuthRequest)

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        var localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        do {
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: self.client.accessToken, prefix: "Token ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: self.client.apiKey, prefix: "Bearer ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "customer-id", value: self.client.customerId, prefix: nil)
            let localVariableRequestBuilder: RequestBuilder<OrganizationUserDataSourceAPI>.Type = CarbonAPI.requestBuilderFactory.getBuilder()
            let URLString = localVariableUrlComponents?.string ?? localVariableURLString
            return localVariableRequestBuilder.init(method: "POST", URLString: URLString, parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
        } catch {
            print("Error: \(error)")
        }
        fatalError("Error: Unable to send request to POST /integrations/s3")
    }


    /**
     Get Oauth Url
     
     - parameter oAuthURLRequest: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @discardableResult
    open class func getOauthUrlSync(oAuthURLRequest: OAuthURLRequest, apiResponseQueue: DispatchQueue = CarbonAPI.apiResponseQueue, completion: @escaping ((_ data: OuthURLResponse?, _ error: Error?) -> Void)) -> RequestTask {
        return getOauthUrlWithRequestBuilder(oAuthURLRequest: oAuthURLRequest).execute(apiResponseQueue) { result in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Get Oauth Url
     
     - parameter oAuthURLRequest: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    private class func getOauthUrlAsyncMappedParams(oAuthURLRequest: OAuthURLRequest) async throws -> OuthURLResponse {
        return try await withCheckedThrowingContinuation { continuation in
            getOauthUrlWithRequestBuilder(oAuthURLRequest: oAuthURLRequest).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }

    /**
     Get Oauth Url
     
     - parameter oAuthURLRequest: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    open class func getOauthUrl(
        service: DataSourceType,
        tags: AnyCodable? = nil, 
        scope: String? = nil, 
        chunkSize: Int? = nil, 
        chunkOverlap: Int? = nil, 
        skipEmbeddingGeneration: Bool? = nil, 
        embeddingModel: EmbeddingGeneratorsNullable? = nil, 
        zendeskSubdomain: String? = nil, 
        microsoftTenant: String? = nil, 
        sharepointSiteName: String? = nil, 
        confluenceSubdomain: String? = nil, 
        generateSparseVectors: Bool? = nil, 
        prependFilenameToChunks: Bool? = nil, 
        maxItemsPerChunk: Int? = nil, 
        salesforceDomain: String? = nil, 
        syncFilesOnConnection: Bool? = nil, 
        setPageAsBoundary: Bool? = nil, 
        dataSourceId: Int? = nil, 
        connectingNewAccount: Bool? = nil, 
        requestId: String? = nil
    ) async throws -> OuthURLResponse {
        let oAuthURLRequest = OAuthURLRequest(
            tags: tags,
            scope: scope,
            service: service,
            chunkSize: chunkSize,
            chunkOverlap: chunkOverlap,
            skipEmbeddingGeneration: skipEmbeddingGeneration,
            embeddingModel: embeddingModel,
            zendeskSubdomain: zendeskSubdomain,
            microsoftTenant: microsoftTenant,
            sharepointSiteName: sharepointSiteName,
            confluenceSubdomain: confluenceSubdomain,
            generateSparseVectors: generateSparseVectors,
            prependFilenameToChunks: prependFilenameToChunks,
            maxItemsPerChunk: maxItemsPerChunk,
            salesforceDomain: salesforceDomain,
            syncFilesOnConnection: syncFilesOnConnection,
            setPageAsBoundary: setPageAsBoundary,
            dataSourceId: dataSourceId,
            connectingNewAccount: connectingNewAccount,
            requestId: requestId
        )
        return try await withCheckedThrowingContinuation { continuation in
            getOauthUrlWithRequestBuilder(oAuthURLRequest: oAuthURLRequest).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    /**
     Get Oauth Url
     
     - parameter oAuthURLRequest: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    open func getOauthUrl(
        service: DataSourceType,
        tags: AnyCodable? = nil, 
        scope: String? = nil, 
        chunkSize: Int? = nil, 
        chunkOverlap: Int? = nil, 
        skipEmbeddingGeneration: Bool? = nil, 
        embeddingModel: EmbeddingGeneratorsNullable? = nil, 
        zendeskSubdomain: String? = nil, 
        microsoftTenant: String? = nil, 
        sharepointSiteName: String? = nil, 
        confluenceSubdomain: String? = nil, 
        generateSparseVectors: Bool? = nil, 
        prependFilenameToChunks: Bool? = nil, 
        maxItemsPerChunk: Int? = nil, 
        salesforceDomain: String? = nil, 
        syncFilesOnConnection: Bool? = nil, 
        setPageAsBoundary: Bool? = nil, 
        dataSourceId: Int? = nil, 
        connectingNewAccount: Bool? = nil, 
        requestId: String? = nil
    ) async throws -> OuthURLResponse {
        let oAuthURLRequest = OAuthURLRequest(
            tags: tags,
            scope: scope,
            service: service,
            chunkSize: chunkSize,
            chunkOverlap: chunkOverlap,
            skipEmbeddingGeneration: skipEmbeddingGeneration,
            embeddingModel: embeddingModel,
            zendeskSubdomain: zendeskSubdomain,
            microsoftTenant: microsoftTenant,
            sharepointSiteName: sharepointSiteName,
            confluenceSubdomain: confluenceSubdomain,
            generateSparseVectors: generateSparseVectors,
            prependFilenameToChunks: prependFilenameToChunks,
            maxItemsPerChunk: maxItemsPerChunk,
            salesforceDomain: salesforceDomain,
            syncFilesOnConnection: syncFilesOnConnection,
            setPageAsBoundary: setPageAsBoundary,
            dataSourceId: dataSourceId,
            connectingNewAccount: connectingNewAccount,
            requestId: requestId
        )
        return try await withCheckedThrowingContinuation { continuation in
            getOauthUrlWithRequestBuilder(oAuthURLRequest: oAuthURLRequest).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }



    /**
     Get Oauth Url
     - POST /integrations/oauth_url
     - This endpoint can be used to generate the following URLs - An OAuth URL for OAuth based connectors - A file syncing URL which skips the OAuth flow if the user already has a valid access token and takes them to the success state.
     - API Key:
       - type: apiKey authorization 
       - name: accessToken
     - API Key:
       - type: apiKey authorization 
       - name: apiKey
     - API Key:
       - type: apiKey customer-id 
       - name: customerId
     - parameter oAuthURLRequest: (body)  
     - returns: RequestBuilder<OuthURLResponse> 
     */
    open class func getOauthUrlWithRequestBuilder(
            oAuthURLRequest: OAuthURLRequest
    ) -> RequestBuilder<OuthURLResponse> {
        let basePath = CarbonAPI.basePath;
        let localVariablePath = "/integrations/oauth_url"
        let localVariableURLString = basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: oAuthURLRequest)

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        var localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        do {
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: CarbonAPI.accessToken, prefix: "Token ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: CarbonAPI.apiKey, prefix: "Bearer ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "customer-id", value: CarbonAPI.customerId, prefix: nil)
            let localVariableRequestBuilder: RequestBuilder<OuthURLResponse>.Type = CarbonAPI.requestBuilderFactory.getBuilder()
            let URLString = localVariableUrlComponents?.string ?? localVariableURLString
            return localVariableRequestBuilder.init(method: "POST", URLString: URLString, parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
        } catch {
            print("Error: \(error)")
        }
        fatalError("Error: Unable to send request to POST /integrations/oauth_url")
    }

    /**
     Get Oauth Url
     - POST /integrations/oauth_url
     - This endpoint can be used to generate the following URLs - An OAuth URL for OAuth based connectors - A file syncing URL which skips the OAuth flow if the user already has a valid access token and takes them to the success state.
     - API Key:
       - type: apiKey authorization 
       - name: accessToken
     - API Key:
       - type: apiKey authorization 
       - name: apiKey
     - API Key:
       - type: apiKey customer-id 
       - name: customerId
     - parameter oAuthURLRequest: (body)  
     - returns: RequestBuilder<OuthURLResponse> 
     */
    open func getOauthUrlWithRequestBuilder(
            oAuthURLRequest: OAuthURLRequest
    ) -> RequestBuilder<OuthURLResponse> {
        let basePath = self.client.basePath;
        let localVariablePath = "/integrations/oauth_url"
        let localVariableURLString = basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: oAuthURLRequest)

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        var localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        do {
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: self.client.accessToken, prefix: "Token ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: self.client.apiKey, prefix: "Bearer ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "customer-id", value: self.client.customerId, prefix: nil)
            let localVariableRequestBuilder: RequestBuilder<OuthURLResponse>.Type = CarbonAPI.requestBuilderFactory.getBuilder()
            let URLString = localVariableUrlComponents?.string ?? localVariableURLString
            return localVariableRequestBuilder.init(method: "POST", URLString: URLString, parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
        } catch {
            print("Error: \(error)")
        }
        fatalError("Error: Unable to send request to POST /integrations/oauth_url")
    }


    /**
     Confluence List
     
     - parameter listRequest: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @discardableResult
    open class func listConfluencePagesSync(listRequest: ListRequest, apiResponseQueue: DispatchQueue = CarbonAPI.apiResponseQueue, completion: @escaping ((_ data: ListResponse?, _ error: Error?) -> Void)) -> RequestTask {
        return listConfluencePagesWithRequestBuilder(listRequest: listRequest).execute(apiResponseQueue) { result in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Confluence List
     
     - parameter listRequest: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    private class func listConfluencePagesAsyncMappedParams(listRequest: ListRequest) async throws -> ListResponse {
        return try await withCheckedThrowingContinuation { continuation in
            listConfluencePagesWithRequestBuilder(listRequest: listRequest).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }

    /**
     Confluence List
     
     - parameter listRequest: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    open class func listConfluencePages(
        dataSourceId: Int,
        parentId: String? = nil
    ) async throws -> ListResponse {
        let listRequest = ListRequest(
            dataSourceId: dataSourceId,
            parentId: parentId
        )
        return try await withCheckedThrowingContinuation { continuation in
            listConfluencePagesWithRequestBuilder(listRequest: listRequest).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    /**
     Confluence List
     
     - parameter listRequest: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    open func listConfluencePages(
        dataSourceId: Int,
        parentId: String? = nil
    ) async throws -> ListResponse {
        let listRequest = ListRequest(
            dataSourceId: dataSourceId,
            parentId: parentId
        )
        return try await withCheckedThrowingContinuation { continuation in
            listConfluencePagesWithRequestBuilder(listRequest: listRequest).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }



    /**
     Confluence List
     - POST /integrations/confluence/list
     - To begin listing a user's Confluence pages, at least a `data_source_id` of a connected Confluence account must be specified. This base request returns a list of root pages for every space the user has access to in a Confluence instance. To traverse further down the user's page directory, additional requests to this endpoint can be made with the same `data_source_id` and with `parent_id` set to the id of page from a previous request. For convenience, the `has_children` property in each directory item in the response list will flag which pages will return non-empty lists of pages when set as the `parent_id`.
     - API Key:
       - type: apiKey authorization 
       - name: accessToken
     - API Key:
       - type: apiKey authorization 
       - name: apiKey
     - API Key:
       - type: apiKey customer-id 
       - name: customerId
     - parameter listRequest: (body)  
     - returns: RequestBuilder<ListResponse> 
     */
    open class func listConfluencePagesWithRequestBuilder(
            listRequest: ListRequest
    ) -> RequestBuilder<ListResponse> {
        let basePath = CarbonAPI.basePath;
        let localVariablePath = "/integrations/confluence/list"
        let localVariableURLString = basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: listRequest)

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        var localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        do {
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: CarbonAPI.accessToken, prefix: "Token ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: CarbonAPI.apiKey, prefix: "Bearer ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "customer-id", value: CarbonAPI.customerId, prefix: nil)
            let localVariableRequestBuilder: RequestBuilder<ListResponse>.Type = CarbonAPI.requestBuilderFactory.getBuilder()
            let URLString = localVariableUrlComponents?.string ?? localVariableURLString
            return localVariableRequestBuilder.init(method: "POST", URLString: URLString, parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
        } catch {
            print("Error: \(error)")
        }
        fatalError("Error: Unable to send request to POST /integrations/confluence/list")
    }

    /**
     Confluence List
     - POST /integrations/confluence/list
     - To begin listing a user's Confluence pages, at least a `data_source_id` of a connected Confluence account must be specified. This base request returns a list of root pages for every space the user has access to in a Confluence instance. To traverse further down the user's page directory, additional requests to this endpoint can be made with the same `data_source_id` and with `parent_id` set to the id of page from a previous request. For convenience, the `has_children` property in each directory item in the response list will flag which pages will return non-empty lists of pages when set as the `parent_id`.
     - API Key:
       - type: apiKey authorization 
       - name: accessToken
     - API Key:
       - type: apiKey authorization 
       - name: apiKey
     - API Key:
       - type: apiKey customer-id 
       - name: customerId
     - parameter listRequest: (body)  
     - returns: RequestBuilder<ListResponse> 
     */
    open func listConfluencePagesWithRequestBuilder(
            listRequest: ListRequest
    ) -> RequestBuilder<ListResponse> {
        let basePath = self.client.basePath;
        let localVariablePath = "/integrations/confluence/list"
        let localVariableURLString = basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: listRequest)

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        var localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        do {
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: self.client.accessToken, prefix: "Token ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: self.client.apiKey, prefix: "Bearer ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "customer-id", value: self.client.customerId, prefix: nil)
            let localVariableRequestBuilder: RequestBuilder<ListResponse>.Type = CarbonAPI.requestBuilderFactory.getBuilder()
            let URLString = localVariableUrlComponents?.string ?? localVariableURLString
            return localVariableRequestBuilder.init(method: "POST", URLString: URLString, parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
        } catch {
            print("Error: \(error)")
        }
        fatalError("Error: Unable to send request to POST /integrations/confluence/list")
    }


    /**
     List Data Source Items
     
     - parameter listDataSourceItemsRequest: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @discardableResult
    open class func listDataSourceItemsSync(listDataSourceItemsRequest: ListDataSourceItemsRequest, apiResponseQueue: DispatchQueue = CarbonAPI.apiResponseQueue, completion: @escaping ((_ data: ListDataSourceItemsResponse?, _ error: Error?) -> Void)) -> RequestTask {
        return listDataSourceItemsWithRequestBuilder(listDataSourceItemsRequest: listDataSourceItemsRequest).execute(apiResponseQueue) { result in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     List Data Source Items
     
     - parameter listDataSourceItemsRequest: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    private class func listDataSourceItemsAsyncMappedParams(listDataSourceItemsRequest: ListDataSourceItemsRequest) async throws -> ListDataSourceItemsResponse {
        return try await withCheckedThrowingContinuation { continuation in
            listDataSourceItemsWithRequestBuilder(listDataSourceItemsRequest: listDataSourceItemsRequest).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }

    /**
     List Data Source Items
     
     - parameter listDataSourceItemsRequest: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    open class func listDataSourceItems(
        dataSourceId: Int,
        parentId: String? = nil, 
        filters: ListItemsFiltersNullable? = nil, 
        pagination: Pagination? = nil
    ) async throws -> ListDataSourceItemsResponse {
        let listDataSourceItemsRequest = ListDataSourceItemsRequest(
            dataSourceId: dataSourceId,
            parentId: parentId,
            filters: filters,
            pagination: pagination
        )
        return try await withCheckedThrowingContinuation { continuation in
            listDataSourceItemsWithRequestBuilder(listDataSourceItemsRequest: listDataSourceItemsRequest).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    /**
     List Data Source Items
     
     - parameter listDataSourceItemsRequest: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    open func listDataSourceItems(
        dataSourceId: Int,
        parentId: String? = nil, 
        filters: ListItemsFiltersNullable? = nil, 
        pagination: Pagination? = nil
    ) async throws -> ListDataSourceItemsResponse {
        let listDataSourceItemsRequest = ListDataSourceItemsRequest(
            dataSourceId: dataSourceId,
            parentId: parentId,
            filters: filters,
            pagination: pagination
        )
        return try await withCheckedThrowingContinuation { continuation in
            listDataSourceItemsWithRequestBuilder(listDataSourceItemsRequest: listDataSourceItemsRequest).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }



    /**
     List Data Source Items
     - POST /integrations/items/list
     - API Key:
       - type: apiKey authorization 
       - name: accessToken
     - API Key:
       - type: apiKey authorization 
       - name: apiKey
     - API Key:
       - type: apiKey customer-id 
       - name: customerId
     - parameter listDataSourceItemsRequest: (body)  
     - returns: RequestBuilder<ListDataSourceItemsResponse> 
     */
    open class func listDataSourceItemsWithRequestBuilder(
            listDataSourceItemsRequest: ListDataSourceItemsRequest
    ) -> RequestBuilder<ListDataSourceItemsResponse> {
        let basePath = CarbonAPI.basePath;
        let localVariablePath = "/integrations/items/list"
        let localVariableURLString = basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: listDataSourceItemsRequest)

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        var localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        do {
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: CarbonAPI.accessToken, prefix: "Token ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: CarbonAPI.apiKey, prefix: "Bearer ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "customer-id", value: CarbonAPI.customerId, prefix: nil)
            let localVariableRequestBuilder: RequestBuilder<ListDataSourceItemsResponse>.Type = CarbonAPI.requestBuilderFactory.getBuilder()
            let URLString = localVariableUrlComponents?.string ?? localVariableURLString
            return localVariableRequestBuilder.init(method: "POST", URLString: URLString, parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
        } catch {
            print("Error: \(error)")
        }
        fatalError("Error: Unable to send request to POST /integrations/items/list")
    }

    /**
     List Data Source Items
     - POST /integrations/items/list
     - API Key:
       - type: apiKey authorization 
       - name: accessToken
     - API Key:
       - type: apiKey authorization 
       - name: apiKey
     - API Key:
       - type: apiKey customer-id 
       - name: customerId
     - parameter listDataSourceItemsRequest: (body)  
     - returns: RequestBuilder<ListDataSourceItemsResponse> 
     */
    open func listDataSourceItemsWithRequestBuilder(
            listDataSourceItemsRequest: ListDataSourceItemsRequest
    ) -> RequestBuilder<ListDataSourceItemsResponse> {
        let basePath = self.client.basePath;
        let localVariablePath = "/integrations/items/list"
        let localVariableURLString = basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: listDataSourceItemsRequest)

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        var localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        do {
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: self.client.accessToken, prefix: "Token ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: self.client.apiKey, prefix: "Bearer ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "customer-id", value: self.client.customerId, prefix: nil)
            let localVariableRequestBuilder: RequestBuilder<ListDataSourceItemsResponse>.Type = CarbonAPI.requestBuilderFactory.getBuilder()
            let URLString = localVariableUrlComponents?.string ?? localVariableURLString
            return localVariableRequestBuilder.init(method: "POST", URLString: URLString, parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
        } catch {
            print("Error: \(error)")
        }
        fatalError("Error: Unable to send request to POST /integrations/items/list")
    }


    /**
     Outlook Folders
     
     - parameter dataSourceId: (query)  (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @discardableResult
    open class func listFoldersSync(dataSourceId: Int? = nil, apiResponseQueue: DispatchQueue = CarbonAPI.apiResponseQueue, completion: @escaping ((_ data: AnyCodable?, _ error: Error?) -> Void)) -> RequestTask {
        return listFoldersWithRequestBuilder(dataSourceId: dataSourceId).execute(apiResponseQueue) { result in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Outlook Folders
     
     - parameter dataSourceId: (query)  (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    private class func listFoldersAsyncMappedParams(dataSourceId: Int? = nil) async throws -> AnyCodable {
        return try await withCheckedThrowingContinuation { continuation in
            listFoldersWithRequestBuilder(dataSourceId: dataSourceId).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }

    /**
     Outlook Folders
     
     - parameter dataSourceId: (query)  (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    open class func listFolders(
        dataSourceId: Int? = nil
    ) async throws -> AnyCodable {
        return try await withCheckedThrowingContinuation { continuation in
            listFoldersWithRequestBuilder(dataSourceId: dataSourceId).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    /**
     Outlook Folders
     
     - parameter dataSourceId: (query)  (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    open func listFolders(
        dataSourceId: Int? = nil
    ) async throws -> AnyCodable {
        return try await withCheckedThrowingContinuation { continuation in
            listFoldersWithRequestBuilder(dataSourceId: dataSourceId).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }



    /**
     Outlook Folders
     - GET /integrations/outlook/user_folders
     - After connecting your Outlook account, you can use this endpoint to list all of your folders on outlook. This includes  both system folders like \"inbox\" and user created folders.
     - API Key:
       - type: apiKey authorization 
       - name: accessToken
     - API Key:
       - type: apiKey authorization 
       - name: apiKey
     - API Key:
       - type: apiKey customer-id 
       - name: customerId
     - parameter dataSourceId: (query)  (optional)
     - returns: RequestBuilder<AnyCodable> 
     */
    open class func listFoldersWithRequestBuilder(
            dataSourceId: Int? = nil
    ) -> RequestBuilder<AnyCodable> {
        let basePath = CarbonAPI.basePath;
        let localVariablePath = "/integrations/outlook/user_folders"
        let localVariableURLString = basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil
        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "data_source_id": (wrappedValue: dataSourceId?.encodeToJSON(), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        var localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        do {
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: CarbonAPI.accessToken, prefix: "Token ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: CarbonAPI.apiKey, prefix: "Bearer ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "customer-id", value: CarbonAPI.customerId, prefix: nil)
            let localVariableRequestBuilder: RequestBuilder<AnyCodable>.Type = CarbonAPI.requestBuilderFactory.getBuilder()
            let URLString = localVariableUrlComponents?.string ?? localVariableURLString
            return localVariableRequestBuilder.init(method: "GET", URLString: URLString, parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
        } catch {
            print("Error: \(error)")
        }
        fatalError("Error: Unable to send request to GET /integrations/outlook/user_folders")
    }

    /**
     Outlook Folders
     - GET /integrations/outlook/user_folders
     - After connecting your Outlook account, you can use this endpoint to list all of your folders on outlook. This includes  both system folders like \"inbox\" and user created folders.
     - API Key:
       - type: apiKey authorization 
       - name: accessToken
     - API Key:
       - type: apiKey authorization 
       - name: apiKey
     - API Key:
       - type: apiKey customer-id 
       - name: customerId
     - parameter dataSourceId: (query)  (optional)
     - returns: RequestBuilder<AnyCodable> 
     */
    open func listFoldersWithRequestBuilder(
            dataSourceId: Int? = nil
    ) -> RequestBuilder<AnyCodable> {
        let basePath = self.client.basePath;
        let localVariablePath = "/integrations/outlook/user_folders"
        let localVariableURLString = basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil
        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "data_source_id": (wrappedValue: dataSourceId?.encodeToJSON(), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        var localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        do {
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: self.client.accessToken, prefix: "Token ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: self.client.apiKey, prefix: "Bearer ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "customer-id", value: self.client.customerId, prefix: nil)
            let localVariableRequestBuilder: RequestBuilder<AnyCodable>.Type = CarbonAPI.requestBuilderFactory.getBuilder()
            let URLString = localVariableUrlComponents?.string ?? localVariableURLString
            return localVariableRequestBuilder.init(method: "GET", URLString: URLString, parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
        } catch {
            print("Error: \(error)")
        }
        fatalError("Error: Unable to send request to GET /integrations/outlook/user_folders")
    }


    /**
     Gitbook Spaces
     
     - parameter dataSourceId: (query)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @discardableResult
    open class func listGitbookSpacesSync(dataSourceId: Int, apiResponseQueue: DispatchQueue = CarbonAPI.apiResponseQueue, completion: @escaping ((_ data: AnyCodable?, _ error: Error?) -> Void)) -> RequestTask {
        return listGitbookSpacesWithRequestBuilder(dataSourceId: dataSourceId).execute(apiResponseQueue) { result in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Gitbook Spaces
     
     - parameter dataSourceId: (query)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    private class func listGitbookSpacesAsyncMappedParams(dataSourceId: Int) async throws -> AnyCodable {
        return try await withCheckedThrowingContinuation { continuation in
            listGitbookSpacesWithRequestBuilder(dataSourceId: dataSourceId).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }

    /**
     Gitbook Spaces
     
     - parameter dataSourceId: (query)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    open class func listGitbookSpaces(
        dataSourceId: Int
    ) async throws -> AnyCodable {
        return try await withCheckedThrowingContinuation { continuation in
            listGitbookSpacesWithRequestBuilder(dataSourceId: dataSourceId).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    /**
     Gitbook Spaces
     
     - parameter dataSourceId: (query)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    open func listGitbookSpaces(
        dataSourceId: Int
    ) async throws -> AnyCodable {
        return try await withCheckedThrowingContinuation { continuation in
            listGitbookSpacesWithRequestBuilder(dataSourceId: dataSourceId).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }



    /**
     Gitbook Spaces
     - GET /integrations/gitbook/spaces
     - After connecting your Gitbook account, you can use this endpoint to list all of your spaces under current organization.
     - API Key:
       - type: apiKey authorization 
       - name: accessToken
     - API Key:
       - type: apiKey authorization 
       - name: apiKey
     - API Key:
       - type: apiKey customer-id 
       - name: customerId
     - parameter dataSourceId: (query)  
     - returns: RequestBuilder<AnyCodable> 
     */
    open class func listGitbookSpacesWithRequestBuilder(
            dataSourceId: Int
    ) -> RequestBuilder<AnyCodable> {
        let basePath = CarbonAPI.basePath;
        let localVariablePath = "/integrations/gitbook/spaces"
        let localVariableURLString = basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil
        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "data_source_id": (wrappedValue: dataSourceId.encodeToJSON(), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        var localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        do {
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: CarbonAPI.accessToken, prefix: "Token ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: CarbonAPI.apiKey, prefix: "Bearer ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "customer-id", value: CarbonAPI.customerId, prefix: nil)
            let localVariableRequestBuilder: RequestBuilder<AnyCodable>.Type = CarbonAPI.requestBuilderFactory.getBuilder()
            let URLString = localVariableUrlComponents?.string ?? localVariableURLString
            return localVariableRequestBuilder.init(method: "GET", URLString: URLString, parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
        } catch {
            print("Error: \(error)")
        }
        fatalError("Error: Unable to send request to GET /integrations/gitbook/spaces")
    }

    /**
     Gitbook Spaces
     - GET /integrations/gitbook/spaces
     - After connecting your Gitbook account, you can use this endpoint to list all of your spaces under current organization.
     - API Key:
       - type: apiKey authorization 
       - name: accessToken
     - API Key:
       - type: apiKey authorization 
       - name: apiKey
     - API Key:
       - type: apiKey customer-id 
       - name: customerId
     - parameter dataSourceId: (query)  
     - returns: RequestBuilder<AnyCodable> 
     */
    open func listGitbookSpacesWithRequestBuilder(
            dataSourceId: Int
    ) -> RequestBuilder<AnyCodable> {
        let basePath = self.client.basePath;
        let localVariablePath = "/integrations/gitbook/spaces"
        let localVariableURLString = basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil
        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "data_source_id": (wrappedValue: dataSourceId.encodeToJSON(), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        var localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        do {
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: self.client.accessToken, prefix: "Token ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: self.client.apiKey, prefix: "Bearer ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "customer-id", value: self.client.customerId, prefix: nil)
            let localVariableRequestBuilder: RequestBuilder<AnyCodable>.Type = CarbonAPI.requestBuilderFactory.getBuilder()
            let URLString = localVariableUrlComponents?.string ?? localVariableURLString
            return localVariableRequestBuilder.init(method: "GET", URLString: URLString, parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
        } catch {
            print("Error: \(error)")
        }
        fatalError("Error: Unable to send request to GET /integrations/gitbook/spaces")
    }


    /**
     Gmail Labels
     
     - parameter dataSourceId: (query)  (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @discardableResult
    open class func listLabelsSync(dataSourceId: Int? = nil, apiResponseQueue: DispatchQueue = CarbonAPI.apiResponseQueue, completion: @escaping ((_ data: AnyCodable?, _ error: Error?) -> Void)) -> RequestTask {
        return listLabelsWithRequestBuilder(dataSourceId: dataSourceId).execute(apiResponseQueue) { result in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Gmail Labels
     
     - parameter dataSourceId: (query)  (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    private class func listLabelsAsyncMappedParams(dataSourceId: Int? = nil) async throws -> AnyCodable {
        return try await withCheckedThrowingContinuation { continuation in
            listLabelsWithRequestBuilder(dataSourceId: dataSourceId).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }

    /**
     Gmail Labels
     
     - parameter dataSourceId: (query)  (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    open class func listLabels(
        dataSourceId: Int? = nil
    ) async throws -> AnyCodable {
        return try await withCheckedThrowingContinuation { continuation in
            listLabelsWithRequestBuilder(dataSourceId: dataSourceId).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    /**
     Gmail Labels
     
     - parameter dataSourceId: (query)  (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    open func listLabels(
        dataSourceId: Int? = nil
    ) async throws -> AnyCodable {
        return try await withCheckedThrowingContinuation { continuation in
            listLabelsWithRequestBuilder(dataSourceId: dataSourceId).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }



    /**
     Gmail Labels
     - GET /integrations/gmail/user_labels
     - After connecting your Gmail account, you can use this endpoint to list all of your labels. User created labels will have the type \"user\" and Gmail's default labels will have the type \"system\"
     - API Key:
       - type: apiKey authorization 
       - name: accessToken
     - API Key:
       - type: apiKey authorization 
       - name: apiKey
     - API Key:
       - type: apiKey customer-id 
       - name: customerId
     - parameter dataSourceId: (query)  (optional)
     - returns: RequestBuilder<AnyCodable> 
     */
    open class func listLabelsWithRequestBuilder(
            dataSourceId: Int? = nil
    ) -> RequestBuilder<AnyCodable> {
        let basePath = CarbonAPI.basePath;
        let localVariablePath = "/integrations/gmail/user_labels"
        let localVariableURLString = basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil
        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "data_source_id": (wrappedValue: dataSourceId?.encodeToJSON(), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        var localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        do {
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: CarbonAPI.accessToken, prefix: "Token ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: CarbonAPI.apiKey, prefix: "Bearer ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "customer-id", value: CarbonAPI.customerId, prefix: nil)
            let localVariableRequestBuilder: RequestBuilder<AnyCodable>.Type = CarbonAPI.requestBuilderFactory.getBuilder()
            let URLString = localVariableUrlComponents?.string ?? localVariableURLString
            return localVariableRequestBuilder.init(method: "GET", URLString: URLString, parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
        } catch {
            print("Error: \(error)")
        }
        fatalError("Error: Unable to send request to GET /integrations/gmail/user_labels")
    }

    /**
     Gmail Labels
     - GET /integrations/gmail/user_labels
     - After connecting your Gmail account, you can use this endpoint to list all of your labels. User created labels will have the type \"user\" and Gmail's default labels will have the type \"system\"
     - API Key:
       - type: apiKey authorization 
       - name: accessToken
     - API Key:
       - type: apiKey authorization 
       - name: apiKey
     - API Key:
       - type: apiKey customer-id 
       - name: customerId
     - parameter dataSourceId: (query)  (optional)
     - returns: RequestBuilder<AnyCodable> 
     */
    open func listLabelsWithRequestBuilder(
            dataSourceId: Int? = nil
    ) -> RequestBuilder<AnyCodable> {
        let basePath = self.client.basePath;
        let localVariablePath = "/integrations/gmail/user_labels"
        let localVariableURLString = basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil
        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "data_source_id": (wrappedValue: dataSourceId?.encodeToJSON(), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        var localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        do {
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: self.client.accessToken, prefix: "Token ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: self.client.apiKey, prefix: "Bearer ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "customer-id", value: self.client.customerId, prefix: nil)
            let localVariableRequestBuilder: RequestBuilder<AnyCodable>.Type = CarbonAPI.requestBuilderFactory.getBuilder()
            let URLString = localVariableUrlComponents?.string ?? localVariableURLString
            return localVariableRequestBuilder.init(method: "GET", URLString: URLString, parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
        } catch {
            print("Error: \(error)")
        }
        fatalError("Error: Unable to send request to GET /integrations/gmail/user_labels")
    }


    /**
     Outlook Categories
     
     - parameter dataSourceId: (query)  (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @discardableResult
    open class func listOutlookCategoriesSync(dataSourceId: Int? = nil, apiResponseQueue: DispatchQueue = CarbonAPI.apiResponseQueue, completion: @escaping ((_ data: AnyCodable?, _ error: Error?) -> Void)) -> RequestTask {
        return listOutlookCategoriesWithRequestBuilder(dataSourceId: dataSourceId).execute(apiResponseQueue) { result in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Outlook Categories
     
     - parameter dataSourceId: (query)  (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    private class func listOutlookCategoriesAsyncMappedParams(dataSourceId: Int? = nil) async throws -> AnyCodable {
        return try await withCheckedThrowingContinuation { continuation in
            listOutlookCategoriesWithRequestBuilder(dataSourceId: dataSourceId).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }

    /**
     Outlook Categories
     
     - parameter dataSourceId: (query)  (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    open class func listOutlookCategories(
        dataSourceId: Int? = nil
    ) async throws -> AnyCodable {
        return try await withCheckedThrowingContinuation { continuation in
            listOutlookCategoriesWithRequestBuilder(dataSourceId: dataSourceId).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    /**
     Outlook Categories
     
     - parameter dataSourceId: (query)  (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    open func listOutlookCategories(
        dataSourceId: Int? = nil
    ) async throws -> AnyCodable {
        return try await withCheckedThrowingContinuation { continuation in
            listOutlookCategoriesWithRequestBuilder(dataSourceId: dataSourceId).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }



    /**
     Outlook Categories
     - GET /integrations/outlook/user_categories
     - After connecting your Outlook account, you can use this endpoint to list all of your categories on outlook. We currently support listing up to 250 categories.
     - API Key:
       - type: apiKey authorization 
       - name: accessToken
     - API Key:
       - type: apiKey authorization 
       - name: apiKey
     - API Key:
       - type: apiKey customer-id 
       - name: customerId
     - parameter dataSourceId: (query)  (optional)
     - returns: RequestBuilder<AnyCodable> 
     */
    open class func listOutlookCategoriesWithRequestBuilder(
            dataSourceId: Int? = nil
    ) -> RequestBuilder<AnyCodable> {
        let basePath = CarbonAPI.basePath;
        let localVariablePath = "/integrations/outlook/user_categories"
        let localVariableURLString = basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil
        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "data_source_id": (wrappedValue: dataSourceId?.encodeToJSON(), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        var localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        do {
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: CarbonAPI.accessToken, prefix: "Token ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: CarbonAPI.apiKey, prefix: "Bearer ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "customer-id", value: CarbonAPI.customerId, prefix: nil)
            let localVariableRequestBuilder: RequestBuilder<AnyCodable>.Type = CarbonAPI.requestBuilderFactory.getBuilder()
            let URLString = localVariableUrlComponents?.string ?? localVariableURLString
            return localVariableRequestBuilder.init(method: "GET", URLString: URLString, parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
        } catch {
            print("Error: \(error)")
        }
        fatalError("Error: Unable to send request to GET /integrations/outlook/user_categories")
    }

    /**
     Outlook Categories
     - GET /integrations/outlook/user_categories
     - After connecting your Outlook account, you can use this endpoint to list all of your categories on outlook. We currently support listing up to 250 categories.
     - API Key:
       - type: apiKey authorization 
       - name: accessToken
     - API Key:
       - type: apiKey authorization 
       - name: apiKey
     - API Key:
       - type: apiKey customer-id 
       - name: customerId
     - parameter dataSourceId: (query)  (optional)
     - returns: RequestBuilder<AnyCodable> 
     */
    open func listOutlookCategoriesWithRequestBuilder(
            dataSourceId: Int? = nil
    ) -> RequestBuilder<AnyCodable> {
        let basePath = self.client.basePath;
        let localVariablePath = "/integrations/outlook/user_categories"
        let localVariableURLString = basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil
        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "data_source_id": (wrappedValue: dataSourceId?.encodeToJSON(), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        var localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        do {
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: self.client.accessToken, prefix: "Token ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: self.client.apiKey, prefix: "Bearer ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "customer-id", value: self.client.customerId, prefix: nil)
            let localVariableRequestBuilder: RequestBuilder<AnyCodable>.Type = CarbonAPI.requestBuilderFactory.getBuilder()
            let URLString = localVariableUrlComponents?.string ?? localVariableURLString
            return localVariableRequestBuilder.init(method: "GET", URLString: URLString, parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
        } catch {
            print("Error: \(error)")
        }
        fatalError("Error: Unable to send request to GET /integrations/outlook/user_categories")
    }


    /**
     Confluence Sync
     
     - parameter syncFilesRequest: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @discardableResult
    open class func syncConfluenceSync(syncFilesRequest: SyncFilesRequest, apiResponseQueue: DispatchQueue = CarbonAPI.apiResponseQueue, completion: @escaping ((_ data: GenericSuccessResponse?, _ error: Error?) -> Void)) -> RequestTask {
        return syncConfluenceWithRequestBuilder(syncFilesRequest: syncFilesRequest).execute(apiResponseQueue) { result in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Confluence Sync
     
     - parameter syncFilesRequest: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    private class func syncConfluenceAsyncMappedParams(syncFilesRequest: SyncFilesRequest) async throws -> GenericSuccessResponse {
        return try await withCheckedThrowingContinuation { continuation in
            syncConfluenceWithRequestBuilder(syncFilesRequest: syncFilesRequest).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }

    /**
     Confluence Sync
     
     - parameter syncFilesRequest: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    open class func syncConfluence(
        dataSourceId: Int,
        ids: IdsProperty,
        tags: AnyCodable? = nil, 
        chunkSize: Int? = nil, 
        chunkOverlap: Int? = nil, 
        skipEmbeddingGeneration: Bool? = nil, 
        embeddingModel: EmbeddingGeneratorsNullable? = nil, 
        generateSparseVectors: Bool? = nil, 
        prependFilenameToChunks: Bool? = nil, 
        maxItemsPerChunk: Int? = nil, 
        setPageAsBoundary: Bool? = nil, 
        requestId: String? = nil
    ) async throws -> GenericSuccessResponse {
        let syncFilesRequest = SyncFilesRequest(
            tags: tags,
            dataSourceId: dataSourceId,
            ids: ids,
            chunkSize: chunkSize,
            chunkOverlap: chunkOverlap,
            skipEmbeddingGeneration: skipEmbeddingGeneration,
            embeddingModel: embeddingModel,
            generateSparseVectors: generateSparseVectors,
            prependFilenameToChunks: prependFilenameToChunks,
            maxItemsPerChunk: maxItemsPerChunk,
            setPageAsBoundary: setPageAsBoundary,
            requestId: requestId
        )
        return try await withCheckedThrowingContinuation { continuation in
            syncConfluenceWithRequestBuilder(syncFilesRequest: syncFilesRequest).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    /**
     Confluence Sync
     
     - parameter syncFilesRequest: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    open func syncConfluence(
        dataSourceId: Int,
        ids: IdsProperty,
        tags: AnyCodable? = nil, 
        chunkSize: Int? = nil, 
        chunkOverlap: Int? = nil, 
        skipEmbeddingGeneration: Bool? = nil, 
        embeddingModel: EmbeddingGeneratorsNullable? = nil, 
        generateSparseVectors: Bool? = nil, 
        prependFilenameToChunks: Bool? = nil, 
        maxItemsPerChunk: Int? = nil, 
        setPageAsBoundary: Bool? = nil, 
        requestId: String? = nil
    ) async throws -> GenericSuccessResponse {
        let syncFilesRequest = SyncFilesRequest(
            tags: tags,
            dataSourceId: dataSourceId,
            ids: ids,
            chunkSize: chunkSize,
            chunkOverlap: chunkOverlap,
            skipEmbeddingGeneration: skipEmbeddingGeneration,
            embeddingModel: embeddingModel,
            generateSparseVectors: generateSparseVectors,
            prependFilenameToChunks: prependFilenameToChunks,
            maxItemsPerChunk: maxItemsPerChunk,
            setPageAsBoundary: setPageAsBoundary,
            requestId: requestId
        )
        return try await withCheckedThrowingContinuation { continuation in
            syncConfluenceWithRequestBuilder(syncFilesRequest: syncFilesRequest).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }



    /**
     Confluence Sync
     - POST /integrations/confluence/sync
     - After listing pages in a user's Confluence account, the set of selected page `ids` and the connected account's `data_source_id` can be passed into this endpoint to sync them into Carbon. Additional parameters listed below can be used to associate data to the selected pages or alter the behavior of the sync.
     - API Key:
       - type: apiKey authorization 
       - name: accessToken
     - API Key:
       - type: apiKey authorization 
       - name: apiKey
     - API Key:
       - type: apiKey customer-id 
       - name: customerId
     - parameter syncFilesRequest: (body)  
     - returns: RequestBuilder<GenericSuccessResponse> 
     */
    open class func syncConfluenceWithRequestBuilder(
            syncFilesRequest: SyncFilesRequest
    ) -> RequestBuilder<GenericSuccessResponse> {
        let basePath = CarbonAPI.basePath;
        let localVariablePath = "/integrations/confluence/sync"
        let localVariableURLString = basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: syncFilesRequest)

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        var localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        do {
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: CarbonAPI.accessToken, prefix: "Token ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: CarbonAPI.apiKey, prefix: "Bearer ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "customer-id", value: CarbonAPI.customerId, prefix: nil)
            let localVariableRequestBuilder: RequestBuilder<GenericSuccessResponse>.Type = CarbonAPI.requestBuilderFactory.getBuilder()
            let URLString = localVariableUrlComponents?.string ?? localVariableURLString
            return localVariableRequestBuilder.init(method: "POST", URLString: URLString, parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
        } catch {
            print("Error: \(error)")
        }
        fatalError("Error: Unable to send request to POST /integrations/confluence/sync")
    }

    /**
     Confluence Sync
     - POST /integrations/confluence/sync
     - After listing pages in a user's Confluence account, the set of selected page `ids` and the connected account's `data_source_id` can be passed into this endpoint to sync them into Carbon. Additional parameters listed below can be used to associate data to the selected pages or alter the behavior of the sync.
     - API Key:
       - type: apiKey authorization 
       - name: accessToken
     - API Key:
       - type: apiKey authorization 
       - name: apiKey
     - API Key:
       - type: apiKey customer-id 
       - name: customerId
     - parameter syncFilesRequest: (body)  
     - returns: RequestBuilder<GenericSuccessResponse> 
     */
    open func syncConfluenceWithRequestBuilder(
            syncFilesRequest: SyncFilesRequest
    ) -> RequestBuilder<GenericSuccessResponse> {
        let basePath = self.client.basePath;
        let localVariablePath = "/integrations/confluence/sync"
        let localVariableURLString = basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: syncFilesRequest)

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        var localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        do {
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: self.client.accessToken, prefix: "Token ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: self.client.apiKey, prefix: "Bearer ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "customer-id", value: self.client.customerId, prefix: nil)
            let localVariableRequestBuilder: RequestBuilder<GenericSuccessResponse>.Type = CarbonAPI.requestBuilderFactory.getBuilder()
            let URLString = localVariableUrlComponents?.string ?? localVariableURLString
            return localVariableRequestBuilder.init(method: "POST", URLString: URLString, parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
        } catch {
            print("Error: \(error)")
        }
        fatalError("Error: Unable to send request to POST /integrations/confluence/sync")
    }


    /**
     Sync Data Source Items
     
     - parameter syncDirectoryRequest: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @discardableResult
    open class func syncDataSourceItemsSync(syncDirectoryRequest: SyncDirectoryRequest, apiResponseQueue: DispatchQueue = CarbonAPI.apiResponseQueue, completion: @escaping ((_ data: OrganizationUserDataSourceAPI?, _ error: Error?) -> Void)) -> RequestTask {
        return syncDataSourceItemsWithRequestBuilder(syncDirectoryRequest: syncDirectoryRequest).execute(apiResponseQueue) { result in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Sync Data Source Items
     
     - parameter syncDirectoryRequest: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    private class func syncDataSourceItemsAsyncMappedParams(syncDirectoryRequest: SyncDirectoryRequest) async throws -> OrganizationUserDataSourceAPI {
        return try await withCheckedThrowingContinuation { continuation in
            syncDataSourceItemsWithRequestBuilder(syncDirectoryRequest: syncDirectoryRequest).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }

    /**
     Sync Data Source Items
     
     - parameter syncDirectoryRequest: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    open class func syncDataSourceItems(
        dataSourceId: Int
    ) async throws -> OrganizationUserDataSourceAPI {
        let syncDirectoryRequest = SyncDirectoryRequest(
            dataSourceId: dataSourceId
        )
        return try await withCheckedThrowingContinuation { continuation in
            syncDataSourceItemsWithRequestBuilder(syncDirectoryRequest: syncDirectoryRequest).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    /**
     Sync Data Source Items
     
     - parameter syncDirectoryRequest: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    open func syncDataSourceItems(
        dataSourceId: Int
    ) async throws -> OrganizationUserDataSourceAPI {
        let syncDirectoryRequest = SyncDirectoryRequest(
            dataSourceId: dataSourceId
        )
        return try await withCheckedThrowingContinuation { continuation in
            syncDataSourceItemsWithRequestBuilder(syncDirectoryRequest: syncDirectoryRequest).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }



    /**
     Sync Data Source Items
     - POST /integrations/items/sync
     - API Key:
       - type: apiKey authorization 
       - name: accessToken
     - API Key:
       - type: apiKey authorization 
       - name: apiKey
     - API Key:
       - type: apiKey customer-id 
       - name: customerId
     - parameter syncDirectoryRequest: (body)  
     - returns: RequestBuilder<OrganizationUserDataSourceAPI> 
     */
    open class func syncDataSourceItemsWithRequestBuilder(
            syncDirectoryRequest: SyncDirectoryRequest
    ) -> RequestBuilder<OrganizationUserDataSourceAPI> {
        let basePath = CarbonAPI.basePath;
        let localVariablePath = "/integrations/items/sync"
        let localVariableURLString = basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: syncDirectoryRequest)

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        var localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        do {
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: CarbonAPI.accessToken, prefix: "Token ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: CarbonAPI.apiKey, prefix: "Bearer ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "customer-id", value: CarbonAPI.customerId, prefix: nil)
            let localVariableRequestBuilder: RequestBuilder<OrganizationUserDataSourceAPI>.Type = CarbonAPI.requestBuilderFactory.getBuilder()
            let URLString = localVariableUrlComponents?.string ?? localVariableURLString
            return localVariableRequestBuilder.init(method: "POST", URLString: URLString, parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
        } catch {
            print("Error: \(error)")
        }
        fatalError("Error: Unable to send request to POST /integrations/items/sync")
    }

    /**
     Sync Data Source Items
     - POST /integrations/items/sync
     - API Key:
       - type: apiKey authorization 
       - name: accessToken
     - API Key:
       - type: apiKey authorization 
       - name: apiKey
     - API Key:
       - type: apiKey customer-id 
       - name: customerId
     - parameter syncDirectoryRequest: (body)  
     - returns: RequestBuilder<OrganizationUserDataSourceAPI> 
     */
    open func syncDataSourceItemsWithRequestBuilder(
            syncDirectoryRequest: SyncDirectoryRequest
    ) -> RequestBuilder<OrganizationUserDataSourceAPI> {
        let basePath = self.client.basePath;
        let localVariablePath = "/integrations/items/sync"
        let localVariableURLString = basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: syncDirectoryRequest)

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        var localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        do {
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: self.client.accessToken, prefix: "Token ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: self.client.apiKey, prefix: "Bearer ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "customer-id", value: self.client.customerId, prefix: nil)
            let localVariableRequestBuilder: RequestBuilder<OrganizationUserDataSourceAPI>.Type = CarbonAPI.requestBuilderFactory.getBuilder()
            let URLString = localVariableUrlComponents?.string ?? localVariableURLString
            return localVariableRequestBuilder.init(method: "POST", URLString: URLString, parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
        } catch {
            print("Error: \(error)")
        }
        fatalError("Error: Unable to send request to POST /integrations/items/sync")
    }


    /**
     Sync Files
     
     - parameter syncFilesRequest: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @discardableResult
    open class func syncFilesSync(syncFilesRequest: SyncFilesRequest, apiResponseQueue: DispatchQueue = CarbonAPI.apiResponseQueue, completion: @escaping ((_ data: GenericSuccessResponse?, _ error: Error?) -> Void)) -> RequestTask {
        return syncFilesWithRequestBuilder(syncFilesRequest: syncFilesRequest).execute(apiResponseQueue) { result in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Sync Files
     
     - parameter syncFilesRequest: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    private class func syncFilesAsyncMappedParams(syncFilesRequest: SyncFilesRequest) async throws -> GenericSuccessResponse {
        return try await withCheckedThrowingContinuation { continuation in
            syncFilesWithRequestBuilder(syncFilesRequest: syncFilesRequest).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }

    /**
     Sync Files
     
     - parameter syncFilesRequest: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    open class func syncFiles(
        dataSourceId: Int,
        ids: IdsProperty,
        tags: AnyCodable? = nil, 
        chunkSize: Int? = nil, 
        chunkOverlap: Int? = nil, 
        skipEmbeddingGeneration: Bool? = nil, 
        embeddingModel: EmbeddingGeneratorsNullable? = nil, 
        generateSparseVectors: Bool? = nil, 
        prependFilenameToChunks: Bool? = nil, 
        maxItemsPerChunk: Int? = nil, 
        setPageAsBoundary: Bool? = nil, 
        requestId: String? = nil
    ) async throws -> GenericSuccessResponse {
        let syncFilesRequest = SyncFilesRequest(
            tags: tags,
            dataSourceId: dataSourceId,
            ids: ids,
            chunkSize: chunkSize,
            chunkOverlap: chunkOverlap,
            skipEmbeddingGeneration: skipEmbeddingGeneration,
            embeddingModel: embeddingModel,
            generateSparseVectors: generateSparseVectors,
            prependFilenameToChunks: prependFilenameToChunks,
            maxItemsPerChunk: maxItemsPerChunk,
            setPageAsBoundary: setPageAsBoundary,
            requestId: requestId
        )
        return try await withCheckedThrowingContinuation { continuation in
            syncFilesWithRequestBuilder(syncFilesRequest: syncFilesRequest).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    /**
     Sync Files
     
     - parameter syncFilesRequest: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    open func syncFiles(
        dataSourceId: Int,
        ids: IdsProperty,
        tags: AnyCodable? = nil, 
        chunkSize: Int? = nil, 
        chunkOverlap: Int? = nil, 
        skipEmbeddingGeneration: Bool? = nil, 
        embeddingModel: EmbeddingGeneratorsNullable? = nil, 
        generateSparseVectors: Bool? = nil, 
        prependFilenameToChunks: Bool? = nil, 
        maxItemsPerChunk: Int? = nil, 
        setPageAsBoundary: Bool? = nil, 
        requestId: String? = nil
    ) async throws -> GenericSuccessResponse {
        let syncFilesRequest = SyncFilesRequest(
            tags: tags,
            dataSourceId: dataSourceId,
            ids: ids,
            chunkSize: chunkSize,
            chunkOverlap: chunkOverlap,
            skipEmbeddingGeneration: skipEmbeddingGeneration,
            embeddingModel: embeddingModel,
            generateSparseVectors: generateSparseVectors,
            prependFilenameToChunks: prependFilenameToChunks,
            maxItemsPerChunk: maxItemsPerChunk,
            setPageAsBoundary: setPageAsBoundary,
            requestId: requestId
        )
        return try await withCheckedThrowingContinuation { continuation in
            syncFilesWithRequestBuilder(syncFilesRequest: syncFilesRequest).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }



    /**
     Sync Files
     - POST /integrations/files/sync
     - After listing files and folders via /integrations/items/sync and integrations/items/list, use the selected items' external ids  as the ids in this endpoint to sync them into Carbon. Sharepoint items take an additional parameter root_id, which identifies the drive the file or folder is in and is stored in root_external_id. That additional paramter is optional and excluding it will tell the sync to assume the item is stored in the default Documents drive.
     - API Key:
       - type: apiKey authorization 
       - name: accessToken
     - API Key:
       - type: apiKey authorization 
       - name: apiKey
     - API Key:
       - type: apiKey customer-id 
       - name: customerId
     - parameter syncFilesRequest: (body)  
     - returns: RequestBuilder<GenericSuccessResponse> 
     */
    open class func syncFilesWithRequestBuilder(
            syncFilesRequest: SyncFilesRequest
    ) -> RequestBuilder<GenericSuccessResponse> {
        let basePath = CarbonAPI.basePath;
        let localVariablePath = "/integrations/files/sync"
        let localVariableURLString = basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: syncFilesRequest)

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        var localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        do {
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: CarbonAPI.accessToken, prefix: "Token ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: CarbonAPI.apiKey, prefix: "Bearer ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "customer-id", value: CarbonAPI.customerId, prefix: nil)
            let localVariableRequestBuilder: RequestBuilder<GenericSuccessResponse>.Type = CarbonAPI.requestBuilderFactory.getBuilder()
            let URLString = localVariableUrlComponents?.string ?? localVariableURLString
            return localVariableRequestBuilder.init(method: "POST", URLString: URLString, parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
        } catch {
            print("Error: \(error)")
        }
        fatalError("Error: Unable to send request to POST /integrations/files/sync")
    }

    /**
     Sync Files
     - POST /integrations/files/sync
     - After listing files and folders via /integrations/items/sync and integrations/items/list, use the selected items' external ids  as the ids in this endpoint to sync them into Carbon. Sharepoint items take an additional parameter root_id, which identifies the drive the file or folder is in and is stored in root_external_id. That additional paramter is optional and excluding it will tell the sync to assume the item is stored in the default Documents drive.
     - API Key:
       - type: apiKey authorization 
       - name: accessToken
     - API Key:
       - type: apiKey authorization 
       - name: apiKey
     - API Key:
       - type: apiKey customer-id 
       - name: customerId
     - parameter syncFilesRequest: (body)  
     - returns: RequestBuilder<GenericSuccessResponse> 
     */
    open func syncFilesWithRequestBuilder(
            syncFilesRequest: SyncFilesRequest
    ) -> RequestBuilder<GenericSuccessResponse> {
        let basePath = self.client.basePath;
        let localVariablePath = "/integrations/files/sync"
        let localVariableURLString = basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: syncFilesRequest)

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        var localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        do {
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: self.client.accessToken, prefix: "Token ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: self.client.apiKey, prefix: "Bearer ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "customer-id", value: self.client.customerId, prefix: nil)
            let localVariableRequestBuilder: RequestBuilder<GenericSuccessResponse>.Type = CarbonAPI.requestBuilderFactory.getBuilder()
            let URLString = localVariableUrlComponents?.string ?? localVariableURLString
            return localVariableRequestBuilder.init(method: "POST", URLString: URLString, parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
        } catch {
            print("Error: \(error)")
        }
        fatalError("Error: Unable to send request to POST /integrations/files/sync")
    }


    /**
     Gitbook Sync
     
     - parameter gitbookSyncRequest: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @discardableResult
    open class func syncGitbookSync(gitbookSyncRequest: GitbookSyncRequest, apiResponseQueue: DispatchQueue = CarbonAPI.apiResponseQueue, completion: @escaping ((_ data: AnyCodable?, _ error: Error?) -> Void)) -> RequestTask {
        return syncGitbookWithRequestBuilder(gitbookSyncRequest: gitbookSyncRequest).execute(apiResponseQueue) { result in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Gitbook Sync
     
     - parameter gitbookSyncRequest: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    private class func syncGitbookAsyncMappedParams(gitbookSyncRequest: GitbookSyncRequest) async throws -> AnyCodable {
        return try await withCheckedThrowingContinuation { continuation in
            syncGitbookWithRequestBuilder(gitbookSyncRequest: gitbookSyncRequest).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }

    /**
     Gitbook Sync
     
     - parameter gitbookSyncRequest: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    open class func syncGitbook(
        spaceIds: [String],
        dataSourceId: Int,
        tags: AnyCodable? = nil, 
        chunkSize: Int? = nil, 
        chunkOverlap: Int? = nil, 
        skipEmbeddingGeneration: Bool? = nil, 
        embeddingModel: EmbeddingGenerators? = nil, 
        generateSparseVectors: Bool? = nil, 
        prependFilenameToChunks: Bool? = nil, 
        requestId: String? = nil
    ) async throws -> AnyCodable {
        let gitbookSyncRequest = GitbookSyncRequest(
            tags: tags,
            spaceIds: spaceIds,
            dataSourceId: dataSourceId,
            chunkSize: chunkSize,
            chunkOverlap: chunkOverlap,
            skipEmbeddingGeneration: skipEmbeddingGeneration,
            embeddingModel: embeddingModel,
            generateSparseVectors: generateSparseVectors,
            prependFilenameToChunks: prependFilenameToChunks,
            requestId: requestId
        )
        return try await withCheckedThrowingContinuation { continuation in
            syncGitbookWithRequestBuilder(gitbookSyncRequest: gitbookSyncRequest).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    /**
     Gitbook Sync
     
     - parameter gitbookSyncRequest: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    open func syncGitbook(
        spaceIds: [String],
        dataSourceId: Int,
        tags: AnyCodable? = nil, 
        chunkSize: Int? = nil, 
        chunkOverlap: Int? = nil, 
        skipEmbeddingGeneration: Bool? = nil, 
        embeddingModel: EmbeddingGenerators? = nil, 
        generateSparseVectors: Bool? = nil, 
        prependFilenameToChunks: Bool? = nil, 
        requestId: String? = nil
    ) async throws -> AnyCodable {
        let gitbookSyncRequest = GitbookSyncRequest(
            tags: tags,
            spaceIds: spaceIds,
            dataSourceId: dataSourceId,
            chunkSize: chunkSize,
            chunkOverlap: chunkOverlap,
            skipEmbeddingGeneration: skipEmbeddingGeneration,
            embeddingModel: embeddingModel,
            generateSparseVectors: generateSparseVectors,
            prependFilenameToChunks: prependFilenameToChunks,
            requestId: requestId
        )
        return try await withCheckedThrowingContinuation { continuation in
            syncGitbookWithRequestBuilder(gitbookSyncRequest: gitbookSyncRequest).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }



    /**
     Gitbook Sync
     - POST /integrations/gitbook/sync
     - You can sync upto 20 Gitbook spaces at a time using this endpoint. Additional parameters below can be used to associate  data with the synced pages or modify the sync behavior.
     - API Key:
       - type: apiKey authorization 
       - name: accessToken
     - API Key:
       - type: apiKey authorization 
       - name: apiKey
     - API Key:
       - type: apiKey customer-id 
       - name: customerId
     - parameter gitbookSyncRequest: (body)  
     - returns: RequestBuilder<AnyCodable> 
     */
    open class func syncGitbookWithRequestBuilder(
            gitbookSyncRequest: GitbookSyncRequest
    ) -> RequestBuilder<AnyCodable> {
        let basePath = CarbonAPI.basePath;
        let localVariablePath = "/integrations/gitbook/sync"
        let localVariableURLString = basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: gitbookSyncRequest)

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        var localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        do {
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: CarbonAPI.accessToken, prefix: "Token ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: CarbonAPI.apiKey, prefix: "Bearer ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "customer-id", value: CarbonAPI.customerId, prefix: nil)
            let localVariableRequestBuilder: RequestBuilder<AnyCodable>.Type = CarbonAPI.requestBuilderFactory.getBuilder()
            let URLString = localVariableUrlComponents?.string ?? localVariableURLString
            return localVariableRequestBuilder.init(method: "POST", URLString: URLString, parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
        } catch {
            print("Error: \(error)")
        }
        fatalError("Error: Unable to send request to POST /integrations/gitbook/sync")
    }

    /**
     Gitbook Sync
     - POST /integrations/gitbook/sync
     - You can sync upto 20 Gitbook spaces at a time using this endpoint. Additional parameters below can be used to associate  data with the synced pages or modify the sync behavior.
     - API Key:
       - type: apiKey authorization 
       - name: accessToken
     - API Key:
       - type: apiKey authorization 
       - name: apiKey
     - API Key:
       - type: apiKey customer-id 
       - name: customerId
     - parameter gitbookSyncRequest: (body)  
     - returns: RequestBuilder<AnyCodable> 
     */
    open func syncGitbookWithRequestBuilder(
            gitbookSyncRequest: GitbookSyncRequest
    ) -> RequestBuilder<AnyCodable> {
        let basePath = self.client.basePath;
        let localVariablePath = "/integrations/gitbook/sync"
        let localVariableURLString = basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: gitbookSyncRequest)

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        var localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        do {
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: self.client.accessToken, prefix: "Token ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: self.client.apiKey, prefix: "Bearer ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "customer-id", value: self.client.customerId, prefix: nil)
            let localVariableRequestBuilder: RequestBuilder<AnyCodable>.Type = CarbonAPI.requestBuilderFactory.getBuilder()
            let URLString = localVariableUrlComponents?.string ?? localVariableURLString
            return localVariableRequestBuilder.init(method: "POST", URLString: URLString, parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
        } catch {
            print("Error: \(error)")
        }
        fatalError("Error: Unable to send request to POST /integrations/gitbook/sync")
    }


    /**
     Gmail Sync
     
     - parameter gmailSyncInput: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @discardableResult
    open class func syncGmailSync(gmailSyncInput: GmailSyncInput, apiResponseQueue: DispatchQueue = CarbonAPI.apiResponseQueue, completion: @escaping ((_ data: GenericSuccessResponse?, _ error: Error?) -> Void)) -> RequestTask {
        return syncGmailWithRequestBuilder(gmailSyncInput: gmailSyncInput).execute(apiResponseQueue) { result in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Gmail Sync
     
     - parameter gmailSyncInput: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    private class func syncGmailAsyncMappedParams(gmailSyncInput: GmailSyncInput) async throws -> GenericSuccessResponse {
        return try await withCheckedThrowingContinuation { continuation in
            syncGmailWithRequestBuilder(gmailSyncInput: gmailSyncInput).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }

    /**
     Gmail Sync
     
     - parameter gmailSyncInput: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    open class func syncGmail(
        filters: AnyCodable,
        tags: AnyCodable? = nil, 
        chunkSize: Int? = nil, 
        chunkOverlap: Int? = nil, 
        skipEmbeddingGeneration: Bool? = nil, 
        embeddingModel: EmbeddingGenerators? = nil, 
        generateSparseVectors: Bool? = nil, 
        prependFilenameToChunks: Bool? = nil, 
        dataSourceId: Int? = nil, 
        requestId: String? = nil
    ) async throws -> GenericSuccessResponse {
        let gmailSyncInput = GmailSyncInput(
            tags: tags,
            filters: filters,
            chunkSize: chunkSize,
            chunkOverlap: chunkOverlap,
            skipEmbeddingGeneration: skipEmbeddingGeneration,
            embeddingModel: embeddingModel,
            generateSparseVectors: generateSparseVectors,
            prependFilenameToChunks: prependFilenameToChunks,
            dataSourceId: dataSourceId,
            requestId: requestId
        )
        return try await withCheckedThrowingContinuation { continuation in
            syncGmailWithRequestBuilder(gmailSyncInput: gmailSyncInput).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    /**
     Gmail Sync
     
     - parameter gmailSyncInput: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    open func syncGmail(
        filters: AnyCodable,
        tags: AnyCodable? = nil, 
        chunkSize: Int? = nil, 
        chunkOverlap: Int? = nil, 
        skipEmbeddingGeneration: Bool? = nil, 
        embeddingModel: EmbeddingGenerators? = nil, 
        generateSparseVectors: Bool? = nil, 
        prependFilenameToChunks: Bool? = nil, 
        dataSourceId: Int? = nil, 
        requestId: String? = nil
    ) async throws -> GenericSuccessResponse {
        let gmailSyncInput = GmailSyncInput(
            tags: tags,
            filters: filters,
            chunkSize: chunkSize,
            chunkOverlap: chunkOverlap,
            skipEmbeddingGeneration: skipEmbeddingGeneration,
            embeddingModel: embeddingModel,
            generateSparseVectors: generateSparseVectors,
            prependFilenameToChunks: prependFilenameToChunks,
            dataSourceId: dataSourceId,
            requestId: requestId
        )
        return try await withCheckedThrowingContinuation { continuation in
            syncGmailWithRequestBuilder(gmailSyncInput: gmailSyncInput).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }



    /**
     Gmail Sync
     - POST /integrations/gmail/sync
     - Once you have successfully connected your gmail account, you can choose which emails to sync with us using the filters parameter. Filters is a JSON object with key value pairs. It also supports AND and OR operations. For now, we support a limited set of keys listed below.  <b>label</b>: Inbuilt Gmail labels, for example \"Important\" or a custom label you created.   <b>after</b> or <b>before</b>: A date in YYYY/mm/dd format (example 2023/12/31). Gets emails after/before a certain date. You can also use them in combination to get emails from a certain period.   <b>is</b>: Can have the following values - starred, important, snoozed, and unread    Using keys or values outside of the specified values can lead to unexpected behaviour.  An example of a basic query with filters can be ```json {     \"filters\": {             \"key\": \"label\",             \"value\": \"Test\"         } } ``` Which will list all emails that have the label \"Test\".  You can use AND and OR operation in the following way: ```json {     \"filters\": {         \"AND\": [             {                 \"key\": \"after\",                 \"value\": \"2024/01/07\"             },             {                 \"OR\": [                     {                         \"key\": \"label\",                         \"value\": \"Personal\"                     },                     {                         \"key\": \"is\",                         \"value\": \"starred\"                     }                 ]             }         ]     } } ``` This will return emails after 7th of Jan that are either starred or have the label \"Personal\".  Note that this is the highest level of nesting we support, i.e. you can't add more AND/OR filters within the OR filter in the above example.
     - API Key:
       - type: apiKey authorization 
       - name: accessToken
     - API Key:
       - type: apiKey authorization 
       - name: apiKey
     - API Key:
       - type: apiKey customer-id 
       - name: customerId
     - parameter gmailSyncInput: (body)  
     - returns: RequestBuilder<GenericSuccessResponse> 
     */
    open class func syncGmailWithRequestBuilder(
            gmailSyncInput: GmailSyncInput
    ) -> RequestBuilder<GenericSuccessResponse> {
        let basePath = CarbonAPI.basePath;
        let localVariablePath = "/integrations/gmail/sync"
        let localVariableURLString = basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: gmailSyncInput)

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        var localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        do {
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: CarbonAPI.accessToken, prefix: "Token ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: CarbonAPI.apiKey, prefix: "Bearer ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "customer-id", value: CarbonAPI.customerId, prefix: nil)
            let localVariableRequestBuilder: RequestBuilder<GenericSuccessResponse>.Type = CarbonAPI.requestBuilderFactory.getBuilder()
            let URLString = localVariableUrlComponents?.string ?? localVariableURLString
            return localVariableRequestBuilder.init(method: "POST", URLString: URLString, parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
        } catch {
            print("Error: \(error)")
        }
        fatalError("Error: Unable to send request to POST /integrations/gmail/sync")
    }

    /**
     Gmail Sync
     - POST /integrations/gmail/sync
     - Once you have successfully connected your gmail account, you can choose which emails to sync with us using the filters parameter. Filters is a JSON object with key value pairs. It also supports AND and OR operations. For now, we support a limited set of keys listed below.  <b>label</b>: Inbuilt Gmail labels, for example \"Important\" or a custom label you created.   <b>after</b> or <b>before</b>: A date in YYYY/mm/dd format (example 2023/12/31). Gets emails after/before a certain date. You can also use them in combination to get emails from a certain period.   <b>is</b>: Can have the following values - starred, important, snoozed, and unread    Using keys or values outside of the specified values can lead to unexpected behaviour.  An example of a basic query with filters can be ```json {     \"filters\": {             \"key\": \"label\",             \"value\": \"Test\"         } } ``` Which will list all emails that have the label \"Test\".  You can use AND and OR operation in the following way: ```json {     \"filters\": {         \"AND\": [             {                 \"key\": \"after\",                 \"value\": \"2024/01/07\"             },             {                 \"OR\": [                     {                         \"key\": \"label\",                         \"value\": \"Personal\"                     },                     {                         \"key\": \"is\",                         \"value\": \"starred\"                     }                 ]             }         ]     } } ``` This will return emails after 7th of Jan that are either starred or have the label \"Personal\".  Note that this is the highest level of nesting we support, i.e. you can't add more AND/OR filters within the OR filter in the above example.
     - API Key:
       - type: apiKey authorization 
       - name: accessToken
     - API Key:
       - type: apiKey authorization 
       - name: apiKey
     - API Key:
       - type: apiKey customer-id 
       - name: customerId
     - parameter gmailSyncInput: (body)  
     - returns: RequestBuilder<GenericSuccessResponse> 
     */
    open func syncGmailWithRequestBuilder(
            gmailSyncInput: GmailSyncInput
    ) -> RequestBuilder<GenericSuccessResponse> {
        let basePath = self.client.basePath;
        let localVariablePath = "/integrations/gmail/sync"
        let localVariableURLString = basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: gmailSyncInput)

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        var localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        do {
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: self.client.accessToken, prefix: "Token ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: self.client.apiKey, prefix: "Bearer ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "customer-id", value: self.client.customerId, prefix: nil)
            let localVariableRequestBuilder: RequestBuilder<GenericSuccessResponse>.Type = CarbonAPI.requestBuilderFactory.getBuilder()
            let URLString = localVariableUrlComponents?.string ?? localVariableURLString
            return localVariableRequestBuilder.init(method: "POST", URLString: URLString, parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
        } catch {
            print("Error: \(error)")
        }
        fatalError("Error: Unable to send request to POST /integrations/gmail/sync")
    }


    /**
     Outlook Sync
     
     - parameter outlookSyncInput: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @discardableResult
    open class func syncOutlookSync(outlookSyncInput: OutlookSyncInput, apiResponseQueue: DispatchQueue = CarbonAPI.apiResponseQueue, completion: @escaping ((_ data: GenericSuccessResponse?, _ error: Error?) -> Void)) -> RequestTask {
        return syncOutlookWithRequestBuilder(outlookSyncInput: outlookSyncInput).execute(apiResponseQueue) { result in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Outlook Sync
     
     - parameter outlookSyncInput: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    private class func syncOutlookAsyncMappedParams(outlookSyncInput: OutlookSyncInput) async throws -> GenericSuccessResponse {
        return try await withCheckedThrowingContinuation { continuation in
            syncOutlookWithRequestBuilder(outlookSyncInput: outlookSyncInput).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }

    /**
     Outlook Sync
     
     - parameter outlookSyncInput: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    open class func syncOutlook(
        filters: AnyCodable,
        tags: AnyCodable? = nil, 
        folder: String? = nil, 
        chunkSize: Int? = nil, 
        chunkOverlap: Int? = nil, 
        skipEmbeddingGeneration: Bool? = nil, 
        embeddingModel: EmbeddingGenerators? = nil, 
        generateSparseVectors: Bool? = nil, 
        prependFilenameToChunks: Bool? = nil, 
        dataSourceId: Int? = nil, 
        requestId: String? = nil
    ) async throws -> GenericSuccessResponse {
        let outlookSyncInput = OutlookSyncInput(
            tags: tags,
            folder: folder,
            filters: filters,
            chunkSize: chunkSize,
            chunkOverlap: chunkOverlap,
            skipEmbeddingGeneration: skipEmbeddingGeneration,
            embeddingModel: embeddingModel,
            generateSparseVectors: generateSparseVectors,
            prependFilenameToChunks: prependFilenameToChunks,
            dataSourceId: dataSourceId,
            requestId: requestId
        )
        return try await withCheckedThrowingContinuation { continuation in
            syncOutlookWithRequestBuilder(outlookSyncInput: outlookSyncInput).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    /**
     Outlook Sync
     
     - parameter outlookSyncInput: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    open func syncOutlook(
        filters: AnyCodable,
        tags: AnyCodable? = nil, 
        folder: String? = nil, 
        chunkSize: Int? = nil, 
        chunkOverlap: Int? = nil, 
        skipEmbeddingGeneration: Bool? = nil, 
        embeddingModel: EmbeddingGenerators? = nil, 
        generateSparseVectors: Bool? = nil, 
        prependFilenameToChunks: Bool? = nil, 
        dataSourceId: Int? = nil, 
        requestId: String? = nil
    ) async throws -> GenericSuccessResponse {
        let outlookSyncInput = OutlookSyncInput(
            tags: tags,
            folder: folder,
            filters: filters,
            chunkSize: chunkSize,
            chunkOverlap: chunkOverlap,
            skipEmbeddingGeneration: skipEmbeddingGeneration,
            embeddingModel: embeddingModel,
            generateSparseVectors: generateSparseVectors,
            prependFilenameToChunks: prependFilenameToChunks,
            dataSourceId: dataSourceId,
            requestId: requestId
        )
        return try await withCheckedThrowingContinuation { continuation in
            syncOutlookWithRequestBuilder(outlookSyncInput: outlookSyncInput).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }



    /**
     Outlook Sync
     - POST /integrations/outlook/sync
     - Once you have successfully connected your Outlook account, you can choose which emails to sync with us using the filters and folder parameter. \"folder\" should be the folder you want to sync from Outlook. By default we get messages from your inbox folder.   Filters is a JSON object with key value pairs. It also supports AND and OR operations. For now, we support a limited set of keys listed below.  <b>category</b>: Custom categories that you created in Outlook.   <b>after</b> or <b>before</b>: A date in YYYY/mm/dd format (example 2023/12/31). Gets emails after/before a certain date. You can also use them in combination to get emails from a certain period.     <b>is</b>: Can have the following values: flagged     An example of a basic query with filters can be ```json {     \"filters\": {             \"key\": \"category\",             \"value\": \"Test\"         } } ``` Which will list all emails that have the category \"Test\".    Specifying a custom folder in the same query ```json {     \"folder\": \"Folder Name\",     \"filters\": {             \"key\": \"category\",             \"value\": \"Test\"         } } ```  You can use AND and OR operation in the following way: ```json {     \"filters\": {         \"AND\": [             {                 \"key\": \"after\",                 \"value\": \"2024/01/07\"             },             {                 \"OR\": [                     {                         \"key\": \"category\",                         \"value\": \"Personal\"                     },                     {                         \"key\": \"category\",                         \"value\": \"Test\"                     },                 ]             }         ]     } } ``` This will return emails after 7th of Jan that have either Personal or Test as category.  Note that this is the highest level of nesting we support, i.e. you can't add more AND/OR filters within the OR filter in the above example.
     - API Key:
       - type: apiKey authorization 
       - name: accessToken
     - API Key:
       - type: apiKey authorization 
       - name: apiKey
     - API Key:
       - type: apiKey customer-id 
       - name: customerId
     - parameter outlookSyncInput: (body)  
     - returns: RequestBuilder<GenericSuccessResponse> 
     */
    open class func syncOutlookWithRequestBuilder(
            outlookSyncInput: OutlookSyncInput
    ) -> RequestBuilder<GenericSuccessResponse> {
        let basePath = CarbonAPI.basePath;
        let localVariablePath = "/integrations/outlook/sync"
        let localVariableURLString = basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: outlookSyncInput)

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        var localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        do {
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: CarbonAPI.accessToken, prefix: "Token ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: CarbonAPI.apiKey, prefix: "Bearer ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "customer-id", value: CarbonAPI.customerId, prefix: nil)
            let localVariableRequestBuilder: RequestBuilder<GenericSuccessResponse>.Type = CarbonAPI.requestBuilderFactory.getBuilder()
            let URLString = localVariableUrlComponents?.string ?? localVariableURLString
            return localVariableRequestBuilder.init(method: "POST", URLString: URLString, parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
        } catch {
            print("Error: \(error)")
        }
        fatalError("Error: Unable to send request to POST /integrations/outlook/sync")
    }

    /**
     Outlook Sync
     - POST /integrations/outlook/sync
     - Once you have successfully connected your Outlook account, you can choose which emails to sync with us using the filters and folder parameter. \"folder\" should be the folder you want to sync from Outlook. By default we get messages from your inbox folder.   Filters is a JSON object with key value pairs. It also supports AND and OR operations. For now, we support a limited set of keys listed below.  <b>category</b>: Custom categories that you created in Outlook.   <b>after</b> or <b>before</b>: A date in YYYY/mm/dd format (example 2023/12/31). Gets emails after/before a certain date. You can also use them in combination to get emails from a certain period.     <b>is</b>: Can have the following values: flagged     An example of a basic query with filters can be ```json {     \"filters\": {             \"key\": \"category\",             \"value\": \"Test\"         } } ``` Which will list all emails that have the category \"Test\".    Specifying a custom folder in the same query ```json {     \"folder\": \"Folder Name\",     \"filters\": {             \"key\": \"category\",             \"value\": \"Test\"         } } ```  You can use AND and OR operation in the following way: ```json {     \"filters\": {         \"AND\": [             {                 \"key\": \"after\",                 \"value\": \"2024/01/07\"             },             {                 \"OR\": [                     {                         \"key\": \"category\",                         \"value\": \"Personal\"                     },                     {                         \"key\": \"category\",                         \"value\": \"Test\"                     },                 ]             }         ]     } } ``` This will return emails after 7th of Jan that have either Personal or Test as category.  Note that this is the highest level of nesting we support, i.e. you can't add more AND/OR filters within the OR filter in the above example.
     - API Key:
       - type: apiKey authorization 
       - name: accessToken
     - API Key:
       - type: apiKey authorization 
       - name: apiKey
     - API Key:
       - type: apiKey customer-id 
       - name: customerId
     - parameter outlookSyncInput: (body)  
     - returns: RequestBuilder<GenericSuccessResponse> 
     */
    open func syncOutlookWithRequestBuilder(
            outlookSyncInput: OutlookSyncInput
    ) -> RequestBuilder<GenericSuccessResponse> {
        let basePath = self.client.basePath;
        let localVariablePath = "/integrations/outlook/sync"
        let localVariableURLString = basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: outlookSyncInput)

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        var localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        do {
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: self.client.accessToken, prefix: "Token ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: self.client.apiKey, prefix: "Bearer ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "customer-id", value: self.client.customerId, prefix: nil)
            let localVariableRequestBuilder: RequestBuilder<GenericSuccessResponse>.Type = CarbonAPI.requestBuilderFactory.getBuilder()
            let URLString = localVariableUrlComponents?.string ?? localVariableURLString
            return localVariableRequestBuilder.init(method: "POST", URLString: URLString, parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
        } catch {
            print("Error: \(error)")
        }
        fatalError("Error: Unable to send request to POST /integrations/outlook/sync")
    }


    /**
     Rss Feed
     
     - parameter rSSFeedInput: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @discardableResult
    open class func syncRssFeedSync(rSSFeedInput: RSSFeedInput, apiResponseQueue: DispatchQueue = CarbonAPI.apiResponseQueue, completion: @escaping ((_ data: GenericSuccessResponse?, _ error: Error?) -> Void)) -> RequestTask {
        return syncRssFeedWithRequestBuilder(rSSFeedInput: rSSFeedInput).execute(apiResponseQueue) { result in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Rss Feed
     
     - parameter rSSFeedInput: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    private class func syncRssFeedAsyncMappedParams(rSSFeedInput: RSSFeedInput) async throws -> GenericSuccessResponse {
        return try await withCheckedThrowingContinuation { continuation in
            syncRssFeedWithRequestBuilder(rSSFeedInput: rSSFeedInput).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }

    /**
     Rss Feed
     
     - parameter rSSFeedInput: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    open class func syncRssFeed(
        url: String,
        tags: AnyCodable? = nil, 
        chunkSize: Int? = nil, 
        chunkOverlap: Int? = nil, 
        skipEmbeddingGeneration: Bool? = nil, 
        embeddingModel: EmbeddingGenerators? = nil, 
        generateSparseVectors: Bool? = nil, 
        prependFilenameToChunks: Bool? = nil, 
        requestId: String? = nil
    ) async throws -> GenericSuccessResponse {
        let rSSFeedInput = RSSFeedInput(
            tags: tags,
            url: url,
            chunkSize: chunkSize,
            chunkOverlap: chunkOverlap,
            skipEmbeddingGeneration: skipEmbeddingGeneration,
            embeddingModel: embeddingModel,
            generateSparseVectors: generateSparseVectors,
            prependFilenameToChunks: prependFilenameToChunks,
            requestId: requestId
        )
        return try await withCheckedThrowingContinuation { continuation in
            syncRssFeedWithRequestBuilder(rSSFeedInput: rSSFeedInput).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    /**
     Rss Feed
     
     - parameter rSSFeedInput: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    open func syncRssFeed(
        url: String,
        tags: AnyCodable? = nil, 
        chunkSize: Int? = nil, 
        chunkOverlap: Int? = nil, 
        skipEmbeddingGeneration: Bool? = nil, 
        embeddingModel: EmbeddingGenerators? = nil, 
        generateSparseVectors: Bool? = nil, 
        prependFilenameToChunks: Bool? = nil, 
        requestId: String? = nil
    ) async throws -> GenericSuccessResponse {
        let rSSFeedInput = RSSFeedInput(
            tags: tags,
            url: url,
            chunkSize: chunkSize,
            chunkOverlap: chunkOverlap,
            skipEmbeddingGeneration: skipEmbeddingGeneration,
            embeddingModel: embeddingModel,
            generateSparseVectors: generateSparseVectors,
            prependFilenameToChunks: prependFilenameToChunks,
            requestId: requestId
        )
        return try await withCheckedThrowingContinuation { continuation in
            syncRssFeedWithRequestBuilder(rSSFeedInput: rSSFeedInput).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }



    /**
     Rss Feed
     - POST /integrations/rss_feed
     - API Key:
       - type: apiKey authorization 
       - name: accessToken
     - API Key:
       - type: apiKey authorization 
       - name: apiKey
     - API Key:
       - type: apiKey customer-id 
       - name: customerId
     - parameter rSSFeedInput: (body)  
     - returns: RequestBuilder<GenericSuccessResponse> 
     */
    open class func syncRssFeedWithRequestBuilder(
            rSSFeedInput: RSSFeedInput
    ) -> RequestBuilder<GenericSuccessResponse> {
        let basePath = CarbonAPI.basePath;
        let localVariablePath = "/integrations/rss_feed"
        let localVariableURLString = basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: rSSFeedInput)

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        var localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        do {
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: CarbonAPI.accessToken, prefix: "Token ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: CarbonAPI.apiKey, prefix: "Bearer ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "customer-id", value: CarbonAPI.customerId, prefix: nil)
            let localVariableRequestBuilder: RequestBuilder<GenericSuccessResponse>.Type = CarbonAPI.requestBuilderFactory.getBuilder()
            let URLString = localVariableUrlComponents?.string ?? localVariableURLString
            return localVariableRequestBuilder.init(method: "POST", URLString: URLString, parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
        } catch {
            print("Error: \(error)")
        }
        fatalError("Error: Unable to send request to POST /integrations/rss_feed")
    }

    /**
     Rss Feed
     - POST /integrations/rss_feed
     - API Key:
       - type: apiKey authorization 
       - name: accessToken
     - API Key:
       - type: apiKey authorization 
       - name: apiKey
     - API Key:
       - type: apiKey customer-id 
       - name: customerId
     - parameter rSSFeedInput: (body)  
     - returns: RequestBuilder<GenericSuccessResponse> 
     */
    open func syncRssFeedWithRequestBuilder(
            rSSFeedInput: RSSFeedInput
    ) -> RequestBuilder<GenericSuccessResponse> {
        let basePath = self.client.basePath;
        let localVariablePath = "/integrations/rss_feed"
        let localVariableURLString = basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: rSSFeedInput)

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        var localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        do {
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: self.client.accessToken, prefix: "Token ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: self.client.apiKey, prefix: "Bearer ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "customer-id", value: self.client.customerId, prefix: nil)
            let localVariableRequestBuilder: RequestBuilder<GenericSuccessResponse>.Type = CarbonAPI.requestBuilderFactory.getBuilder()
            let URLString = localVariableUrlComponents?.string ?? localVariableURLString
            return localVariableRequestBuilder.init(method: "POST", URLString: URLString, parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
        } catch {
            print("Error: \(error)")
        }
        fatalError("Error: Unable to send request to POST /integrations/rss_feed")
    }


    /**
     S3 Files
     
     - parameter s3FileSyncInput: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @discardableResult
    open class func syncS3FilesSync(s3FileSyncInput: S3FileSyncInput, apiResponseQueue: DispatchQueue = CarbonAPI.apiResponseQueue, completion: @escaping ((_ data: GenericSuccessResponse?, _ error: Error?) -> Void)) -> RequestTask {
        return syncS3FilesWithRequestBuilder(s3FileSyncInput: s3FileSyncInput).execute(apiResponseQueue) { result in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     S3 Files
     
     - parameter s3FileSyncInput: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    private class func syncS3FilesAsyncMappedParams(s3FileSyncInput: S3FileSyncInput) async throws -> GenericSuccessResponse {
        return try await withCheckedThrowingContinuation { continuation in
            syncS3FilesWithRequestBuilder(s3FileSyncInput: s3FileSyncInput).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }

    /**
     S3 Files
     
     - parameter s3FileSyncInput: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    open class func syncS3Files(
        ids: [S3GetFileInput],
        tags: AnyCodable? = nil, 
        chunkSize: Int? = nil, 
        chunkOverlap: Int? = nil, 
        skipEmbeddingGeneration: Bool? = nil, 
        embeddingModel: EmbeddingGenerators? = nil, 
        generateSparseVectors: Bool? = nil, 
        prependFilenameToChunks: Bool? = nil, 
        maxItemsPerChunk: Int? = nil, 
        setPageAsBoundary: Bool? = nil, 
        dataSourceId: Int? = nil, 
        requestId: String? = nil
    ) async throws -> GenericSuccessResponse {
        let s3FileSyncInput = S3FileSyncInput(
            tags: tags,
            ids: ids,
            chunkSize: chunkSize,
            chunkOverlap: chunkOverlap,
            skipEmbeddingGeneration: skipEmbeddingGeneration,
            embeddingModel: embeddingModel,
            generateSparseVectors: generateSparseVectors,
            prependFilenameToChunks: prependFilenameToChunks,
            maxItemsPerChunk: maxItemsPerChunk,
            setPageAsBoundary: setPageAsBoundary,
            dataSourceId: dataSourceId,
            requestId: requestId
        )
        return try await withCheckedThrowingContinuation { continuation in
            syncS3FilesWithRequestBuilder(s3FileSyncInput: s3FileSyncInput).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    /**
     S3 Files
     
     - parameter s3FileSyncInput: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    open func syncS3Files(
        ids: [S3GetFileInput],
        tags: AnyCodable? = nil, 
        chunkSize: Int? = nil, 
        chunkOverlap: Int? = nil, 
        skipEmbeddingGeneration: Bool? = nil, 
        embeddingModel: EmbeddingGenerators? = nil, 
        generateSparseVectors: Bool? = nil, 
        prependFilenameToChunks: Bool? = nil, 
        maxItemsPerChunk: Int? = nil, 
        setPageAsBoundary: Bool? = nil, 
        dataSourceId: Int? = nil, 
        requestId: String? = nil
    ) async throws -> GenericSuccessResponse {
        let s3FileSyncInput = S3FileSyncInput(
            tags: tags,
            ids: ids,
            chunkSize: chunkSize,
            chunkOverlap: chunkOverlap,
            skipEmbeddingGeneration: skipEmbeddingGeneration,
            embeddingModel: embeddingModel,
            generateSparseVectors: generateSparseVectors,
            prependFilenameToChunks: prependFilenameToChunks,
            maxItemsPerChunk: maxItemsPerChunk,
            setPageAsBoundary: setPageAsBoundary,
            dataSourceId: dataSourceId,
            requestId: requestId
        )
        return try await withCheckedThrowingContinuation { continuation in
            syncS3FilesWithRequestBuilder(s3FileSyncInput: s3FileSyncInput).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }



    /**
     S3 Files
     - POST /integrations/s3/files
     - After optionally loading the items via /integrations/items/sync and integrations/items/list, use the bucket name  and object key as the ID in this endpoint to sync them into Carbon. Additional parameters below can associate  data with the selected items or modify the sync behavior
     - API Key:
       - type: apiKey authorization 
       - name: accessToken
     - API Key:
       - type: apiKey authorization 
       - name: apiKey
     - API Key:
       - type: apiKey customer-id 
       - name: customerId
     - parameter s3FileSyncInput: (body)  
     - returns: RequestBuilder<GenericSuccessResponse> 
     */
    open class func syncS3FilesWithRequestBuilder(
            s3FileSyncInput: S3FileSyncInput
    ) -> RequestBuilder<GenericSuccessResponse> {
        let basePath = CarbonAPI.basePath;
        let localVariablePath = "/integrations/s3/files"
        let localVariableURLString = basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: s3FileSyncInput)

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        var localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        do {
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: CarbonAPI.accessToken, prefix: "Token ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: CarbonAPI.apiKey, prefix: "Bearer ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "customer-id", value: CarbonAPI.customerId, prefix: nil)
            let localVariableRequestBuilder: RequestBuilder<GenericSuccessResponse>.Type = CarbonAPI.requestBuilderFactory.getBuilder()
            let URLString = localVariableUrlComponents?.string ?? localVariableURLString
            return localVariableRequestBuilder.init(method: "POST", URLString: URLString, parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
        } catch {
            print("Error: \(error)")
        }
        fatalError("Error: Unable to send request to POST /integrations/s3/files")
    }

    /**
     S3 Files
     - POST /integrations/s3/files
     - After optionally loading the items via /integrations/items/sync and integrations/items/list, use the bucket name  and object key as the ID in this endpoint to sync them into Carbon. Additional parameters below can associate  data with the selected items or modify the sync behavior
     - API Key:
       - type: apiKey authorization 
       - name: accessToken
     - API Key:
       - type: apiKey authorization 
       - name: apiKey
     - API Key:
       - type: apiKey customer-id 
       - name: customerId
     - parameter s3FileSyncInput: (body)  
     - returns: RequestBuilder<GenericSuccessResponse> 
     */
    open func syncS3FilesWithRequestBuilder(
            s3FileSyncInput: S3FileSyncInput
    ) -> RequestBuilder<GenericSuccessResponse> {
        let basePath = self.client.basePath;
        let localVariablePath = "/integrations/s3/files"
        let localVariableURLString = basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: s3FileSyncInput)

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        var localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        do {
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: self.client.accessToken, prefix: "Token ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: self.client.apiKey, prefix: "Bearer ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "customer-id", value: self.client.customerId, prefix: nil)
            let localVariableRequestBuilder: RequestBuilder<GenericSuccessResponse>.Type = CarbonAPI.requestBuilderFactory.getBuilder()
            let URLString = localVariableUrlComponents?.string ?? localVariableURLString
            return localVariableRequestBuilder.init(method: "POST", URLString: URLString, parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
        } catch {
            print("Error: \(error)")
        }
        fatalError("Error: Unable to send request to POST /integrations/s3/files")
    }

}
